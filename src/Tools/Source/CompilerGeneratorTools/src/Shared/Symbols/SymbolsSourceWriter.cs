using System.Xml.Linq;
using Luna.Compilers.Generators.Symbols.Model;
using Luna.Compilers.Generators.Syntax.Model;
using SamLu.CodeAnalysis;

namespace Luna.Compilers.Generators.Symbols;

internal class SymbolsSourceWriter : SymbolsFileWriter
{
    private SymbolsSourceWriter(TextWriter writer, SymbolTree tree, CancellationToken cancellationToken) : base(writer, tree, cancellationToken) { }

    public static void WriteInternal(TextWriter writer, SymbolTree tree, CancellationToken cancellationToken = default) => new SymbolsSourceWriter(writer, tree, cancellationToken).WriteInternal();

    public static void WritePublic(TextWriter writer, SymbolTree tree, CancellationToken cancellationToken = default) => new SymbolsSourceWriter(writer, tree, cancellationToken).WritePublic();

    private void WriteFileHeader()
    {
        WriteLine("// <auto-generated />");
        WriteLine();
        WriteLine("#nullable enable");
        WriteLine();
        WriteLine("using System;");
        WriteLine("using System.Collections.Generic;");
        WriteLine("using Microsoft.CodeAnalysis;");
        WriteLine("using Microsoft.CodeAnalysis.Symbols;");
        WriteLine($"using SamLu.CodeAnalysis.{LanguageNames.This};");
        WriteLine("using Roslyn.Utilities;");
        WriteLine();
    }

    private void WriteInternal()
    {
        WriteFileHeader();
        WriteLine($"namespace SamLu.CodeAnalysis.{LanguageNames.This}.Symbols");
        OpenBlock();
        this.WriteInternalSymbols();
        this.WriteInternalVisitors();
        CloseBlock();
    }

    private void WritePublic()
    {
        WriteFileHeader();
        WriteLine($"namespace SamLu.CodeAnalysis.{LanguageNames.This}.Symbols.PublicModel");
        OpenBlock();
        this.WritePublicSymbols();
        this.WritePublicVisitors();
        CloseBlock();
    }

    private void WriteInternalSymbols()
    {
        var symbols = this.Tree.Types.Where(n => n is not PredefinedSymbol).ToList();
        foreach (var symbol in symbols)
        {
            WriteLine();
            this.WriteInternalSymbol(symbol);
        }
    }

    private void WriteInternalSymbol(SymbolTreeType symbol)
    {
        if (symbol is AbstractSymbol or Symbol)
        {
            WriteLine($"internal abstract partial class {symbol.Name} : {symbol.Base}");
            OpenBlock();

            this.WriteInternalAcceptMethods(symbol);

            CloseBlock();
        }
    }

    private void WriteInternalAcceptMethods(SymbolTreeType symbol)
    {
        WriteLine();
        WriteLine($"public override void Accept({LanguageNames.This}SymbolVisitor visitor) => visitor.Visit{StripPost(symbol.Name, "Symbol")}(this);");
        WriteLine($"public override TResult? Accept<TResult>({LanguageNames.This}SymbolVisitor<TResult> visitor) where TResult : default => visitor.Visit{StripPost(symbol.Name, "Symbol")}(this);");
        WriteLine($"internal override TResult? Accept<TArgument, TResult>({LanguageNames.This}SymbolVisitor<TArgument, TResult> visitor, TArgument argument) where TResult : default => visitor.Visit{StripPost(symbol.Name, "Symbol")}(this, argument);");
    }
}
