// <auto-generated />

#nullable enable

using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Syntax.InternalSyntax;
using SamLu.CodeAnalysis.MoonScript;
using Roslyn.Utilities;

namespace SamLu.CodeAnalysis.MoonScript.Syntax.InternalSyntax
{


    /// <summary>提供表示名称语法节点继承用的父类，此类必须被继承。</summary>
    internal abstract partial class NameSyntax : MoonScriptSyntaxNode
    {
        internal NameSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal NameSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected NameSyntax(ObjectReader reader)
          : base(reader)
        {
        }
    }

    /// <summary>提供表示简单名称语法节点继承用的父类，此类必须被继承。</summary>
    internal abstract partial class SimpleNameSyntax : NameSyntax
    {
        internal SimpleNameSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal SimpleNameSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected SimpleNameSyntax(ObjectReader reader)
          : base(reader)
        {
        }

        /// <summary>表示简单名称的语法标志。</summary>
        public abstract SyntaxToken Identifier { get; }
    }

    /// <summary>Class which represents the syntax node for identifier name.</summary>
    internal sealed partial class IdentifierNameSyntax : SimpleNameSyntax
    {
        internal readonly SyntaxToken identifier;

        internal IdentifierNameSyntax(SyntaxKind kind, SyntaxToken identifier, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
        }

        internal IdentifierNameSyntax(SyntaxKind kind, SyntaxToken identifier, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
        }

        internal IdentifierNameSyntax(SyntaxKind kind, SyntaxToken identifier)
          : base(kind)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
        }

        /// <summary>SyntaxToken representing the keyword for the kind of the identifier name.</summary>
        public override SyntaxToken Identifier => this.identifier;

        internal override GreenNode? GetSlot(int index)
            => index == 0 ? this.identifier : null;

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.IdentifierNameSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitIdentifierName(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitIdentifierName(this);

        public IdentifierNameSyntax Update(SyntaxToken identifier)
        {
            if (identifier != this.Identifier)
            {
                var newNode = SyntaxFactory.IdentifierName(identifier);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new IdentifierNameSyntax(this.Kind, this.identifier, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new IdentifierNameSyntax(this.Kind, this.identifier, GetDiagnostics(), annotations);

        internal IdentifierNameSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 1;
            var identifier = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.identifier);
        }

        static IdentifierNameSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(IdentifierNameSyntax), r => new IdentifierNameSyntax(r));
        }
    }

    /// <summary>Provides the base class from which the classes that represent expression syntax nodes are derived. This is an abstract class.</summary>
    internal abstract partial class ExpressionSyntax : MoonScriptSyntaxNode
    {
        internal ExpressionSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal ExpressionSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected ExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
        }
    }

    /// <summary>Class which represents the syntax node for a literal expression.</summary>
    internal sealed partial class LiteralExpressionSyntax : ExpressionSyntax
    {
        internal readonly SyntaxToken token;

        internal LiteralExpressionSyntax(SyntaxKind kind, SyntaxToken token, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(token);
            this.token = token;
        }

        internal LiteralExpressionSyntax(SyntaxKind kind, SyntaxToken token, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(token);
            this.token = token;
        }

        internal LiteralExpressionSyntax(SyntaxKind kind, SyntaxToken token)
          : base(kind)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(token);
            this.token = token;
        }

        /// <summary>SyntaxToken representing the keyword corresponding to the kind of the literal expression.</summary>
        public SyntaxToken Token => this.token;

        internal override GreenNode? GetSlot(int index)
            => index == 0 ? this.token : null;

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.LiteralExpressionSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitLiteralExpression(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitLiteralExpression(this);

        public LiteralExpressionSyntax Update(SyntaxToken token)
        {
            if (token != this.Token)
            {
                var newNode = SyntaxFactory.LiteralExpression(this.Kind, token);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new LiteralExpressionSyntax(this.Kind, this.token, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new LiteralExpressionSyntax(this.Kind, this.token, GetDiagnostics(), annotations);

        internal LiteralExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 1;
            var token = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(token);
            this.token = token;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.token);
        }

        static LiteralExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(LiteralExpressionSyntax), r => new LiteralExpressionSyntax(r));
        }
    }

    internal abstract partial class BaseInstanceExpressionSyntax : ExpressionSyntax
    {
        internal BaseInstanceExpressionSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal BaseInstanceExpressionSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected BaseInstanceExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
        }

        public abstract SyntaxToken Token { get; }
    }

    internal sealed partial class SelfExpressionSyntax : BaseInstanceExpressionSyntax
    {
        internal readonly SyntaxToken token;

        internal SelfExpressionSyntax(SyntaxKind kind, SyntaxToken token, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(token);
            this.token = token;
        }

        internal SelfExpressionSyntax(SyntaxKind kind, SyntaxToken token, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(token);
            this.token = token;
        }

        internal SelfExpressionSyntax(SyntaxKind kind, SyntaxToken token)
          : base(kind)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(token);
            this.token = token;
        }

        public override SyntaxToken Token => this.token;

        internal override GreenNode? GetSlot(int index)
            => index == 0 ? this.token : null;

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.SelfExpressionSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitSelfExpression(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitSelfExpression(this);

        public SelfExpressionSyntax Update(SyntaxToken token)
        {
            if (token != this.Token)
            {
                var newNode = SyntaxFactory.SelfExpression(token);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new SelfExpressionSyntax(this.Kind, this.token, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new SelfExpressionSyntax(this.Kind, this.token, GetDiagnostics(), annotations);

        internal SelfExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 1;
            var token = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(token);
            this.token = token;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.token);
        }

        static SelfExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(SelfExpressionSyntax), r => new SelfExpressionSyntax(r));
        }
    }

    internal sealed partial class SuperExpressionSyntax : BaseInstanceExpressionSyntax
    {
        internal readonly SyntaxToken token;

        internal SuperExpressionSyntax(SyntaxKind kind, SyntaxToken token, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(token);
            this.token = token;
        }

        internal SuperExpressionSyntax(SyntaxKind kind, SyntaxToken token, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(token);
            this.token = token;
        }

        internal SuperExpressionSyntax(SyntaxKind kind, SyntaxToken token)
          : base(kind)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(token);
            this.token = token;
        }

        public override SyntaxToken Token => this.token;

        internal override GreenNode? GetSlot(int index)
            => index == 0 ? this.token : null;

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.SuperExpressionSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitSuperExpression(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitSuperExpression(this);

        public SuperExpressionSyntax Update(SyntaxToken token)
        {
            if (token != this.Token)
            {
                var newNode = SyntaxFactory.SuperExpression(token);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new SuperExpressionSyntax(this.Kind, this.token, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new SuperExpressionSyntax(this.Kind, this.token, GetDiagnostics(), annotations);

        internal SuperExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 1;
            var token = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(token);
            this.token = token;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.token);
        }

        static SuperExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(SuperExpressionSyntax), r => new SuperExpressionSyntax(r));
        }
    }

    internal sealed partial class TypeExpressionSyntax : BaseInstanceExpressionSyntax
    {
        internal readonly SyntaxToken token;

        internal TypeExpressionSyntax(SyntaxKind kind, SyntaxToken token, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(token);
            this.token = token;
        }

        internal TypeExpressionSyntax(SyntaxKind kind, SyntaxToken token, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(token);
            this.token = token;
        }

        internal TypeExpressionSyntax(SyntaxKind kind, SyntaxToken token)
          : base(kind)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(token);
            this.token = token;
        }

        public override SyntaxToken Token => this.token;

        internal override GreenNode? GetSlot(int index)
            => index == 0 ? this.token : null;

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.TypeExpressionSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitTypeExpression(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitTypeExpression(this);

        public TypeExpressionSyntax Update(SyntaxToken token)
        {
            if (token != this.Token)
            {
                var newNode = SyntaxFactory.TypeExpression(token);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new TypeExpressionSyntax(this.Kind, this.token, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new TypeExpressionSyntax(this.Kind, this.token, GetDiagnostics(), annotations);

        internal TypeExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 1;
            var token = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(token);
            this.token = token;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.token);
        }

        static TypeExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(TypeExpressionSyntax), r => new TypeExpressionSyntax(r));
        }
    }

    /// <summary>Class which represents the syntax node for parenthesized expression.</summary>
    internal sealed partial class ParenthesizedExpressionSyntax : ExpressionSyntax
    {
        internal readonly SyntaxToken openParenToken;
        internal readonly ExpressionSyntax expression;
        internal readonly SyntaxToken closeParenToken;

        internal ParenthesizedExpressionSyntax(SyntaxKind kind, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal ParenthesizedExpressionSyntax(SyntaxKind kind, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal ParenthesizedExpressionSyntax(SyntaxKind kind, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        /// <summary>SyntaxToken representing the open parenthesis.</summary>
        public SyntaxToken OpenParenToken => this.openParenToken;
        /// <summary>ExpressionSyntax node representing the expression enclosed within the parenthesis.</summary>
        public ExpressionSyntax Expression => this.expression;
        /// <summary>SyntaxToken representing the close parenthesis.</summary>
        public SyntaxToken CloseParenToken => this.closeParenToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.openParenToken,
                1 => this.expression,
                2 => this.closeParenToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.ParenthesizedExpressionSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitParenthesizedExpression(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitParenthesizedExpression(this);

        public ParenthesizedExpressionSyntax Update(SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
        {
            if (openParenToken != this.OpenParenToken || expression != this.Expression || closeParenToken != this.CloseParenToken)
            {
                var newNode = SyntaxFactory.ParenthesizedExpression(openParenToken, expression, closeParenToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ParenthesizedExpressionSyntax(this.Kind, this.openParenToken, this.expression, this.closeParenToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ParenthesizedExpressionSyntax(this.Kind, this.openParenToken, this.expression, this.closeParenToken, GetDiagnostics(), annotations);

        internal ParenthesizedExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var openParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            var expression = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(expression);
            this.expression = expression;
            var closeParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.openParenToken);
            writer.WriteValue(this.expression);
            writer.WriteValue(this.closeParenToken);
        }

        static ParenthesizedExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ParenthesizedExpressionSyntax), r => new ParenthesizedExpressionSyntax(r));
        }
    }

    internal sealed partial class ClassExpressionSyntax : ExpressionSyntax
    {
        internal readonly SyntaxToken classKeyword;
        internal readonly IdentifierNameSyntax name;
        internal readonly SyntaxToken extendsKeyword;
        internal readonly IdentifierNameSyntax baseName;
        internal readonly GreenNode? statements;

        internal ClassExpressionSyntax(SyntaxKind kind, SyntaxToken classKeyword, IdentifierNameSyntax name, SyntaxToken extendsKeyword, IdentifierNameSyntax baseName, GreenNode? statements, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(classKeyword);
            this.classKeyword = classKeyword;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(extendsKeyword);
            this.extendsKeyword = extendsKeyword;
            this.AdjustFlagsAndWidth(baseName);
            this.baseName = baseName;
            if (statements != null)
            {
                this.AdjustFlagsAndWidth(statements);
                this.statements = statements;
            }
        }

        internal ClassExpressionSyntax(SyntaxKind kind, SyntaxToken classKeyword, IdentifierNameSyntax name, SyntaxToken extendsKeyword, IdentifierNameSyntax baseName, GreenNode? statements, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(classKeyword);
            this.classKeyword = classKeyword;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(extendsKeyword);
            this.extendsKeyword = extendsKeyword;
            this.AdjustFlagsAndWidth(baseName);
            this.baseName = baseName;
            if (statements != null)
            {
                this.AdjustFlagsAndWidth(statements);
                this.statements = statements;
            }
        }

        internal ClassExpressionSyntax(SyntaxKind kind, SyntaxToken classKeyword, IdentifierNameSyntax name, SyntaxToken extendsKeyword, IdentifierNameSyntax baseName, GreenNode? statements)
          : base(kind)
        {
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(classKeyword);
            this.classKeyword = classKeyword;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(extendsKeyword);
            this.extendsKeyword = extendsKeyword;
            this.AdjustFlagsAndWidth(baseName);
            this.baseName = baseName;
            if (statements != null)
            {
                this.AdjustFlagsAndWidth(statements);
                this.statements = statements;
            }
        }

        public SyntaxToken ClassKeyword => this.classKeyword;
        public IdentifierNameSyntax Name => this.name;
        public SyntaxToken ExtendsKeyword => this.extendsKeyword;
        public IdentifierNameSyntax BaseName => this.baseName;
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<StatementSyntax> Statements => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<StatementSyntax>(this.statements);

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.classKeyword,
                1 => this.name,
                2 => this.extendsKeyword,
                3 => this.baseName,
                4 => this.statements,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.ClassExpressionSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitClassExpression(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitClassExpression(this);

        public ClassExpressionSyntax Update(SyntaxToken classKeyword, IdentifierNameSyntax name, SyntaxToken extendsKeyword, IdentifierNameSyntax baseName, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<StatementSyntax> statements)
        {
            if (classKeyword != this.ClassKeyword || name != this.Name || extendsKeyword != this.ExtendsKeyword || baseName != this.BaseName || statements != this.Statements)
            {
                var newNode = SyntaxFactory.ClassExpression(classKeyword, name, extendsKeyword, baseName, statements);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ClassExpressionSyntax(this.Kind, this.classKeyword, this.name, this.extendsKeyword, this.baseName, this.statements, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ClassExpressionSyntax(this.Kind, this.classKeyword, this.name, this.extendsKeyword, this.baseName, this.statements, GetDiagnostics(), annotations);

        internal ClassExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 5;
            var classKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(classKeyword);
            this.classKeyword = classKeyword;
            var name = (IdentifierNameSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(name);
            this.name = name;
            var extendsKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(extendsKeyword);
            this.extendsKeyword = extendsKeyword;
            var baseName = (IdentifierNameSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(baseName);
            this.baseName = baseName;
            var statements = (GreenNode?)reader.ReadValue();
            if (statements != null)
            {
                AdjustFlagsAndWidth(statements);
                this.statements = statements;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.classKeyword);
            writer.WriteValue(this.name);
            writer.WriteValue(this.extendsKeyword);
            writer.WriteValue(this.baseName);
            writer.WriteValue(this.statements);
        }

        static ClassExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ClassExpressionSyntax), r => new ClassExpressionSyntax(r));
        }
    }

    internal sealed partial class AnomymousClassExpressionSyntax : ExpressionSyntax
    {
        internal readonly SyntaxToken classKeyword;
        internal readonly SyntaxToken extendsKeyword;
        internal readonly IdentifierNameSyntax baseName;
        internal readonly GreenNode? statements;

        internal AnomymousClassExpressionSyntax(SyntaxKind kind, SyntaxToken classKeyword, SyntaxToken extendsKeyword, IdentifierNameSyntax baseName, GreenNode? statements, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(classKeyword);
            this.classKeyword = classKeyword;
            this.AdjustFlagsAndWidth(extendsKeyword);
            this.extendsKeyword = extendsKeyword;
            this.AdjustFlagsAndWidth(baseName);
            this.baseName = baseName;
            if (statements != null)
            {
                this.AdjustFlagsAndWidth(statements);
                this.statements = statements;
            }
        }

        internal AnomymousClassExpressionSyntax(SyntaxKind kind, SyntaxToken classKeyword, SyntaxToken extendsKeyword, IdentifierNameSyntax baseName, GreenNode? statements, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(classKeyword);
            this.classKeyword = classKeyword;
            this.AdjustFlagsAndWidth(extendsKeyword);
            this.extendsKeyword = extendsKeyword;
            this.AdjustFlagsAndWidth(baseName);
            this.baseName = baseName;
            if (statements != null)
            {
                this.AdjustFlagsAndWidth(statements);
                this.statements = statements;
            }
        }

        internal AnomymousClassExpressionSyntax(SyntaxKind kind, SyntaxToken classKeyword, SyntaxToken extendsKeyword, IdentifierNameSyntax baseName, GreenNode? statements)
          : base(kind)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(classKeyword);
            this.classKeyword = classKeyword;
            this.AdjustFlagsAndWidth(extendsKeyword);
            this.extendsKeyword = extendsKeyword;
            this.AdjustFlagsAndWidth(baseName);
            this.baseName = baseName;
            if (statements != null)
            {
                this.AdjustFlagsAndWidth(statements);
                this.statements = statements;
            }
        }

        public SyntaxToken ClassKeyword => this.classKeyword;
        public SyntaxToken ExtendsKeyword => this.extendsKeyword;
        public IdentifierNameSyntax BaseName => this.baseName;
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<StatementSyntax> Statements => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<StatementSyntax>(this.statements);

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.classKeyword,
                1 => this.extendsKeyword,
                2 => this.baseName,
                3 => this.statements,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.AnomymousClassExpressionSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitAnomymousClassExpression(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitAnomymousClassExpression(this);

        public AnomymousClassExpressionSyntax Update(SyntaxToken classKeyword, SyntaxToken extendsKeyword, IdentifierNameSyntax baseName, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<StatementSyntax> statements)
        {
            if (classKeyword != this.ClassKeyword || extendsKeyword != this.ExtendsKeyword || baseName != this.BaseName || statements != this.Statements)
            {
                var newNode = SyntaxFactory.AnomymousClassExpression(classKeyword, extendsKeyword, baseName, statements);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new AnomymousClassExpressionSyntax(this.Kind, this.classKeyword, this.extendsKeyword, this.baseName, this.statements, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new AnomymousClassExpressionSyntax(this.Kind, this.classKeyword, this.extendsKeyword, this.baseName, this.statements, GetDiagnostics(), annotations);

        internal AnomymousClassExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var classKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(classKeyword);
            this.classKeyword = classKeyword;
            var extendsKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(extendsKeyword);
            this.extendsKeyword = extendsKeyword;
            var baseName = (IdentifierNameSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(baseName);
            this.baseName = baseName;
            var statements = (GreenNode?)reader.ReadValue();
            if (statements != null)
            {
                AdjustFlagsAndWidth(statements);
                this.statements = statements;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.classKeyword);
            writer.WriteValue(this.extendsKeyword);
            writer.WriteValue(this.baseName);
            writer.WriteValue(this.statements);
        }

        static AnomymousClassExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(AnomymousClassExpressionSyntax), r => new AnomymousClassExpressionSyntax(r));
        }
    }

    internal sealed partial class DoExpressionSyntax : ExpressionSyntax
    {
        internal readonly SyntaxToken doKeyword;
        internal readonly BlockSyntax block;

        internal DoExpressionSyntax(SyntaxKind kind, SyntaxToken doKeyword, BlockSyntax block, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(doKeyword);
            this.doKeyword = doKeyword;
            this.AdjustFlagsAndWidth(block);
            this.block = block;
        }

        internal DoExpressionSyntax(SyntaxKind kind, SyntaxToken doKeyword, BlockSyntax block, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(doKeyword);
            this.doKeyword = doKeyword;
            this.AdjustFlagsAndWidth(block);
            this.block = block;
        }

        internal DoExpressionSyntax(SyntaxKind kind, SyntaxToken doKeyword, BlockSyntax block)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(doKeyword);
            this.doKeyword = doKeyword;
            this.AdjustFlagsAndWidth(block);
            this.block = block;
        }

        public SyntaxToken DoKeyword => this.doKeyword;
        public BlockSyntax Block => this.block;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.doKeyword,
                1 => this.block,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.DoExpressionSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitDoExpression(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitDoExpression(this);

        public DoExpressionSyntax Update(SyntaxToken doKeyword, BlockSyntax block)
        {
            if (doKeyword != this.DoKeyword || block != this.Block)
            {
                var newNode = SyntaxFactory.DoExpression(doKeyword, block);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new DoExpressionSyntax(this.Kind, this.doKeyword, this.block, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new DoExpressionSyntax(this.Kind, this.doKeyword, this.block, GetDiagnostics(), annotations);

        internal DoExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var doKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(doKeyword);
            this.doKeyword = doKeyword;
            var block = (BlockSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(block);
            this.block = block;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.doKeyword);
            writer.WriteValue(this.block);
        }

        static DoExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(DoExpressionSyntax), r => new DoExpressionSyntax(r));
        }
    }

    internal sealed partial class ForExpressionSyntax : ExpressionSyntax
    {
        internal readonly SyntaxToken forKeyword;
        internal readonly IdentifierNameSyntax name;
        internal readonly SyntaxToken equalsToken;
        internal readonly ExpressionSyntax initial;
        internal readonly SyntaxToken firstCommaToken;
        internal readonly ExpressionSyntax limit;
        internal readonly SyntaxToken secondCommaToken;
        internal readonly ExpressionSyntax step;
        internal readonly SyntaxToken? doKeyword;
        internal readonly BlockSyntax block;

        internal ForExpressionSyntax(SyntaxKind kind, SyntaxToken forKeyword, IdentifierNameSyntax name, SyntaxToken equalsToken, ExpressionSyntax initial, SyntaxToken firstCommaToken, ExpressionSyntax limit, SyntaxToken secondCommaToken, ExpressionSyntax step, SyntaxToken? doKeyword, BlockSyntax block, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 10;
            this.AdjustFlagsAndWidth(forKeyword);
            this.forKeyword = forKeyword;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            this.AdjustFlagsAndWidth(initial);
            this.initial = initial;
            this.AdjustFlagsAndWidth(firstCommaToken);
            this.firstCommaToken = firstCommaToken;
            this.AdjustFlagsAndWidth(limit);
            this.limit = limit;
            this.AdjustFlagsAndWidth(secondCommaToken);
            this.secondCommaToken = secondCommaToken;
            this.AdjustFlagsAndWidth(step);
            this.step = step;
            if (doKeyword != null)
            {
                this.AdjustFlagsAndWidth(doKeyword);
                this.doKeyword = doKeyword;
            }
            this.AdjustFlagsAndWidth(block);
            this.block = block;
        }

        internal ForExpressionSyntax(SyntaxKind kind, SyntaxToken forKeyword, IdentifierNameSyntax name, SyntaxToken equalsToken, ExpressionSyntax initial, SyntaxToken firstCommaToken, ExpressionSyntax limit, SyntaxToken secondCommaToken, ExpressionSyntax step, SyntaxToken? doKeyword, BlockSyntax block, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 10;
            this.AdjustFlagsAndWidth(forKeyword);
            this.forKeyword = forKeyword;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            this.AdjustFlagsAndWidth(initial);
            this.initial = initial;
            this.AdjustFlagsAndWidth(firstCommaToken);
            this.firstCommaToken = firstCommaToken;
            this.AdjustFlagsAndWidth(limit);
            this.limit = limit;
            this.AdjustFlagsAndWidth(secondCommaToken);
            this.secondCommaToken = secondCommaToken;
            this.AdjustFlagsAndWidth(step);
            this.step = step;
            if (doKeyword != null)
            {
                this.AdjustFlagsAndWidth(doKeyword);
                this.doKeyword = doKeyword;
            }
            this.AdjustFlagsAndWidth(block);
            this.block = block;
        }

        internal ForExpressionSyntax(SyntaxKind kind, SyntaxToken forKeyword, IdentifierNameSyntax name, SyntaxToken equalsToken, ExpressionSyntax initial, SyntaxToken firstCommaToken, ExpressionSyntax limit, SyntaxToken secondCommaToken, ExpressionSyntax step, SyntaxToken? doKeyword, BlockSyntax block)
          : base(kind)
        {
            this.SlotCount = 10;
            this.AdjustFlagsAndWidth(forKeyword);
            this.forKeyword = forKeyword;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            this.AdjustFlagsAndWidth(initial);
            this.initial = initial;
            this.AdjustFlagsAndWidth(firstCommaToken);
            this.firstCommaToken = firstCommaToken;
            this.AdjustFlagsAndWidth(limit);
            this.limit = limit;
            this.AdjustFlagsAndWidth(secondCommaToken);
            this.secondCommaToken = secondCommaToken;
            this.AdjustFlagsAndWidth(step);
            this.step = step;
            if (doKeyword != null)
            {
                this.AdjustFlagsAndWidth(doKeyword);
                this.doKeyword = doKeyword;
            }
            this.AdjustFlagsAndWidth(block);
            this.block = block;
        }

        public SyntaxToken ForKeyword => this.forKeyword;
        public IdentifierNameSyntax Name => this.name;
        public SyntaxToken EqualsToken => this.equalsToken;
        public ExpressionSyntax Initial => this.initial;
        public SyntaxToken FirstCommaToken => this.firstCommaToken;
        public ExpressionSyntax Limit => this.limit;
        public SyntaxToken SecondCommaToken => this.secondCommaToken;
        public ExpressionSyntax Step => this.step;
        public SyntaxToken? DoKeyword => this.doKeyword;
        public BlockSyntax Block => this.block;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.forKeyword,
                1 => this.name,
                2 => this.equalsToken,
                3 => this.initial,
                4 => this.firstCommaToken,
                5 => this.limit,
                6 => this.secondCommaToken,
                7 => this.step,
                8 => this.doKeyword,
                9 => this.block,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.ForExpressionSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitForExpression(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitForExpression(this);

        public ForExpressionSyntax Update(SyntaxToken forKeyword, IdentifierNameSyntax name, SyntaxToken equalsToken, ExpressionSyntax initial, SyntaxToken firstCommaToken, ExpressionSyntax limit, SyntaxToken secondCommaToken, ExpressionSyntax step, SyntaxToken doKeyword, BlockSyntax block)
        {
            if (forKeyword != this.ForKeyword || name != this.Name || equalsToken != this.EqualsToken || initial != this.Initial || firstCommaToken != this.FirstCommaToken || limit != this.Limit || secondCommaToken != this.SecondCommaToken || step != this.Step || doKeyword != this.DoKeyword || block != this.Block)
            {
                var newNode = SyntaxFactory.ForExpression(forKeyword, name, equalsToken, initial, firstCommaToken, limit, secondCommaToken, step, doKeyword, block);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ForExpressionSyntax(this.Kind, this.forKeyword, this.name, this.equalsToken, this.initial, this.firstCommaToken, this.limit, this.secondCommaToken, this.step, this.doKeyword, this.block, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ForExpressionSyntax(this.Kind, this.forKeyword, this.name, this.equalsToken, this.initial, this.firstCommaToken, this.limit, this.secondCommaToken, this.step, this.doKeyword, this.block, GetDiagnostics(), annotations);

        internal ForExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 10;
            var forKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(forKeyword);
            this.forKeyword = forKeyword;
            var name = (IdentifierNameSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(name);
            this.name = name;
            var equalsToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            var initial = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(initial);
            this.initial = initial;
            var firstCommaToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(firstCommaToken);
            this.firstCommaToken = firstCommaToken;
            var limit = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(limit);
            this.limit = limit;
            var secondCommaToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(secondCommaToken);
            this.secondCommaToken = secondCommaToken;
            var step = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(step);
            this.step = step;
            var doKeyword = (SyntaxToken?)reader.ReadValue();
            if (doKeyword != null)
            {
                AdjustFlagsAndWidth(doKeyword);
                this.doKeyword = doKeyword;
            }
            var block = (BlockSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(block);
            this.block = block;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.forKeyword);
            writer.WriteValue(this.name);
            writer.WriteValue(this.equalsToken);
            writer.WriteValue(this.initial);
            writer.WriteValue(this.firstCommaToken);
            writer.WriteValue(this.limit);
            writer.WriteValue(this.secondCommaToken);
            writer.WriteValue(this.step);
            writer.WriteValue(this.doKeyword);
            writer.WriteValue(this.block);
        }

        static ForExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ForExpressionSyntax), r => new ForExpressionSyntax(r));
        }
    }

    internal sealed partial class ForInExpressionSyntax : ExpressionSyntax
    {
        internal readonly SyntaxToken forKeyword;
        internal readonly GreenNode? names;
        internal readonly SyntaxToken inKeyword;
        internal readonly ExpressionSyntax iteration;
        internal readonly SyntaxToken? doKeyword;
        internal readonly BlockSyntax block;

        internal ForInExpressionSyntax(SyntaxKind kind, SyntaxToken forKeyword, GreenNode? names, SyntaxToken inKeyword, ExpressionSyntax iteration, SyntaxToken? doKeyword, BlockSyntax block, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 6;
            this.AdjustFlagsAndWidth(forKeyword);
            this.forKeyword = forKeyword;
            if (names != null)
            {
                this.AdjustFlagsAndWidth(names);
                this.names = names;
            }
            this.AdjustFlagsAndWidth(inKeyword);
            this.inKeyword = inKeyword;
            this.AdjustFlagsAndWidth(iteration);
            this.iteration = iteration;
            if (doKeyword != null)
            {
                this.AdjustFlagsAndWidth(doKeyword);
                this.doKeyword = doKeyword;
            }
            this.AdjustFlagsAndWidth(block);
            this.block = block;
        }

        internal ForInExpressionSyntax(SyntaxKind kind, SyntaxToken forKeyword, GreenNode? names, SyntaxToken inKeyword, ExpressionSyntax iteration, SyntaxToken? doKeyword, BlockSyntax block, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 6;
            this.AdjustFlagsAndWidth(forKeyword);
            this.forKeyword = forKeyword;
            if (names != null)
            {
                this.AdjustFlagsAndWidth(names);
                this.names = names;
            }
            this.AdjustFlagsAndWidth(inKeyword);
            this.inKeyword = inKeyword;
            this.AdjustFlagsAndWidth(iteration);
            this.iteration = iteration;
            if (doKeyword != null)
            {
                this.AdjustFlagsAndWidth(doKeyword);
                this.doKeyword = doKeyword;
            }
            this.AdjustFlagsAndWidth(block);
            this.block = block;
        }

        internal ForInExpressionSyntax(SyntaxKind kind, SyntaxToken forKeyword, GreenNode? names, SyntaxToken inKeyword, ExpressionSyntax iteration, SyntaxToken? doKeyword, BlockSyntax block)
          : base(kind)
        {
            this.SlotCount = 6;
            this.AdjustFlagsAndWidth(forKeyword);
            this.forKeyword = forKeyword;
            if (names != null)
            {
                this.AdjustFlagsAndWidth(names);
                this.names = names;
            }
            this.AdjustFlagsAndWidth(inKeyword);
            this.inKeyword = inKeyword;
            this.AdjustFlagsAndWidth(iteration);
            this.iteration = iteration;
            if (doKeyword != null)
            {
                this.AdjustFlagsAndWidth(doKeyword);
                this.doKeyword = doKeyword;
            }
            this.AdjustFlagsAndWidth(block);
            this.block = block;
        }

        public SyntaxToken ForKeyword => this.forKeyword;
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<IdentifierNameSyntax> Names => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<IdentifierNameSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MoonScriptSyntaxNode>(this.names));
        public SyntaxToken InKeyword => this.inKeyword;
        public ExpressionSyntax Iteration => this.iteration;
        public SyntaxToken? DoKeyword => this.doKeyword;
        public BlockSyntax Block => this.block;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.forKeyword,
                1 => this.names,
                2 => this.inKeyword,
                3 => this.iteration,
                4 => this.doKeyword,
                5 => this.block,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.ForInExpressionSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitForInExpression(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitForInExpression(this);

        public ForInExpressionSyntax Update(SyntaxToken forKeyword, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<IdentifierNameSyntax> names, SyntaxToken inKeyword, ExpressionSyntax iteration, SyntaxToken doKeyword, BlockSyntax block)
        {
            if (forKeyword != this.ForKeyword || names != this.Names || inKeyword != this.InKeyword || iteration != this.Iteration || doKeyword != this.DoKeyword || block != this.Block)
            {
                var newNode = SyntaxFactory.ForInExpression(forKeyword, names, inKeyword, iteration, doKeyword, block);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ForInExpressionSyntax(this.Kind, this.forKeyword, this.names, this.inKeyword, this.iteration, this.doKeyword, this.block, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ForInExpressionSyntax(this.Kind, this.forKeyword, this.names, this.inKeyword, this.iteration, this.doKeyword, this.block, GetDiagnostics(), annotations);

        internal ForInExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 6;
            var forKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(forKeyword);
            this.forKeyword = forKeyword;
            var names = (GreenNode?)reader.ReadValue();
            if (names != null)
            {
                AdjustFlagsAndWidth(names);
                this.names = names;
            }
            var inKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(inKeyword);
            this.inKeyword = inKeyword;
            var iteration = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(iteration);
            this.iteration = iteration;
            var doKeyword = (SyntaxToken?)reader.ReadValue();
            if (doKeyword != null)
            {
                AdjustFlagsAndWidth(doKeyword);
                this.doKeyword = doKeyword;
            }
            var block = (BlockSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(block);
            this.block = block;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.forKeyword);
            writer.WriteValue(this.names);
            writer.WriteValue(this.inKeyword);
            writer.WriteValue(this.iteration);
            writer.WriteValue(this.doKeyword);
            writer.WriteValue(this.block);
        }

        static ForInExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ForInExpressionSyntax), r => new ForInExpressionSyntax(r));
        }
    }

    internal abstract partial class BaseConditionalExpressionSyntax : ExpressionSyntax
    {
        internal BaseConditionalExpressionSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal BaseConditionalExpressionSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected BaseConditionalExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
        }

        public abstract ExpressionSyntax Condition { get; }

        public abstract BlockSyntax Block { get; }
    }

    internal sealed partial class IfExpressionSyntax : BaseConditionalExpressionSyntax
    {
        internal readonly SyntaxToken ifKeyword;
        internal readonly ExpressionSyntax condition;
        internal readonly SyntaxToken? thenKeyword;
        internal readonly BlockSyntax block;
        internal readonly GreenNode? elseIfs;
        internal readonly ElseClauseSyntax? @else;

        internal IfExpressionSyntax(SyntaxKind kind, SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken? thenKeyword, BlockSyntax block, GreenNode? elseIfs, ElseClauseSyntax? @else, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 6;
            this.AdjustFlagsAndWidth(ifKeyword);
            this.ifKeyword = ifKeyword;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            if (thenKeyword != null)
            {
                this.AdjustFlagsAndWidth(thenKeyword);
                this.thenKeyword = thenKeyword;
            }
            this.AdjustFlagsAndWidth(block);
            this.block = block;
            if (elseIfs != null)
            {
                this.AdjustFlagsAndWidth(elseIfs);
                this.elseIfs = elseIfs;
            }
            if (@else != null)
            {
                this.AdjustFlagsAndWidth(@else);
                this.@else = @else;
            }
        }

        internal IfExpressionSyntax(SyntaxKind kind, SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken? thenKeyword, BlockSyntax block, GreenNode? elseIfs, ElseClauseSyntax? @else, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 6;
            this.AdjustFlagsAndWidth(ifKeyword);
            this.ifKeyword = ifKeyword;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            if (thenKeyword != null)
            {
                this.AdjustFlagsAndWidth(thenKeyword);
                this.thenKeyword = thenKeyword;
            }
            this.AdjustFlagsAndWidth(block);
            this.block = block;
            if (elseIfs != null)
            {
                this.AdjustFlagsAndWidth(elseIfs);
                this.elseIfs = elseIfs;
            }
            if (@else != null)
            {
                this.AdjustFlagsAndWidth(@else);
                this.@else = @else;
            }
        }

        internal IfExpressionSyntax(SyntaxKind kind, SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken? thenKeyword, BlockSyntax block, GreenNode? elseIfs, ElseClauseSyntax? @else)
          : base(kind)
        {
            this.SlotCount = 6;
            this.AdjustFlagsAndWidth(ifKeyword);
            this.ifKeyword = ifKeyword;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            if (thenKeyword != null)
            {
                this.AdjustFlagsAndWidth(thenKeyword);
                this.thenKeyword = thenKeyword;
            }
            this.AdjustFlagsAndWidth(block);
            this.block = block;
            if (elseIfs != null)
            {
                this.AdjustFlagsAndWidth(elseIfs);
                this.elseIfs = elseIfs;
            }
            if (@else != null)
            {
                this.AdjustFlagsAndWidth(@else);
                this.@else = @else;
            }
        }

        public SyntaxToken IfKeyword => this.ifKeyword;
        public override ExpressionSyntax Condition => this.condition;
        public SyntaxToken? ThenKeyword => this.thenKeyword;
        public override BlockSyntax Block => this.block;
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ElseIfClauseSyntax> ElseIfs => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ElseIfClauseSyntax>(this.elseIfs);
        public ElseClauseSyntax? Else => this.@else;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.ifKeyword,
                1 => this.condition,
                2 => this.thenKeyword,
                3 => this.block,
                4 => this.elseIfs,
                5 => this.@else,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.IfExpressionSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitIfExpression(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitIfExpression(this);

        public IfExpressionSyntax Update(SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken thenKeyword, BlockSyntax block, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ElseIfClauseSyntax> elseIfs, ElseClauseSyntax @else)
        {
            if (ifKeyword != this.IfKeyword || condition != this.Condition || thenKeyword != this.ThenKeyword || block != this.Block || elseIfs != this.ElseIfs || @else != this.Else)
            {
                var newNode = SyntaxFactory.IfExpression(ifKeyword, condition, thenKeyword, block, elseIfs, @else);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new IfExpressionSyntax(this.Kind, this.ifKeyword, this.condition, this.thenKeyword, this.block, this.elseIfs, this.@else, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new IfExpressionSyntax(this.Kind, this.ifKeyword, this.condition, this.thenKeyword, this.block, this.elseIfs, this.@else, GetDiagnostics(), annotations);

        internal IfExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 6;
            var ifKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(ifKeyword);
            this.ifKeyword = ifKeyword;
            var condition = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(condition);
            this.condition = condition;
            var thenKeyword = (SyntaxToken?)reader.ReadValue();
            if (thenKeyword != null)
            {
                AdjustFlagsAndWidth(thenKeyword);
                this.thenKeyword = thenKeyword;
            }
            var block = (BlockSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(block);
            this.block = block;
            var elseIfs = (GreenNode?)reader.ReadValue();
            if (elseIfs != null)
            {
                AdjustFlagsAndWidth(elseIfs);
                this.elseIfs = elseIfs;
            }
            var @else = (ElseClauseSyntax?)reader.ReadValue();
            if (@else != null)
            {
                AdjustFlagsAndWidth(@else);
                this.@else = @else;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.ifKeyword);
            writer.WriteValue(this.condition);
            writer.WriteValue(this.thenKeyword);
            writer.WriteValue(this.block);
            writer.WriteValue(this.elseIfs);
            writer.WriteValue(this.@else);
        }

        static IfExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(IfExpressionSyntax), r => new IfExpressionSyntax(r));
        }
    }

    internal sealed partial class ElseIfClauseSyntax : MoonScriptSyntaxNode
    {
        internal readonly SyntaxToken elseIfKeyword;
        internal readonly ExpressionSyntax condition;
        internal readonly SyntaxToken thenKeyword;
        internal readonly BlockSyntax block;

        internal ElseIfClauseSyntax(SyntaxKind kind, SyntaxToken elseIfKeyword, ExpressionSyntax condition, SyntaxToken thenKeyword, BlockSyntax block, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(elseIfKeyword);
            this.elseIfKeyword = elseIfKeyword;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            this.AdjustFlagsAndWidth(thenKeyword);
            this.thenKeyword = thenKeyword;
            this.AdjustFlagsAndWidth(block);
            this.block = block;
        }

        internal ElseIfClauseSyntax(SyntaxKind kind, SyntaxToken elseIfKeyword, ExpressionSyntax condition, SyntaxToken thenKeyword, BlockSyntax block, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(elseIfKeyword);
            this.elseIfKeyword = elseIfKeyword;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            this.AdjustFlagsAndWidth(thenKeyword);
            this.thenKeyword = thenKeyword;
            this.AdjustFlagsAndWidth(block);
            this.block = block;
        }

        internal ElseIfClauseSyntax(SyntaxKind kind, SyntaxToken elseIfKeyword, ExpressionSyntax condition, SyntaxToken thenKeyword, BlockSyntax block)
          : base(kind)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(elseIfKeyword);
            this.elseIfKeyword = elseIfKeyword;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            this.AdjustFlagsAndWidth(thenKeyword);
            this.thenKeyword = thenKeyword;
            this.AdjustFlagsAndWidth(block);
            this.block = block;
        }

        public SyntaxToken ElseIfKeyword => this.elseIfKeyword;
        public ExpressionSyntax Condition => this.condition;
        public SyntaxToken ThenKeyword => this.thenKeyword;
        public BlockSyntax Block => this.block;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.elseIfKeyword,
                1 => this.condition,
                2 => this.thenKeyword,
                3 => this.block,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.ElseIfClauseSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitElseIfClause(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitElseIfClause(this);

        public ElseIfClauseSyntax Update(SyntaxToken elseIfKeyword, ExpressionSyntax condition, SyntaxToken thenKeyword, BlockSyntax block)
        {
            if (elseIfKeyword != this.ElseIfKeyword || condition != this.Condition || thenKeyword != this.ThenKeyword || block != this.Block)
            {
                var newNode = SyntaxFactory.ElseIfClause(elseIfKeyword, condition, thenKeyword, block);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ElseIfClauseSyntax(this.Kind, this.elseIfKeyword, this.condition, this.thenKeyword, this.block, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ElseIfClauseSyntax(this.Kind, this.elseIfKeyword, this.condition, this.thenKeyword, this.block, GetDiagnostics(), annotations);

        internal ElseIfClauseSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var elseIfKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(elseIfKeyword);
            this.elseIfKeyword = elseIfKeyword;
            var condition = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(condition);
            this.condition = condition;
            var thenKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(thenKeyword);
            this.thenKeyword = thenKeyword;
            var block = (BlockSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(block);
            this.block = block;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.elseIfKeyword);
            writer.WriteValue(this.condition);
            writer.WriteValue(this.thenKeyword);
            writer.WriteValue(this.block);
        }

        static ElseIfClauseSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ElseIfClauseSyntax), r => new ElseIfClauseSyntax(r));
        }
    }

    internal sealed partial class ElseClauseSyntax : MoonScriptSyntaxNode
    {
        internal readonly SyntaxToken elseKeyword;
        internal readonly BlockSyntax block;

        internal ElseClauseSyntax(SyntaxKind kind, SyntaxToken elseKeyword, BlockSyntax block, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(elseKeyword);
            this.elseKeyword = elseKeyword;
            this.AdjustFlagsAndWidth(block);
            this.block = block;
        }

        internal ElseClauseSyntax(SyntaxKind kind, SyntaxToken elseKeyword, BlockSyntax block, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(elseKeyword);
            this.elseKeyword = elseKeyword;
            this.AdjustFlagsAndWidth(block);
            this.block = block;
        }

        internal ElseClauseSyntax(SyntaxKind kind, SyntaxToken elseKeyword, BlockSyntax block)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(elseKeyword);
            this.elseKeyword = elseKeyword;
            this.AdjustFlagsAndWidth(block);
            this.block = block;
        }

        public SyntaxToken ElseKeyword => this.elseKeyword;
        public BlockSyntax Block => this.block;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.elseKeyword,
                1 => this.block,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.ElseClauseSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitElseClause(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitElseClause(this);

        public ElseClauseSyntax Update(SyntaxToken elseKeyword, BlockSyntax block)
        {
            if (elseKeyword != this.ElseKeyword || block != this.Block)
            {
                var newNode = SyntaxFactory.ElseClause(elseKeyword, block);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ElseClauseSyntax(this.Kind, this.elseKeyword, this.block, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ElseClauseSyntax(this.Kind, this.elseKeyword, this.block, GetDiagnostics(), annotations);

        internal ElseClauseSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var elseKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(elseKeyword);
            this.elseKeyword = elseKeyword;
            var block = (BlockSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(block);
            this.block = block;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.elseKeyword);
            writer.WriteValue(this.block);
        }

        static ElseClauseSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ElseClauseSyntax), r => new ElseClauseSyntax(r));
        }
    }

    internal sealed partial class SwitchExpressionSyntax : ExpressionSyntax
    {
        internal readonly ExpressionSyntax expression;
        internal readonly GreenNode? whens;
        internal readonly ElseClauseSyntax @else;

        internal SwitchExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, GreenNode? whens, ElseClauseSyntax @else, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            if (whens != null)
            {
                this.AdjustFlagsAndWidth(whens);
                this.whens = whens;
            }
            this.AdjustFlagsAndWidth(@else);
            this.@else = @else;
        }

        internal SwitchExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, GreenNode? whens, ElseClauseSyntax @else, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            if (whens != null)
            {
                this.AdjustFlagsAndWidth(whens);
                this.whens = whens;
            }
            this.AdjustFlagsAndWidth(@else);
            this.@else = @else;
        }

        internal SwitchExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, GreenNode? whens, ElseClauseSyntax @else)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            if (whens != null)
            {
                this.AdjustFlagsAndWidth(whens);
                this.whens = whens;
            }
            this.AdjustFlagsAndWidth(@else);
            this.@else = @else;
        }

        public ExpressionSyntax Expression => this.expression;
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<WhenClauseSyntax> Whens => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<WhenClauseSyntax>(this.whens);
        public ElseClauseSyntax Else => this.@else;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.expression,
                1 => this.whens,
                2 => this.@else,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.SwitchExpressionSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitSwitchExpression(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitSwitchExpression(this);

        public SwitchExpressionSyntax Update(ExpressionSyntax expression, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<WhenClauseSyntax> whens, ElseClauseSyntax @else)
        {
            if (expression != this.Expression || whens != this.Whens || @else != this.Else)
            {
                var newNode = SyntaxFactory.SwitchExpression(expression, whens, @else);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new SwitchExpressionSyntax(this.Kind, this.expression, this.whens, this.@else, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new SwitchExpressionSyntax(this.Kind, this.expression, this.whens, this.@else, GetDiagnostics(), annotations);

        internal SwitchExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var expression = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(expression);
            this.expression = expression;
            var whens = (GreenNode?)reader.ReadValue();
            if (whens != null)
            {
                AdjustFlagsAndWidth(whens);
                this.whens = whens;
            }
            var @else = (ElseClauseSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(@else);
            this.@else = @else;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.expression);
            writer.WriteValue(this.whens);
            writer.WriteValue(this.@else);
        }

        static SwitchExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(SwitchExpressionSyntax), r => new SwitchExpressionSyntax(r));
        }
    }

    internal sealed partial class WhenClauseSyntax : MoonScriptSyntaxNode
    {
        internal readonly SyntaxToken whenKeyword;
        internal readonly ExpressionListSyntax values;
        internal readonly SyntaxToken? thenKeyword;
        internal readonly BlockSyntax block;

        internal WhenClauseSyntax(SyntaxKind kind, SyntaxToken whenKeyword, ExpressionListSyntax values, SyntaxToken? thenKeyword, BlockSyntax block, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(whenKeyword);
            this.whenKeyword = whenKeyword;
            this.AdjustFlagsAndWidth(values);
            this.values = values;
            if (thenKeyword != null)
            {
                this.AdjustFlagsAndWidth(thenKeyword);
                this.thenKeyword = thenKeyword;
            }
            this.AdjustFlagsAndWidth(block);
            this.block = block;
        }

        internal WhenClauseSyntax(SyntaxKind kind, SyntaxToken whenKeyword, ExpressionListSyntax values, SyntaxToken? thenKeyword, BlockSyntax block, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(whenKeyword);
            this.whenKeyword = whenKeyword;
            this.AdjustFlagsAndWidth(values);
            this.values = values;
            if (thenKeyword != null)
            {
                this.AdjustFlagsAndWidth(thenKeyword);
                this.thenKeyword = thenKeyword;
            }
            this.AdjustFlagsAndWidth(block);
            this.block = block;
        }

        internal WhenClauseSyntax(SyntaxKind kind, SyntaxToken whenKeyword, ExpressionListSyntax values, SyntaxToken? thenKeyword, BlockSyntax block)
          : base(kind)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(whenKeyword);
            this.whenKeyword = whenKeyword;
            this.AdjustFlagsAndWidth(values);
            this.values = values;
            if (thenKeyword != null)
            {
                this.AdjustFlagsAndWidth(thenKeyword);
                this.thenKeyword = thenKeyword;
            }
            this.AdjustFlagsAndWidth(block);
            this.block = block;
        }

        public SyntaxToken WhenKeyword => this.whenKeyword;
        public ExpressionListSyntax Values => this.values;
        public SyntaxToken? ThenKeyword => this.thenKeyword;
        public BlockSyntax Block => this.block;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.whenKeyword,
                1 => this.values,
                2 => this.thenKeyword,
                3 => this.block,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.WhenClauseSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitWhenClause(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitWhenClause(this);

        public WhenClauseSyntax Update(SyntaxToken whenKeyword, ExpressionListSyntax values, SyntaxToken thenKeyword, BlockSyntax block)
        {
            if (whenKeyword != this.WhenKeyword || values != this.Values || thenKeyword != this.ThenKeyword || block != this.Block)
            {
                var newNode = SyntaxFactory.WhenClause(whenKeyword, values, thenKeyword, block);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new WhenClauseSyntax(this.Kind, this.whenKeyword, this.values, this.thenKeyword, this.block, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new WhenClauseSyntax(this.Kind, this.whenKeyword, this.values, this.thenKeyword, this.block, GetDiagnostics(), annotations);

        internal WhenClauseSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var whenKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(whenKeyword);
            this.whenKeyword = whenKeyword;
            var values = (ExpressionListSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(values);
            this.values = values;
            var thenKeyword = (SyntaxToken?)reader.ReadValue();
            if (thenKeyword != null)
            {
                AdjustFlagsAndWidth(thenKeyword);
                this.thenKeyword = thenKeyword;
            }
            var block = (BlockSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(block);
            this.block = block;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.whenKeyword);
            writer.WriteValue(this.values);
            writer.WriteValue(this.thenKeyword);
            writer.WriteValue(this.block);
        }

        static WhenClauseSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(WhenClauseSyntax), r => new WhenClauseSyntax(r));
        }
    }

    internal sealed partial class UnlessExpressionSyntax : BaseConditionalExpressionSyntax
    {
        internal readonly SyntaxToken unlessKeyword;
        internal readonly ExpressionSyntax condition;
        internal readonly SyntaxToken? thenKeyword;
        internal readonly BlockSyntax block;

        internal UnlessExpressionSyntax(SyntaxKind kind, SyntaxToken unlessKeyword, ExpressionSyntax condition, SyntaxToken? thenKeyword, BlockSyntax block, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(unlessKeyword);
            this.unlessKeyword = unlessKeyword;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            if (thenKeyword != null)
            {
                this.AdjustFlagsAndWidth(thenKeyword);
                this.thenKeyword = thenKeyword;
            }
            this.AdjustFlagsAndWidth(block);
            this.block = block;
        }

        internal UnlessExpressionSyntax(SyntaxKind kind, SyntaxToken unlessKeyword, ExpressionSyntax condition, SyntaxToken? thenKeyword, BlockSyntax block, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(unlessKeyword);
            this.unlessKeyword = unlessKeyword;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            if (thenKeyword != null)
            {
                this.AdjustFlagsAndWidth(thenKeyword);
                this.thenKeyword = thenKeyword;
            }
            this.AdjustFlagsAndWidth(block);
            this.block = block;
        }

        internal UnlessExpressionSyntax(SyntaxKind kind, SyntaxToken unlessKeyword, ExpressionSyntax condition, SyntaxToken? thenKeyword, BlockSyntax block)
          : base(kind)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(unlessKeyword);
            this.unlessKeyword = unlessKeyword;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            if (thenKeyword != null)
            {
                this.AdjustFlagsAndWidth(thenKeyword);
                this.thenKeyword = thenKeyword;
            }
            this.AdjustFlagsAndWidth(block);
            this.block = block;
        }

        public SyntaxToken UnlessKeyword => this.unlessKeyword;
        public override ExpressionSyntax Condition => this.condition;
        public SyntaxToken? ThenKeyword => this.thenKeyword;
        public override BlockSyntax Block => this.block;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.unlessKeyword,
                1 => this.condition,
                2 => this.thenKeyword,
                3 => this.block,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.UnlessExpressionSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitUnlessExpression(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitUnlessExpression(this);

        public UnlessExpressionSyntax Update(SyntaxToken unlessKeyword, ExpressionSyntax condition, SyntaxToken thenKeyword, BlockSyntax block)
        {
            if (unlessKeyword != this.UnlessKeyword || condition != this.Condition || thenKeyword != this.ThenKeyword || block != this.Block)
            {
                var newNode = SyntaxFactory.UnlessExpression(unlessKeyword, condition, thenKeyword, block);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new UnlessExpressionSyntax(this.Kind, this.unlessKeyword, this.condition, this.thenKeyword, this.block, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new UnlessExpressionSyntax(this.Kind, this.unlessKeyword, this.condition, this.thenKeyword, this.block, GetDiagnostics(), annotations);

        internal UnlessExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var unlessKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(unlessKeyword);
            this.unlessKeyword = unlessKeyword;
            var condition = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(condition);
            this.condition = condition;
            var thenKeyword = (SyntaxToken?)reader.ReadValue();
            if (thenKeyword != null)
            {
                AdjustFlagsAndWidth(thenKeyword);
                this.thenKeyword = thenKeyword;
            }
            var block = (BlockSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(block);
            this.block = block;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.unlessKeyword);
            writer.WriteValue(this.condition);
            writer.WriteValue(this.thenKeyword);
            writer.WriteValue(this.block);
        }

        static UnlessExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(UnlessExpressionSyntax), r => new UnlessExpressionSyntax(r));
        }
    }

    internal sealed partial class WhileExpressionSyntax : ExpressionSyntax
    {
        internal readonly SyntaxToken whileKeyword;
        internal readonly ExpressionSyntax condition;
        internal readonly SyntaxToken? doKeyword;
        internal readonly BlockSyntax block;

        internal WhileExpressionSyntax(SyntaxKind kind, SyntaxToken whileKeyword, ExpressionSyntax condition, SyntaxToken? doKeyword, BlockSyntax block, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(whileKeyword);
            this.whileKeyword = whileKeyword;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            if (doKeyword != null)
            {
                this.AdjustFlagsAndWidth(doKeyword);
                this.doKeyword = doKeyword;
            }
            this.AdjustFlagsAndWidth(block);
            this.block = block;
        }

        internal WhileExpressionSyntax(SyntaxKind kind, SyntaxToken whileKeyword, ExpressionSyntax condition, SyntaxToken? doKeyword, BlockSyntax block, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(whileKeyword);
            this.whileKeyword = whileKeyword;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            if (doKeyword != null)
            {
                this.AdjustFlagsAndWidth(doKeyword);
                this.doKeyword = doKeyword;
            }
            this.AdjustFlagsAndWidth(block);
            this.block = block;
        }

        internal WhileExpressionSyntax(SyntaxKind kind, SyntaxToken whileKeyword, ExpressionSyntax condition, SyntaxToken? doKeyword, BlockSyntax block)
          : base(kind)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(whileKeyword);
            this.whileKeyword = whileKeyword;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            if (doKeyword != null)
            {
                this.AdjustFlagsAndWidth(doKeyword);
                this.doKeyword = doKeyword;
            }
            this.AdjustFlagsAndWidth(block);
            this.block = block;
        }

        public SyntaxToken WhileKeyword => this.whileKeyword;
        public ExpressionSyntax Condition => this.condition;
        public SyntaxToken? DoKeyword => this.doKeyword;
        public BlockSyntax Block => this.block;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.whileKeyword,
                1 => this.condition,
                2 => this.doKeyword,
                3 => this.block,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.WhileExpressionSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitWhileExpression(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitWhileExpression(this);

        public WhileExpressionSyntax Update(SyntaxToken whileKeyword, ExpressionSyntax condition, SyntaxToken doKeyword, BlockSyntax block)
        {
            if (whileKeyword != this.WhileKeyword || condition != this.Condition || doKeyword != this.DoKeyword || block != this.Block)
            {
                var newNode = SyntaxFactory.WhileExpression(whileKeyword, condition, doKeyword, block);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new WhileExpressionSyntax(this.Kind, this.whileKeyword, this.condition, this.doKeyword, this.block, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new WhileExpressionSyntax(this.Kind, this.whileKeyword, this.condition, this.doKeyword, this.block, GetDiagnostics(), annotations);

        internal WhileExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var whileKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(whileKeyword);
            this.whileKeyword = whileKeyword;
            var condition = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(condition);
            this.condition = condition;
            var doKeyword = (SyntaxToken?)reader.ReadValue();
            if (doKeyword != null)
            {
                AdjustFlagsAndWidth(doKeyword);
                this.doKeyword = doKeyword;
            }
            var block = (BlockSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(block);
            this.block = block;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.whileKeyword);
            writer.WriteValue(this.condition);
            writer.WriteValue(this.doKeyword);
            writer.WriteValue(this.block);
        }

        static WhileExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(WhileExpressionSyntax), r => new WhileExpressionSyntax(r));
        }
    }

    internal sealed partial class WithExpressionSyntax : ExpressionSyntax
    {
        internal readonly SyntaxToken withKeyword;
        internal readonly ExpressionSyntax expression;
        internal readonly BlockSyntax block;

        internal WithExpressionSyntax(SyntaxKind kind, SyntaxToken withKeyword, ExpressionSyntax expression, BlockSyntax block, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(withKeyword);
            this.withKeyword = withKeyword;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(block);
            this.block = block;
        }

        internal WithExpressionSyntax(SyntaxKind kind, SyntaxToken withKeyword, ExpressionSyntax expression, BlockSyntax block, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(withKeyword);
            this.withKeyword = withKeyword;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(block);
            this.block = block;
        }

        internal WithExpressionSyntax(SyntaxKind kind, SyntaxToken withKeyword, ExpressionSyntax expression, BlockSyntax block)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(withKeyword);
            this.withKeyword = withKeyword;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(block);
            this.block = block;
        }

        public SyntaxToken WithKeyword => this.withKeyword;
        public ExpressionSyntax Expression => this.expression;
        public BlockSyntax Block => this.block;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.withKeyword,
                1 => this.expression,
                2 => this.block,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.WithExpressionSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitWithExpression(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitWithExpression(this);

        public WithExpressionSyntax Update(SyntaxToken withKeyword, ExpressionSyntax expression, BlockSyntax block)
        {
            if (withKeyword != this.WithKeyword || expression != this.Expression || block != this.Block)
            {
                var newNode = SyntaxFactory.WithExpression(withKeyword, expression, block);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new WithExpressionSyntax(this.Kind, this.withKeyword, this.expression, this.block, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new WithExpressionSyntax(this.Kind, this.withKeyword, this.expression, this.block, GetDiagnostics(), annotations);

        internal WithExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var withKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(withKeyword);
            this.withKeyword = withKeyword;
            var expression = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(expression);
            this.expression = expression;
            var block = (BlockSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(block);
            this.block = block;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.withKeyword);
            writer.WriteValue(this.expression);
            writer.WriteValue(this.block);
        }

        static WithExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(WithExpressionSyntax), r => new WithExpressionSyntax(r));
        }
    }

    internal abstract partial class BaseComprehensionExpressionSyntax : ExpressionSyntax
    {
        internal BaseComprehensionExpressionSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal BaseComprehensionExpressionSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected BaseComprehensionExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
        }

        public abstract ExpressionSyntax Expression { get; }

        public abstract BaseComprehensionClauseSyntax FirstClause { get; }

        public abstract Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<BaseComprehensionClauseSyntax> RestClauses { get; }
    }

    internal sealed partial class ListComprehensionExpressionSyntax : BaseComprehensionExpressionSyntax
    {
        internal readonly SyntaxToken openBracketToken;
        internal readonly ExpressionSyntax expression;
        internal readonly BaseComprehensionClauseSyntax firstClause;
        internal readonly GreenNode? restClauses;
        internal readonly SyntaxToken closeBracketToken;

        internal ListComprehensionExpressionSyntax(SyntaxKind kind, SyntaxToken openBracketToken, ExpressionSyntax expression, BaseComprehensionClauseSyntax firstClause, GreenNode? restClauses, SyntaxToken closeBracketToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(firstClause);
            this.firstClause = firstClause;
            if (restClauses != null)
            {
                this.AdjustFlagsAndWidth(restClauses);
                this.restClauses = restClauses;
            }
            this.AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
        }

        internal ListComprehensionExpressionSyntax(SyntaxKind kind, SyntaxToken openBracketToken, ExpressionSyntax expression, BaseComprehensionClauseSyntax firstClause, GreenNode? restClauses, SyntaxToken closeBracketToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(firstClause);
            this.firstClause = firstClause;
            if (restClauses != null)
            {
                this.AdjustFlagsAndWidth(restClauses);
                this.restClauses = restClauses;
            }
            this.AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
        }

        internal ListComprehensionExpressionSyntax(SyntaxKind kind, SyntaxToken openBracketToken, ExpressionSyntax expression, BaseComprehensionClauseSyntax firstClause, GreenNode? restClauses, SyntaxToken closeBracketToken)
          : base(kind)
        {
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(firstClause);
            this.firstClause = firstClause;
            if (restClauses != null)
            {
                this.AdjustFlagsAndWidth(restClauses);
                this.restClauses = restClauses;
            }
            this.AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
        }

        public SyntaxToken OpenBracketToken => this.openBracketToken;
        public override ExpressionSyntax Expression => this.expression;
        public override BaseComprehensionClauseSyntax FirstClause => this.firstClause;
        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<BaseComprehensionClauseSyntax> RestClauses => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<BaseComprehensionClauseSyntax>(this.restClauses);
        public SyntaxToken CloseBracketToken => this.closeBracketToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.openBracketToken,
                1 => this.expression,
                2 => this.firstClause,
                3 => this.restClauses,
                4 => this.closeBracketToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.ListComprehensionExpressionSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitListComprehensionExpression(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitListComprehensionExpression(this);

        public ListComprehensionExpressionSyntax Update(SyntaxToken openBracketToken, ExpressionSyntax expression, BaseComprehensionClauseSyntax firstClause, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<BaseComprehensionClauseSyntax> restClauses, SyntaxToken closeBracketToken)
        {
            if (openBracketToken != this.OpenBracketToken || expression != this.Expression || firstClause != this.FirstClause || restClauses != this.RestClauses || closeBracketToken != this.CloseBracketToken)
            {
                var newNode = SyntaxFactory.ListComprehensionExpression(openBracketToken, expression, firstClause, restClauses, closeBracketToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ListComprehensionExpressionSyntax(this.Kind, this.openBracketToken, this.expression, this.firstClause, this.restClauses, this.closeBracketToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ListComprehensionExpressionSyntax(this.Kind, this.openBracketToken, this.expression, this.firstClause, this.restClauses, this.closeBracketToken, GetDiagnostics(), annotations);

        internal ListComprehensionExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 5;
            var openBracketToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            var expression = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(expression);
            this.expression = expression;
            var firstClause = (BaseComprehensionClauseSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(firstClause);
            this.firstClause = firstClause;
            var restClauses = (GreenNode?)reader.ReadValue();
            if (restClauses != null)
            {
                AdjustFlagsAndWidth(restClauses);
                this.restClauses = restClauses;
            }
            var closeBracketToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.openBracketToken);
            writer.WriteValue(this.expression);
            writer.WriteValue(this.firstClause);
            writer.WriteValue(this.restClauses);
            writer.WriteValue(this.closeBracketToken);
        }

        static ListComprehensionExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ListComprehensionExpressionSyntax), r => new ListComprehensionExpressionSyntax(r));
        }
    }

    internal sealed partial class TableComprehensionExpressionSyntax : BaseComprehensionExpressionSyntax
    {
        internal readonly SyntaxToken openBraceToken;
        internal readonly ExpressionSyntax expression;
        internal readonly BaseComprehensionClauseSyntax firstClause;
        internal readonly GreenNode? restClauses;
        internal readonly SyntaxToken closeBraceToken;

        internal TableComprehensionExpressionSyntax(SyntaxKind kind, SyntaxToken openBraceToken, ExpressionSyntax expression, BaseComprehensionClauseSyntax firstClause, GreenNode? restClauses, SyntaxToken closeBraceToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(firstClause);
            this.firstClause = firstClause;
            if (restClauses != null)
            {
                this.AdjustFlagsAndWidth(restClauses);
                this.restClauses = restClauses;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
        }

        internal TableComprehensionExpressionSyntax(SyntaxKind kind, SyntaxToken openBraceToken, ExpressionSyntax expression, BaseComprehensionClauseSyntax firstClause, GreenNode? restClauses, SyntaxToken closeBraceToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(firstClause);
            this.firstClause = firstClause;
            if (restClauses != null)
            {
                this.AdjustFlagsAndWidth(restClauses);
                this.restClauses = restClauses;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
        }

        internal TableComprehensionExpressionSyntax(SyntaxKind kind, SyntaxToken openBraceToken, ExpressionSyntax expression, BaseComprehensionClauseSyntax firstClause, GreenNode? restClauses, SyntaxToken closeBraceToken)
          : base(kind)
        {
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(firstClause);
            this.firstClause = firstClause;
            if (restClauses != null)
            {
                this.AdjustFlagsAndWidth(restClauses);
                this.restClauses = restClauses;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
        }

        public SyntaxToken OpenBraceToken => this.openBraceToken;
        public override ExpressionSyntax Expression => this.expression;
        public override BaseComprehensionClauseSyntax FirstClause => this.firstClause;
        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<BaseComprehensionClauseSyntax> RestClauses => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<BaseComprehensionClauseSyntax>(this.restClauses);
        public SyntaxToken CloseBraceToken => this.closeBraceToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.openBraceToken,
                1 => this.expression,
                2 => this.firstClause,
                3 => this.restClauses,
                4 => this.closeBraceToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.TableComprehensionExpressionSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitTableComprehensionExpression(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitTableComprehensionExpression(this);

        public TableComprehensionExpressionSyntax Update(SyntaxToken openBraceToken, ExpressionSyntax expression, BaseComprehensionClauseSyntax firstClause, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<BaseComprehensionClauseSyntax> restClauses, SyntaxToken closeBraceToken)
        {
            if (openBraceToken != this.OpenBraceToken || expression != this.Expression || firstClause != this.FirstClause || restClauses != this.RestClauses || closeBraceToken != this.CloseBraceToken)
            {
                var newNode = SyntaxFactory.TableComprehensionExpression(openBraceToken, expression, firstClause, restClauses, closeBraceToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new TableComprehensionExpressionSyntax(this.Kind, this.openBraceToken, this.expression, this.firstClause, this.restClauses, this.closeBraceToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new TableComprehensionExpressionSyntax(this.Kind, this.openBraceToken, this.expression, this.firstClause, this.restClauses, this.closeBraceToken, GetDiagnostics(), annotations);

        internal TableComprehensionExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 5;
            var openBraceToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            var expression = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(expression);
            this.expression = expression;
            var firstClause = (BaseComprehensionClauseSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(firstClause);
            this.firstClause = firstClause;
            var restClauses = (GreenNode?)reader.ReadValue();
            if (restClauses != null)
            {
                AdjustFlagsAndWidth(restClauses);
                this.restClauses = restClauses;
            }
            var closeBraceToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.openBraceToken);
            writer.WriteValue(this.expression);
            writer.WriteValue(this.firstClause);
            writer.WriteValue(this.restClauses);
            writer.WriteValue(this.closeBraceToken);
        }

        static TableComprehensionExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(TableComprehensionExpressionSyntax), r => new TableComprehensionExpressionSyntax(r));
        }
    }

    internal abstract partial class BaseComprehensionClauseSyntax : MoonScriptSyntaxNode
    {
        internal BaseComprehensionClauseSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal BaseComprehensionClauseSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected BaseComprehensionClauseSyntax(ObjectReader reader)
          : base(reader)
        {
        }
    }

    internal sealed partial class ForComprehensionClauseSyntax : BaseComprehensionClauseSyntax
    {
        internal readonly SyntaxToken forKeyword;
        internal readonly IdentifierNameSyntax name;
        internal readonly SyntaxToken equalsToken;
        internal readonly ExpressionSyntax initial;
        internal readonly SyntaxToken firstCommaToken;
        internal readonly ExpressionSyntax limit;
        internal readonly SyntaxToken secondCommaToken;
        internal readonly ExpressionSyntax step;

        internal ForComprehensionClauseSyntax(SyntaxKind kind, SyntaxToken forKeyword, IdentifierNameSyntax name, SyntaxToken equalsToken, ExpressionSyntax initial, SyntaxToken firstCommaToken, ExpressionSyntax limit, SyntaxToken secondCommaToken, ExpressionSyntax step, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 8;
            this.AdjustFlagsAndWidth(forKeyword);
            this.forKeyword = forKeyword;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            this.AdjustFlagsAndWidth(initial);
            this.initial = initial;
            this.AdjustFlagsAndWidth(firstCommaToken);
            this.firstCommaToken = firstCommaToken;
            this.AdjustFlagsAndWidth(limit);
            this.limit = limit;
            this.AdjustFlagsAndWidth(secondCommaToken);
            this.secondCommaToken = secondCommaToken;
            this.AdjustFlagsAndWidth(step);
            this.step = step;
        }

        internal ForComprehensionClauseSyntax(SyntaxKind kind, SyntaxToken forKeyword, IdentifierNameSyntax name, SyntaxToken equalsToken, ExpressionSyntax initial, SyntaxToken firstCommaToken, ExpressionSyntax limit, SyntaxToken secondCommaToken, ExpressionSyntax step, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 8;
            this.AdjustFlagsAndWidth(forKeyword);
            this.forKeyword = forKeyword;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            this.AdjustFlagsAndWidth(initial);
            this.initial = initial;
            this.AdjustFlagsAndWidth(firstCommaToken);
            this.firstCommaToken = firstCommaToken;
            this.AdjustFlagsAndWidth(limit);
            this.limit = limit;
            this.AdjustFlagsAndWidth(secondCommaToken);
            this.secondCommaToken = secondCommaToken;
            this.AdjustFlagsAndWidth(step);
            this.step = step;
        }

        internal ForComprehensionClauseSyntax(SyntaxKind kind, SyntaxToken forKeyword, IdentifierNameSyntax name, SyntaxToken equalsToken, ExpressionSyntax initial, SyntaxToken firstCommaToken, ExpressionSyntax limit, SyntaxToken secondCommaToken, ExpressionSyntax step)
          : base(kind)
        {
            this.SlotCount = 8;
            this.AdjustFlagsAndWidth(forKeyword);
            this.forKeyword = forKeyword;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            this.AdjustFlagsAndWidth(initial);
            this.initial = initial;
            this.AdjustFlagsAndWidth(firstCommaToken);
            this.firstCommaToken = firstCommaToken;
            this.AdjustFlagsAndWidth(limit);
            this.limit = limit;
            this.AdjustFlagsAndWidth(secondCommaToken);
            this.secondCommaToken = secondCommaToken;
            this.AdjustFlagsAndWidth(step);
            this.step = step;
        }

        public SyntaxToken ForKeyword => this.forKeyword;
        public IdentifierNameSyntax Name => this.name;
        public SyntaxToken EqualsToken => this.equalsToken;
        public ExpressionSyntax Initial => this.initial;
        public SyntaxToken FirstCommaToken => this.firstCommaToken;
        public ExpressionSyntax Limit => this.limit;
        public SyntaxToken SecondCommaToken => this.secondCommaToken;
        public ExpressionSyntax Step => this.step;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.forKeyword,
                1 => this.name,
                2 => this.equalsToken,
                3 => this.initial,
                4 => this.firstCommaToken,
                5 => this.limit,
                6 => this.secondCommaToken,
                7 => this.step,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.ForComprehensionClauseSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitForComprehensionClause(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitForComprehensionClause(this);

        public ForComprehensionClauseSyntax Update(SyntaxToken forKeyword, IdentifierNameSyntax name, SyntaxToken equalsToken, ExpressionSyntax initial, SyntaxToken firstCommaToken, ExpressionSyntax limit, SyntaxToken secondCommaToken, ExpressionSyntax step)
        {
            if (forKeyword != this.ForKeyword || name != this.Name || equalsToken != this.EqualsToken || initial != this.Initial || firstCommaToken != this.FirstCommaToken || limit != this.Limit || secondCommaToken != this.SecondCommaToken || step != this.Step)
            {
                var newNode = SyntaxFactory.ForComprehensionClause(forKeyword, name, equalsToken, initial, firstCommaToken, limit, secondCommaToken, step);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ForComprehensionClauseSyntax(this.Kind, this.forKeyword, this.name, this.equalsToken, this.initial, this.firstCommaToken, this.limit, this.secondCommaToken, this.step, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ForComprehensionClauseSyntax(this.Kind, this.forKeyword, this.name, this.equalsToken, this.initial, this.firstCommaToken, this.limit, this.secondCommaToken, this.step, GetDiagnostics(), annotations);

        internal ForComprehensionClauseSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 8;
            var forKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(forKeyword);
            this.forKeyword = forKeyword;
            var name = (IdentifierNameSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(name);
            this.name = name;
            var equalsToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            var initial = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(initial);
            this.initial = initial;
            var firstCommaToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(firstCommaToken);
            this.firstCommaToken = firstCommaToken;
            var limit = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(limit);
            this.limit = limit;
            var secondCommaToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(secondCommaToken);
            this.secondCommaToken = secondCommaToken;
            var step = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(step);
            this.step = step;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.forKeyword);
            writer.WriteValue(this.name);
            writer.WriteValue(this.equalsToken);
            writer.WriteValue(this.initial);
            writer.WriteValue(this.firstCommaToken);
            writer.WriteValue(this.limit);
            writer.WriteValue(this.secondCommaToken);
            writer.WriteValue(this.step);
        }

        static ForComprehensionClauseSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ForComprehensionClauseSyntax), r => new ForComprehensionClauseSyntax(r));
        }
    }

    internal sealed partial class ForInComprehensionClauseSyntax : BaseComprehensionClauseSyntax
    {
        internal readonly SyntaxToken forKeyword;
        internal readonly GreenNode? names;
        internal readonly SyntaxToken inKeyword;
        internal readonly ExpressionSyntax iteration;

        internal ForInComprehensionClauseSyntax(SyntaxKind kind, SyntaxToken forKeyword, GreenNode? names, SyntaxToken inKeyword, ExpressionSyntax iteration, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(forKeyword);
            this.forKeyword = forKeyword;
            if (names != null)
            {
                this.AdjustFlagsAndWidth(names);
                this.names = names;
            }
            this.AdjustFlagsAndWidth(inKeyword);
            this.inKeyword = inKeyword;
            this.AdjustFlagsAndWidth(iteration);
            this.iteration = iteration;
        }

        internal ForInComprehensionClauseSyntax(SyntaxKind kind, SyntaxToken forKeyword, GreenNode? names, SyntaxToken inKeyword, ExpressionSyntax iteration, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(forKeyword);
            this.forKeyword = forKeyword;
            if (names != null)
            {
                this.AdjustFlagsAndWidth(names);
                this.names = names;
            }
            this.AdjustFlagsAndWidth(inKeyword);
            this.inKeyword = inKeyword;
            this.AdjustFlagsAndWidth(iteration);
            this.iteration = iteration;
        }

        internal ForInComprehensionClauseSyntax(SyntaxKind kind, SyntaxToken forKeyword, GreenNode? names, SyntaxToken inKeyword, ExpressionSyntax iteration)
          : base(kind)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(forKeyword);
            this.forKeyword = forKeyword;
            if (names != null)
            {
                this.AdjustFlagsAndWidth(names);
                this.names = names;
            }
            this.AdjustFlagsAndWidth(inKeyword);
            this.inKeyword = inKeyword;
            this.AdjustFlagsAndWidth(iteration);
            this.iteration = iteration;
        }

        public SyntaxToken ForKeyword => this.forKeyword;
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<IdentifierNameSyntax> Names => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<IdentifierNameSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MoonScriptSyntaxNode>(this.names));
        public SyntaxToken InKeyword => this.inKeyword;
        public ExpressionSyntax Iteration => this.iteration;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.forKeyword,
                1 => this.names,
                2 => this.inKeyword,
                3 => this.iteration,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.ForInComprehensionClauseSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitForInComprehensionClause(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitForInComprehensionClause(this);

        public ForInComprehensionClauseSyntax Update(SyntaxToken forKeyword, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<IdentifierNameSyntax> names, SyntaxToken inKeyword, ExpressionSyntax iteration)
        {
            if (forKeyword != this.ForKeyword || names != this.Names || inKeyword != this.InKeyword || iteration != this.Iteration)
            {
                var newNode = SyntaxFactory.ForInComprehensionClause(forKeyword, names, inKeyword, iteration);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ForInComprehensionClauseSyntax(this.Kind, this.forKeyword, this.names, this.inKeyword, this.iteration, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ForInComprehensionClauseSyntax(this.Kind, this.forKeyword, this.names, this.inKeyword, this.iteration, GetDiagnostics(), annotations);

        internal ForInComprehensionClauseSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var forKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(forKeyword);
            this.forKeyword = forKeyword;
            var names = (GreenNode?)reader.ReadValue();
            if (names != null)
            {
                AdjustFlagsAndWidth(names);
                this.names = names;
            }
            var inKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(inKeyword);
            this.inKeyword = inKeyword;
            var iteration = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(iteration);
            this.iteration = iteration;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.forKeyword);
            writer.WriteValue(this.names);
            writer.WriteValue(this.inKeyword);
            writer.WriteValue(this.iteration);
        }

        static ForInComprehensionClauseSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ForInComprehensionClauseSyntax), r => new ForInComprehensionClauseSyntax(r));
        }
    }

    internal sealed partial class WhenComprehensionClauseSyntax : BaseComprehensionClauseSyntax
    {
        internal readonly SyntaxToken whenKeyword;
        internal readonly ExpressionSyntax condition;

        internal WhenComprehensionClauseSyntax(SyntaxKind kind, SyntaxToken whenKeyword, ExpressionSyntax condition, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(whenKeyword);
            this.whenKeyword = whenKeyword;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
        }

        internal WhenComprehensionClauseSyntax(SyntaxKind kind, SyntaxToken whenKeyword, ExpressionSyntax condition, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(whenKeyword);
            this.whenKeyword = whenKeyword;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
        }

        internal WhenComprehensionClauseSyntax(SyntaxKind kind, SyntaxToken whenKeyword, ExpressionSyntax condition)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(whenKeyword);
            this.whenKeyword = whenKeyword;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
        }

        public SyntaxToken WhenKeyword => this.whenKeyword;
        public ExpressionSyntax Condition => this.condition;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.whenKeyword,
                1 => this.condition,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.WhenComprehensionClauseSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitWhenComprehensionClause(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitWhenComprehensionClause(this);

        public WhenComprehensionClauseSyntax Update(SyntaxToken whenKeyword, ExpressionSyntax condition)
        {
            if (whenKeyword != this.WhenKeyword || condition != this.Condition)
            {
                var newNode = SyntaxFactory.WhenComprehensionClause(whenKeyword, condition);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new WhenComprehensionClauseSyntax(this.Kind, this.whenKeyword, this.condition, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new WhenComprehensionClauseSyntax(this.Kind, this.whenKeyword, this.condition, GetDiagnostics(), annotations);

        internal WhenComprehensionClauseSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var whenKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(whenKeyword);
            this.whenKeyword = whenKeyword;
            var condition = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(condition);
            this.condition = condition;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.whenKeyword);
            writer.WriteValue(this.condition);
        }

        static WhenComprehensionClauseSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(WhenComprehensionClauseSyntax), r => new WhenComprehensionClauseSyntax(r));
        }
    }

    internal sealed partial class NumericallyIterateExpressionSyntax : ExpressionSyntax
    {
        internal readonly SyntaxToken asteriskToken;
        internal readonly ExpressionSyntax expression;

        internal NumericallyIterateExpressionSyntax(SyntaxKind kind, SyntaxToken asteriskToken, ExpressionSyntax expression, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(asteriskToken);
            this.asteriskToken = asteriskToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        internal NumericallyIterateExpressionSyntax(SyntaxKind kind, SyntaxToken asteriskToken, ExpressionSyntax expression, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(asteriskToken);
            this.asteriskToken = asteriskToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        internal NumericallyIterateExpressionSyntax(SyntaxKind kind, SyntaxToken asteriskToken, ExpressionSyntax expression)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(asteriskToken);
            this.asteriskToken = asteriskToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        public SyntaxToken AsteriskToken => this.asteriskToken;
        public ExpressionSyntax Expression => this.expression;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.asteriskToken,
                1 => this.expression,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.NumericallyIterateExpressionSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitNumericallyIterateExpression(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitNumericallyIterateExpression(this);

        public NumericallyIterateExpressionSyntax Update(SyntaxToken asteriskToken, ExpressionSyntax expression)
        {
            if (asteriskToken != this.AsteriskToken || expression != this.Expression)
            {
                var newNode = SyntaxFactory.NumericallyIterateExpression(asteriskToken, expression);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new NumericallyIterateExpressionSyntax(this.Kind, this.asteriskToken, this.expression, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new NumericallyIterateExpressionSyntax(this.Kind, this.asteriskToken, this.expression, GetDiagnostics(), annotations);

        internal NumericallyIterateExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var asteriskToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(asteriskToken);
            this.asteriskToken = asteriskToken;
            var expression = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.asteriskToken);
            writer.WriteValue(this.expression);
        }

        static NumericallyIterateExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(NumericallyIterateExpressionSyntax), r => new NumericallyIterateExpressionSyntax(r));
        }
    }

    internal sealed partial class SlicingExpressionSyntax : ExpressionSyntax
    {
        internal readonly ExpressionSyntax numericallyIterateExpression;
        internal readonly SyntaxToken openBracketToken;
        internal readonly ExpressionSyntax? initial;
        internal readonly SyntaxToken firstCommaToken;
        internal readonly ExpressionSyntax? limit;
        internal readonly SyntaxToken secondCommaToken;
        internal readonly ExpressionSyntax step;
        internal readonly SyntaxToken closeBracketToken;

        internal SlicingExpressionSyntax(SyntaxKind kind, ExpressionSyntax numericallyIterateExpression, SyntaxToken openBracketToken, ExpressionSyntax? initial, SyntaxToken firstCommaToken, ExpressionSyntax? limit, SyntaxToken secondCommaToken, ExpressionSyntax step, SyntaxToken closeBracketToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 8;
            this.AdjustFlagsAndWidth(numericallyIterateExpression);
            this.numericallyIterateExpression = numericallyIterateExpression;
            this.AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            if (initial != null)
            {
                this.AdjustFlagsAndWidth(initial);
                this.initial = initial;
            }
            this.AdjustFlagsAndWidth(firstCommaToken);
            this.firstCommaToken = firstCommaToken;
            if (limit != null)
            {
                this.AdjustFlagsAndWidth(limit);
                this.limit = limit;
            }
            this.AdjustFlagsAndWidth(secondCommaToken);
            this.secondCommaToken = secondCommaToken;
            this.AdjustFlagsAndWidth(step);
            this.step = step;
            this.AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
        }

        internal SlicingExpressionSyntax(SyntaxKind kind, ExpressionSyntax numericallyIterateExpression, SyntaxToken openBracketToken, ExpressionSyntax? initial, SyntaxToken firstCommaToken, ExpressionSyntax? limit, SyntaxToken secondCommaToken, ExpressionSyntax step, SyntaxToken closeBracketToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 8;
            this.AdjustFlagsAndWidth(numericallyIterateExpression);
            this.numericallyIterateExpression = numericallyIterateExpression;
            this.AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            if (initial != null)
            {
                this.AdjustFlagsAndWidth(initial);
                this.initial = initial;
            }
            this.AdjustFlagsAndWidth(firstCommaToken);
            this.firstCommaToken = firstCommaToken;
            if (limit != null)
            {
                this.AdjustFlagsAndWidth(limit);
                this.limit = limit;
            }
            this.AdjustFlagsAndWidth(secondCommaToken);
            this.secondCommaToken = secondCommaToken;
            this.AdjustFlagsAndWidth(step);
            this.step = step;
            this.AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
        }

        internal SlicingExpressionSyntax(SyntaxKind kind, ExpressionSyntax numericallyIterateExpression, SyntaxToken openBracketToken, ExpressionSyntax? initial, SyntaxToken firstCommaToken, ExpressionSyntax? limit, SyntaxToken secondCommaToken, ExpressionSyntax step, SyntaxToken closeBracketToken)
          : base(kind)
        {
            this.SlotCount = 8;
            this.AdjustFlagsAndWidth(numericallyIterateExpression);
            this.numericallyIterateExpression = numericallyIterateExpression;
            this.AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            if (initial != null)
            {
                this.AdjustFlagsAndWidth(initial);
                this.initial = initial;
            }
            this.AdjustFlagsAndWidth(firstCommaToken);
            this.firstCommaToken = firstCommaToken;
            if (limit != null)
            {
                this.AdjustFlagsAndWidth(limit);
                this.limit = limit;
            }
            this.AdjustFlagsAndWidth(secondCommaToken);
            this.secondCommaToken = secondCommaToken;
            this.AdjustFlagsAndWidth(step);
            this.step = step;
            this.AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
        }

        public ExpressionSyntax NumericallyIterateExpression => this.numericallyIterateExpression;
        public SyntaxToken OpenBracketToken => this.openBracketToken;
        public ExpressionSyntax? Initial => this.initial;
        public SyntaxToken FirstCommaToken => this.firstCommaToken;
        public ExpressionSyntax? Limit => this.limit;
        public SyntaxToken SecondCommaToken => this.secondCommaToken;
        public ExpressionSyntax Step => this.step;
        public SyntaxToken CloseBracketToken => this.closeBracketToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.numericallyIterateExpression,
                1 => this.openBracketToken,
                2 => this.initial,
                3 => this.firstCommaToken,
                4 => this.limit,
                5 => this.secondCommaToken,
                6 => this.step,
                7 => this.closeBracketToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.SlicingExpressionSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitSlicingExpression(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitSlicingExpression(this);

        public SlicingExpressionSyntax Update(ExpressionSyntax numericallyIterateExpression, SyntaxToken openBracketToken, ExpressionSyntax initial, SyntaxToken firstCommaToken, ExpressionSyntax limit, SyntaxToken secondCommaToken, ExpressionSyntax step, SyntaxToken closeBracketToken)
        {
            if (numericallyIterateExpression != this.NumericallyIterateExpression || openBracketToken != this.OpenBracketToken || initial != this.Initial || firstCommaToken != this.FirstCommaToken || limit != this.Limit || secondCommaToken != this.SecondCommaToken || step != this.Step || closeBracketToken != this.CloseBracketToken)
            {
                var newNode = SyntaxFactory.SlicingExpression(numericallyIterateExpression, openBracketToken, initial, firstCommaToken, limit, secondCommaToken, step, closeBracketToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new SlicingExpressionSyntax(this.Kind, this.numericallyIterateExpression, this.openBracketToken, this.initial, this.firstCommaToken, this.limit, this.secondCommaToken, this.step, this.closeBracketToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new SlicingExpressionSyntax(this.Kind, this.numericallyIterateExpression, this.openBracketToken, this.initial, this.firstCommaToken, this.limit, this.secondCommaToken, this.step, this.closeBracketToken, GetDiagnostics(), annotations);

        internal SlicingExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 8;
            var numericallyIterateExpression = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(numericallyIterateExpression);
            this.numericallyIterateExpression = numericallyIterateExpression;
            var openBracketToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            var initial = (ExpressionSyntax?)reader.ReadValue();
            if (initial != null)
            {
                AdjustFlagsAndWidth(initial);
                this.initial = initial;
            }
            var firstCommaToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(firstCommaToken);
            this.firstCommaToken = firstCommaToken;
            var limit = (ExpressionSyntax?)reader.ReadValue();
            if (limit != null)
            {
                AdjustFlagsAndWidth(limit);
                this.limit = limit;
            }
            var secondCommaToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(secondCommaToken);
            this.secondCommaToken = secondCommaToken;
            var step = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(step);
            this.step = step;
            var closeBracketToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.numericallyIterateExpression);
            writer.WriteValue(this.openBracketToken);
            writer.WriteValue(this.initial);
            writer.WriteValue(this.firstCommaToken);
            writer.WriteValue(this.limit);
            writer.WriteValue(this.secondCommaToken);
            writer.WriteValue(this.step);
            writer.WriteValue(this.closeBracketToken);
        }

        static SlicingExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(SlicingExpressionSyntax), r => new SlicingExpressionSyntax(r));
        }
    }

    /// <summary>Class which represents the syntax node for invocation expression.</summary>
    internal sealed partial class InvocationExpressionSyntax : ExpressionSyntax
    {
        internal readonly ExpressionSyntax? expression;
        internal readonly ImplicitSelfCallSyntax? selfCall;
        internal readonly ArgumentListSyntax argumentList;

        internal InvocationExpressionSyntax(SyntaxKind kind, ExpressionSyntax? expression, ImplicitSelfCallSyntax? selfCall, ArgumentListSyntax argumentList, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            if (expression != null)
            {
                this.AdjustFlagsAndWidth(expression);
                this.expression = expression;
            }
            if (selfCall != null)
            {
                this.AdjustFlagsAndWidth(selfCall);
                this.selfCall = selfCall;
            }
            this.AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
        }

        internal InvocationExpressionSyntax(SyntaxKind kind, ExpressionSyntax? expression, ImplicitSelfCallSyntax? selfCall, ArgumentListSyntax argumentList, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            if (expression != null)
            {
                this.AdjustFlagsAndWidth(expression);
                this.expression = expression;
            }
            if (selfCall != null)
            {
                this.AdjustFlagsAndWidth(selfCall);
                this.selfCall = selfCall;
            }
            this.AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
        }

        internal InvocationExpressionSyntax(SyntaxKind kind, ExpressionSyntax? expression, ImplicitSelfCallSyntax? selfCall, ArgumentListSyntax argumentList)
          : base(kind)
        {
            this.SlotCount = 3;
            if (expression != null)
            {
                this.AdjustFlagsAndWidth(expression);
                this.expression = expression;
            }
            if (selfCall != null)
            {
                this.AdjustFlagsAndWidth(selfCall);
                this.selfCall = selfCall;
            }
            this.AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
        }

        /// <summary>ExpressionSyntax node representing the expression part of the invocation.</summary>
        public ExpressionSyntax? Expression => this.expression;
        public ImplicitSelfCallSyntax? SelfCall => this.selfCall;
        /// <summary>ArgumentListSyntax node representing the list of arguments of the invocation expression.</summary>
        public ArgumentListSyntax ArgumentList => this.argumentList;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.expression,
                1 => this.selfCall,
                2 => this.argumentList,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.InvocationExpressionSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitInvocationExpression(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitInvocationExpression(this);

        public InvocationExpressionSyntax Update(ExpressionSyntax expression, ImplicitSelfCallSyntax selfCall, ArgumentListSyntax argumentList)
        {
            if (expression != this.Expression || selfCall != this.SelfCall || argumentList != this.ArgumentList)
            {
                var newNode = SyntaxFactory.InvocationExpression(expression, selfCall, argumentList);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new InvocationExpressionSyntax(this.Kind, this.expression, this.selfCall, this.argumentList, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new InvocationExpressionSyntax(this.Kind, this.expression, this.selfCall, this.argumentList, GetDiagnostics(), annotations);

        internal InvocationExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var expression = (ExpressionSyntax?)reader.ReadValue();
            if (expression != null)
            {
                AdjustFlagsAndWidth(expression);
                this.expression = expression;
            }
            var selfCall = (ImplicitSelfCallSyntax?)reader.ReadValue();
            if (selfCall != null)
            {
                AdjustFlagsAndWidth(selfCall);
                this.selfCall = selfCall;
            }
            var argumentList = (ArgumentListSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.expression);
            writer.WriteValue(this.selfCall);
            writer.WriteValue(this.argumentList);
        }

        static InvocationExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(InvocationExpressionSyntax), r => new InvocationExpressionSyntax(r));
        }
    }

    internal sealed partial class LambdaExpressionSyntax : ExpressionSyntax
    {
        internal readonly ParameterListSyntax? parameters;
        internal readonly SyntaxToken arrow;
        internal readonly BlockSyntax block;

        internal LambdaExpressionSyntax(SyntaxKind kind, ParameterListSyntax? parameters, SyntaxToken arrow, BlockSyntax block, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            if (parameters != null)
            {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            this.AdjustFlagsAndWidth(arrow);
            this.arrow = arrow;
            this.AdjustFlagsAndWidth(block);
            this.block = block;
        }

        internal LambdaExpressionSyntax(SyntaxKind kind, ParameterListSyntax? parameters, SyntaxToken arrow, BlockSyntax block, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            if (parameters != null)
            {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            this.AdjustFlagsAndWidth(arrow);
            this.arrow = arrow;
            this.AdjustFlagsAndWidth(block);
            this.block = block;
        }

        internal LambdaExpressionSyntax(SyntaxKind kind, ParameterListSyntax? parameters, SyntaxToken arrow, BlockSyntax block)
          : base(kind)
        {
            this.SlotCount = 3;
            if (parameters != null)
            {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            this.AdjustFlagsAndWidth(arrow);
            this.arrow = arrow;
            this.AdjustFlagsAndWidth(block);
            this.block = block;
        }

        public ParameterListSyntax? Parameters => this.parameters;
        public SyntaxToken Arrow => this.arrow;
        public BlockSyntax Block => this.block;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.parameters,
                1 => this.arrow,
                2 => this.block,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.LambdaExpressionSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitLambdaExpression(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitLambdaExpression(this);

        public LambdaExpressionSyntax Update(ParameterListSyntax parameters, SyntaxToken arrow, BlockSyntax block)
        {
            if (parameters != this.Parameters || arrow != this.Arrow || block != this.Block)
            {
                var newNode = SyntaxFactory.LambdaExpression(parameters, arrow, block);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new LambdaExpressionSyntax(this.Kind, this.parameters, this.arrow, this.block, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new LambdaExpressionSyntax(this.Kind, this.parameters, this.arrow, this.block, GetDiagnostics(), annotations);

        internal LambdaExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var parameters = (ParameterListSyntax?)reader.ReadValue();
            if (parameters != null)
            {
                AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            var arrow = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(arrow);
            this.arrow = arrow;
            var block = (BlockSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(block);
            this.block = block;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.parameters);
            writer.WriteValue(this.arrow);
            writer.WriteValue(this.block);
        }

        static LambdaExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(LambdaExpressionSyntax), r => new LambdaExpressionSyntax(r));
        }
    }

    /// <summary>Class which represents an expression that has a binary operator.</summary>
    internal sealed partial class BinaryExpressionSyntax : ExpressionSyntax
    {
        internal readonly ExpressionSyntax left;
        internal readonly SyntaxToken operatorToken;
        internal readonly ExpressionSyntax right;

        internal BinaryExpressionSyntax(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(left);
            this.left = left;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            this.AdjustFlagsAndWidth(right);
            this.right = right;
        }

        internal BinaryExpressionSyntax(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(left);
            this.left = left;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            this.AdjustFlagsAndWidth(right);
            this.right = right;
        }

        internal BinaryExpressionSyntax(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(left);
            this.left = left;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            this.AdjustFlagsAndWidth(right);
            this.right = right;
        }

        /// <summary>ExpressionSyntax node representing the expression on the left of the binary operator.</summary>
        public ExpressionSyntax Left => this.left;
        /// <summary>SyntaxToken representing the operator of the binary expression.</summary>
        public SyntaxToken OperatorToken => this.operatorToken;
        /// <summary>ExpressionSyntax node representing the expression on the right of the binary operator.</summary>
        public ExpressionSyntax Right => this.right;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.left,
                1 => this.operatorToken,
                2 => this.right,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.BinaryExpressionSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitBinaryExpression(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitBinaryExpression(this);

        public BinaryExpressionSyntax Update(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)
        {
            if (left != this.Left || operatorToken != this.OperatorToken || right != this.Right)
            {
                var newNode = SyntaxFactory.BinaryExpression(this.Kind, left, operatorToken, right);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new BinaryExpressionSyntax(this.Kind, this.left, this.operatorToken, this.right, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new BinaryExpressionSyntax(this.Kind, this.left, this.operatorToken, this.right, GetDiagnostics(), annotations);

        internal BinaryExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var left = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(left);
            this.left = left;
            var operatorToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            var right = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(right);
            this.right = right;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.left);
            writer.WriteValue(this.operatorToken);
            writer.WriteValue(this.right);
        }

        static BinaryExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(BinaryExpressionSyntax), r => new BinaryExpressionSyntax(r));
        }
    }

    /// <summary>Class which represents the syntax node for prefix unary expression.</summary>
    internal sealed partial class UnaryExpressionSyntax : ExpressionSyntax
    {
        internal readonly SyntaxToken operatorToken;
        internal readonly ExpressionSyntax operand;

        internal UnaryExpressionSyntax(SyntaxKind kind, SyntaxToken operatorToken, ExpressionSyntax operand, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            this.AdjustFlagsAndWidth(operand);
            this.operand = operand;
        }

        internal UnaryExpressionSyntax(SyntaxKind kind, SyntaxToken operatorToken, ExpressionSyntax operand, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            this.AdjustFlagsAndWidth(operand);
            this.operand = operand;
        }

        internal UnaryExpressionSyntax(SyntaxKind kind, SyntaxToken operatorToken, ExpressionSyntax operand)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            this.AdjustFlagsAndWidth(operand);
            this.operand = operand;
        }

        /// <summary>SyntaxToken representing the kind of the operator of the prefix unary expression.</summary>
        public SyntaxToken OperatorToken => this.operatorToken;
        /// <summary>ExpressionSyntax representing the operand of the prefix unary expression.</summary>
        public ExpressionSyntax Operand => this.operand;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.operatorToken,
                1 => this.operand,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.UnaryExpressionSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitUnaryExpression(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitUnaryExpression(this);

        public UnaryExpressionSyntax Update(SyntaxToken operatorToken, ExpressionSyntax operand)
        {
            if (operatorToken != this.OperatorToken || operand != this.Operand)
            {
                var newNode = SyntaxFactory.UnaryExpression(this.Kind, operatorToken, operand);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new UnaryExpressionSyntax(this.Kind, this.operatorToken, this.operand, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new UnaryExpressionSyntax(this.Kind, this.operatorToken, this.operand, GetDiagnostics(), annotations);

        internal UnaryExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var operatorToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            var operand = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(operand);
            this.operand = operand;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.operatorToken);
            writer.WriteValue(this.operand);
        }

        static UnaryExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(UnaryExpressionSyntax), r => new UnaryExpressionSyntax(r));
        }
    }

    internal abstract partial class BaseAssignmentExpressionSyntax : ExpressionSyntax
    {
        internal BaseAssignmentExpressionSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal BaseAssignmentExpressionSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected BaseAssignmentExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
        }

        public abstract SyntaxToken OperatorToken { get; }
    }

    /// <summary>Class which represents an expression that has an assignment operator.</summary>
    internal sealed partial class SimpleAssignmentExpressionSyntax : BaseAssignmentExpressionSyntax
    {
        internal readonly ExpressionListSyntax left;
        internal readonly SyntaxToken equalsToken;
        internal readonly ExpressionListSyntax right;

        internal SimpleAssignmentExpressionSyntax(SyntaxKind kind, ExpressionListSyntax left, SyntaxToken equalsToken, ExpressionListSyntax right, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(left);
            this.left = left;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            this.AdjustFlagsAndWidth(right);
            this.right = right;
        }

        internal SimpleAssignmentExpressionSyntax(SyntaxKind kind, ExpressionListSyntax left, SyntaxToken equalsToken, ExpressionListSyntax right, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(left);
            this.left = left;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            this.AdjustFlagsAndWidth(right);
            this.right = right;
        }

        internal SimpleAssignmentExpressionSyntax(SyntaxKind kind, ExpressionListSyntax left, SyntaxToken equalsToken, ExpressionListSyntax right)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(left);
            this.left = left;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            this.AdjustFlagsAndWidth(right);
            this.right = right;
        }

        public ExpressionListSyntax Left => this.left;
        /// <summary>SyntaxToken representing the operator of the assignment expression.</summary>
        public override SyntaxToken OperatorToken => this.equalsToken;
        public SyntaxToken EqualsToken => this.equalsToken;
        public ExpressionListSyntax Right => this.right;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.left,
                1 => this.equalsToken,
                2 => this.right,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.SimpleAssignmentExpressionSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitSimpleAssignmentExpression(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitSimpleAssignmentExpression(this);

        public SimpleAssignmentExpressionSyntax Update(ExpressionListSyntax left, SyntaxToken equalsToken, ExpressionListSyntax right)
        {
            if (left != this.Left || equalsToken != this.EqualsToken || right != this.Right)
            {
                var newNode = SyntaxFactory.SimpleAssignmentExpression(left, equalsToken, right);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new SimpleAssignmentExpressionSyntax(this.Kind, this.left, this.equalsToken, this.right, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new SimpleAssignmentExpressionSyntax(this.Kind, this.left, this.equalsToken, this.right, GetDiagnostics(), annotations);

        internal SimpleAssignmentExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var left = (ExpressionListSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(left);
            this.left = left;
            var equalsToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            var right = (ExpressionListSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(right);
            this.right = right;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.left);
            writer.WriteValue(this.equalsToken);
            writer.WriteValue(this.right);
        }

        static SimpleAssignmentExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(SimpleAssignmentExpressionSyntax), r => new SimpleAssignmentExpressionSyntax(r));
        }
    }

    internal sealed partial class UpdateAssignmentExpressionSyntax : BaseAssignmentExpressionSyntax
    {
        internal readonly ExpressionSyntax left;
        internal readonly SyntaxToken operatorToken;
        internal readonly ExpressionListSyntax right;

        internal UpdateAssignmentExpressionSyntax(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionListSyntax right, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(left);
            this.left = left;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            this.AdjustFlagsAndWidth(right);
            this.right = right;
        }

        internal UpdateAssignmentExpressionSyntax(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionListSyntax right, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(left);
            this.left = left;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            this.AdjustFlagsAndWidth(right);
            this.right = right;
        }

        internal UpdateAssignmentExpressionSyntax(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionListSyntax right)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(left);
            this.left = left;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            this.AdjustFlagsAndWidth(right);
            this.right = right;
        }

        /// <summary>ExpressionSyntax node representing the expression on the left of the assignment operator.</summary>
        public ExpressionSyntax Left => this.left;
        /// <summary>SyntaxToken representing the operator of the update assignment expression.</summary>
        public override SyntaxToken OperatorToken => this.operatorToken;
        public ExpressionListSyntax Right => this.right;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.left,
                1 => this.operatorToken,
                2 => this.right,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.UpdateAssignmentExpressionSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitUpdateAssignmentExpression(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitUpdateAssignmentExpression(this);

        public UpdateAssignmentExpressionSyntax Update(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionListSyntax right)
        {
            if (left != this.Left || operatorToken != this.OperatorToken || right != this.Right)
            {
                var newNode = SyntaxFactory.UpdateAssignmentExpression(this.Kind, left, operatorToken, right);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new UpdateAssignmentExpressionSyntax(this.Kind, this.left, this.operatorToken, this.right, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new UpdateAssignmentExpressionSyntax(this.Kind, this.left, this.operatorToken, this.right, GetDiagnostics(), annotations);

        internal UpdateAssignmentExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var left = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(left);
            this.left = left;
            var operatorToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            var right = (ExpressionListSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(right);
            this.right = right;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.left);
            writer.WriteValue(this.operatorToken);
            writer.WriteValue(this.right);
        }

        static UpdateAssignmentExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(UpdateAssignmentExpressionSyntax), r => new UpdateAssignmentExpressionSyntax(r));
        }
    }

    /// <summary>Provides the base class from which the classes that represent statement syntax nodes are derived. This is an abstract class.</summary>
    internal abstract partial class StatementSyntax : MoonScriptSyntaxNode
    {
        internal StatementSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal StatementSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected StatementSyntax(ObjectReader reader)
          : base(reader)
        {
        }
    }

    internal sealed partial class ExpressionStatementSyntax : StatementSyntax
    {
        internal readonly ExpressionSyntax expression;
        internal readonly LineDecoratorSyntax? lineDecorator;

        internal ExpressionStatementSyntax(SyntaxKind kind, ExpressionSyntax expression, LineDecoratorSyntax? lineDecorator, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            if (lineDecorator != null)
            {
                this.AdjustFlagsAndWidth(lineDecorator);
                this.lineDecorator = lineDecorator;
            }
        }

        internal ExpressionStatementSyntax(SyntaxKind kind, ExpressionSyntax expression, LineDecoratorSyntax? lineDecorator, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            if (lineDecorator != null)
            {
                this.AdjustFlagsAndWidth(lineDecorator);
                this.lineDecorator = lineDecorator;
            }
        }

        internal ExpressionStatementSyntax(SyntaxKind kind, ExpressionSyntax expression, LineDecoratorSyntax? lineDecorator)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            if (lineDecorator != null)
            {
                this.AdjustFlagsAndWidth(lineDecorator);
                this.lineDecorator = lineDecorator;
            }
        }

        public ExpressionSyntax Expression => this.expression;
        public LineDecoratorSyntax? LineDecorator => this.lineDecorator;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.expression,
                1 => this.lineDecorator,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.ExpressionStatementSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitExpressionStatement(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitExpressionStatement(this);

        public ExpressionStatementSyntax Update(ExpressionSyntax expression, LineDecoratorSyntax lineDecorator)
        {
            if (expression != this.Expression || lineDecorator != this.LineDecorator)
            {
                var newNode = SyntaxFactory.ExpressionStatement(expression, lineDecorator);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ExpressionStatementSyntax(this.Kind, this.expression, this.lineDecorator, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ExpressionStatementSyntax(this.Kind, this.expression, this.lineDecorator, GetDiagnostics(), annotations);

        internal ExpressionStatementSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var expression = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(expression);
            this.expression = expression;
            var lineDecorator = (LineDecoratorSyntax?)reader.ReadValue();
            if (lineDecorator != null)
            {
                AdjustFlagsAndWidth(lineDecorator);
                this.lineDecorator = lineDecorator;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.expression);
            writer.WriteValue(this.lineDecorator);
        }

        static ExpressionStatementSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ExpressionStatementSyntax), r => new ExpressionStatementSyntax(r));
        }
    }

    internal sealed partial class BreakStatementSyntax : StatementSyntax
    {
        internal readonly SyntaxToken breakKeyword;
        internal readonly ConditionalLineDecoratorSyntax? lineDecorator;

        internal BreakStatementSyntax(SyntaxKind kind, SyntaxToken breakKeyword, ConditionalLineDecoratorSyntax? lineDecorator, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(breakKeyword);
            this.breakKeyword = breakKeyword;
            if (lineDecorator != null)
            {
                this.AdjustFlagsAndWidth(lineDecorator);
                this.lineDecorator = lineDecorator;
            }
        }

        internal BreakStatementSyntax(SyntaxKind kind, SyntaxToken breakKeyword, ConditionalLineDecoratorSyntax? lineDecorator, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(breakKeyword);
            this.breakKeyword = breakKeyword;
            if (lineDecorator != null)
            {
                this.AdjustFlagsAndWidth(lineDecorator);
                this.lineDecorator = lineDecorator;
            }
        }

        internal BreakStatementSyntax(SyntaxKind kind, SyntaxToken breakKeyword, ConditionalLineDecoratorSyntax? lineDecorator)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(breakKeyword);
            this.breakKeyword = breakKeyword;
            if (lineDecorator != null)
            {
                this.AdjustFlagsAndWidth(lineDecorator);
                this.lineDecorator = lineDecorator;
            }
        }

        public SyntaxToken BreakKeyword => this.breakKeyword;
        public ConditionalLineDecoratorSyntax? LineDecorator => this.lineDecorator;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.breakKeyword,
                1 => this.lineDecorator,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.BreakStatementSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitBreakStatement(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitBreakStatement(this);

        public BreakStatementSyntax Update(SyntaxToken breakKeyword, ConditionalLineDecoratorSyntax lineDecorator)
        {
            if (breakKeyword != this.BreakKeyword || lineDecorator != this.LineDecorator)
            {
                var newNode = SyntaxFactory.BreakStatement(breakKeyword, lineDecorator);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new BreakStatementSyntax(this.Kind, this.breakKeyword, this.lineDecorator, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new BreakStatementSyntax(this.Kind, this.breakKeyword, this.lineDecorator, GetDiagnostics(), annotations);

        internal BreakStatementSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var breakKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(breakKeyword);
            this.breakKeyword = breakKeyword;
            var lineDecorator = (ConditionalLineDecoratorSyntax?)reader.ReadValue();
            if (lineDecorator != null)
            {
                AdjustFlagsAndWidth(lineDecorator);
                this.lineDecorator = lineDecorator;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.breakKeyword);
            writer.WriteValue(this.lineDecorator);
        }

        static BreakStatementSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(BreakStatementSyntax), r => new BreakStatementSyntax(r));
        }
    }

    internal sealed partial class ClassStatementSyntax : MoonScriptSyntaxNode
    {
        internal readonly SyntaxToken classKeyword;
        internal readonly IdentifierNameSyntax name;
        internal readonly SyntaxToken extendsKeyword;
        internal readonly IdentifierNameSyntax baseName;
        internal readonly GreenNode? statements;

        internal ClassStatementSyntax(SyntaxKind kind, SyntaxToken classKeyword, IdentifierNameSyntax name, SyntaxToken extendsKeyword, IdentifierNameSyntax baseName, GreenNode? statements, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(classKeyword);
            this.classKeyword = classKeyword;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(extendsKeyword);
            this.extendsKeyword = extendsKeyword;
            this.AdjustFlagsAndWidth(baseName);
            this.baseName = baseName;
            if (statements != null)
            {
                this.AdjustFlagsAndWidth(statements);
                this.statements = statements;
            }
        }

        internal ClassStatementSyntax(SyntaxKind kind, SyntaxToken classKeyword, IdentifierNameSyntax name, SyntaxToken extendsKeyword, IdentifierNameSyntax baseName, GreenNode? statements, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(classKeyword);
            this.classKeyword = classKeyword;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(extendsKeyword);
            this.extendsKeyword = extendsKeyword;
            this.AdjustFlagsAndWidth(baseName);
            this.baseName = baseName;
            if (statements != null)
            {
                this.AdjustFlagsAndWidth(statements);
                this.statements = statements;
            }
        }

        internal ClassStatementSyntax(SyntaxKind kind, SyntaxToken classKeyword, IdentifierNameSyntax name, SyntaxToken extendsKeyword, IdentifierNameSyntax baseName, GreenNode? statements)
          : base(kind)
        {
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(classKeyword);
            this.classKeyword = classKeyword;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(extendsKeyword);
            this.extendsKeyword = extendsKeyword;
            this.AdjustFlagsAndWidth(baseName);
            this.baseName = baseName;
            if (statements != null)
            {
                this.AdjustFlagsAndWidth(statements);
                this.statements = statements;
            }
        }

        public SyntaxToken ClassKeyword => this.classKeyword;
        public IdentifierNameSyntax Name => this.name;
        public SyntaxToken ExtendsKeyword => this.extendsKeyword;
        public IdentifierNameSyntax BaseName => this.baseName;
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<StatementSyntax> Statements => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<StatementSyntax>(this.statements);

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.classKeyword,
                1 => this.name,
                2 => this.extendsKeyword,
                3 => this.baseName,
                4 => this.statements,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.ClassStatementSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitClassStatement(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitClassStatement(this);

        public ClassStatementSyntax Update(SyntaxToken classKeyword, IdentifierNameSyntax name, SyntaxToken extendsKeyword, IdentifierNameSyntax baseName, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<StatementSyntax> statements)
        {
            if (classKeyword != this.ClassKeyword || name != this.Name || extendsKeyword != this.ExtendsKeyword || baseName != this.BaseName || statements != this.Statements)
            {
                var newNode = SyntaxFactory.ClassStatement(classKeyword, name, extendsKeyword, baseName, statements);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ClassStatementSyntax(this.Kind, this.classKeyword, this.name, this.extendsKeyword, this.baseName, this.statements, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ClassStatementSyntax(this.Kind, this.classKeyword, this.name, this.extendsKeyword, this.baseName, this.statements, GetDiagnostics(), annotations);

        internal ClassStatementSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 5;
            var classKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(classKeyword);
            this.classKeyword = classKeyword;
            var name = (IdentifierNameSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(name);
            this.name = name;
            var extendsKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(extendsKeyword);
            this.extendsKeyword = extendsKeyword;
            var baseName = (IdentifierNameSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(baseName);
            this.baseName = baseName;
            var statements = (GreenNode?)reader.ReadValue();
            if (statements != null)
            {
                AdjustFlagsAndWidth(statements);
                this.statements = statements;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.classKeyword);
            writer.WriteValue(this.name);
            writer.WriteValue(this.extendsKeyword);
            writer.WriteValue(this.baseName);
            writer.WriteValue(this.statements);
        }

        static ClassStatementSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ClassStatementSyntax), r => new ClassStatementSyntax(r));
        }
    }

    internal sealed partial class MemberStatementSyntax : StatementSyntax
    {
        internal readonly SyntaxToken? commercialAtToken;
        internal readonly NameColonSyntax nameColon;
        internal readonly ExpressionSyntax expression;

        internal MemberStatementSyntax(SyntaxKind kind, SyntaxToken? commercialAtToken, NameColonSyntax nameColon, ExpressionSyntax expression, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            if (commercialAtToken != null)
            {
                this.AdjustFlagsAndWidth(commercialAtToken);
                this.commercialAtToken = commercialAtToken;
            }
            this.AdjustFlagsAndWidth(nameColon);
            this.nameColon = nameColon;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        internal MemberStatementSyntax(SyntaxKind kind, SyntaxToken? commercialAtToken, NameColonSyntax nameColon, ExpressionSyntax expression, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            if (commercialAtToken != null)
            {
                this.AdjustFlagsAndWidth(commercialAtToken);
                this.commercialAtToken = commercialAtToken;
            }
            this.AdjustFlagsAndWidth(nameColon);
            this.nameColon = nameColon;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        internal MemberStatementSyntax(SyntaxKind kind, SyntaxToken? commercialAtToken, NameColonSyntax nameColon, ExpressionSyntax expression)
          : base(kind)
        {
            this.SlotCount = 3;
            if (commercialAtToken != null)
            {
                this.AdjustFlagsAndWidth(commercialAtToken);
                this.commercialAtToken = commercialAtToken;
            }
            this.AdjustFlagsAndWidth(nameColon);
            this.nameColon = nameColon;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        public SyntaxToken? CommercialAtToken => this.commercialAtToken;
        public NameColonSyntax NameColon => this.nameColon;
        public ExpressionSyntax Expression => this.expression;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.commercialAtToken,
                1 => this.nameColon,
                2 => this.expression,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.MemberStatementSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitMemberStatement(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitMemberStatement(this);

        public MemberStatementSyntax Update(SyntaxToken commercialAtToken, NameColonSyntax nameColon, ExpressionSyntax expression)
        {
            if (commercialAtToken != this.CommercialAtToken || nameColon != this.NameColon || expression != this.Expression)
            {
                var newNode = SyntaxFactory.MemberStatement(commercialAtToken, nameColon, expression);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new MemberStatementSyntax(this.Kind, this.commercialAtToken, this.nameColon, this.expression, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new MemberStatementSyntax(this.Kind, this.commercialAtToken, this.nameColon, this.expression, GetDiagnostics(), annotations);

        internal MemberStatementSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var commercialAtToken = (SyntaxToken?)reader.ReadValue();
            if (commercialAtToken != null)
            {
                AdjustFlagsAndWidth(commercialAtToken);
                this.commercialAtToken = commercialAtToken;
            }
            var nameColon = (NameColonSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(nameColon);
            this.nameColon = nameColon;
            var expression = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.commercialAtToken);
            writer.WriteValue(this.nameColon);
            writer.WriteValue(this.expression);
        }

        static MemberStatementSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(MemberStatementSyntax), r => new MemberStatementSyntax(r));
        }
    }

    internal sealed partial class ContinueStatementSyntax : StatementSyntax
    {
        internal readonly SyntaxToken breakKeyword;
        internal readonly ConditionalLineDecoratorSyntax? lineDecorator;

        internal ContinueStatementSyntax(SyntaxKind kind, SyntaxToken breakKeyword, ConditionalLineDecoratorSyntax? lineDecorator, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(breakKeyword);
            this.breakKeyword = breakKeyword;
            if (lineDecorator != null)
            {
                this.AdjustFlagsAndWidth(lineDecorator);
                this.lineDecorator = lineDecorator;
            }
        }

        internal ContinueStatementSyntax(SyntaxKind kind, SyntaxToken breakKeyword, ConditionalLineDecoratorSyntax? lineDecorator, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(breakKeyword);
            this.breakKeyword = breakKeyword;
            if (lineDecorator != null)
            {
                this.AdjustFlagsAndWidth(lineDecorator);
                this.lineDecorator = lineDecorator;
            }
        }

        internal ContinueStatementSyntax(SyntaxKind kind, SyntaxToken breakKeyword, ConditionalLineDecoratorSyntax? lineDecorator)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(breakKeyword);
            this.breakKeyword = breakKeyword;
            if (lineDecorator != null)
            {
                this.AdjustFlagsAndWidth(lineDecorator);
                this.lineDecorator = lineDecorator;
            }
        }

        public SyntaxToken BreakKeyword => this.breakKeyword;
        public ConditionalLineDecoratorSyntax? LineDecorator => this.lineDecorator;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.breakKeyword,
                1 => this.lineDecorator,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.ContinueStatementSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitContinueStatement(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitContinueStatement(this);

        public ContinueStatementSyntax Update(SyntaxToken breakKeyword, ConditionalLineDecoratorSyntax lineDecorator)
        {
            if (breakKeyword != this.BreakKeyword || lineDecorator != this.LineDecorator)
            {
                var newNode = SyntaxFactory.ContinueStatement(breakKeyword, lineDecorator);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ContinueStatementSyntax(this.Kind, this.breakKeyword, this.lineDecorator, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ContinueStatementSyntax(this.Kind, this.breakKeyword, this.lineDecorator, GetDiagnostics(), annotations);

        internal ContinueStatementSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var breakKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(breakKeyword);
            this.breakKeyword = breakKeyword;
            var lineDecorator = (ConditionalLineDecoratorSyntax?)reader.ReadValue();
            if (lineDecorator != null)
            {
                AdjustFlagsAndWidth(lineDecorator);
                this.lineDecorator = lineDecorator;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.breakKeyword);
            writer.WriteValue(this.lineDecorator);
        }

        static ContinueStatementSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ContinueStatementSyntax), r => new ContinueStatementSyntax(r));
        }
    }

    internal sealed partial class DoStatementSyntax : StatementSyntax
    {
        internal readonly SyntaxToken doKeyword;
        internal readonly BlockSyntax block;

        internal DoStatementSyntax(SyntaxKind kind, SyntaxToken doKeyword, BlockSyntax block, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(doKeyword);
            this.doKeyword = doKeyword;
            this.AdjustFlagsAndWidth(block);
            this.block = block;
        }

        internal DoStatementSyntax(SyntaxKind kind, SyntaxToken doKeyword, BlockSyntax block, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(doKeyword);
            this.doKeyword = doKeyword;
            this.AdjustFlagsAndWidth(block);
            this.block = block;
        }

        internal DoStatementSyntax(SyntaxKind kind, SyntaxToken doKeyword, BlockSyntax block)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(doKeyword);
            this.doKeyword = doKeyword;
            this.AdjustFlagsAndWidth(block);
            this.block = block;
        }

        public SyntaxToken DoKeyword => this.doKeyword;
        public BlockSyntax Block => this.block;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.doKeyword,
                1 => this.block,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.DoStatementSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitDoStatement(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitDoStatement(this);

        public DoStatementSyntax Update(SyntaxToken doKeyword, BlockSyntax block)
        {
            if (doKeyword != this.DoKeyword || block != this.Block)
            {
                var newNode = SyntaxFactory.DoStatement(doKeyword, block);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new DoStatementSyntax(this.Kind, this.doKeyword, this.block, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new DoStatementSyntax(this.Kind, this.doKeyword, this.block, GetDiagnostics(), annotations);

        internal DoStatementSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var doKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(doKeyword);
            this.doKeyword = doKeyword;
            var block = (BlockSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(block);
            this.block = block;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.doKeyword);
            writer.WriteValue(this.block);
        }

        static DoStatementSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(DoStatementSyntax), r => new DoStatementSyntax(r));
        }
    }

    internal sealed partial class ExportStatementSyntax : StatementSyntax
    {
        internal readonly SyntaxToken exportKeyword;
        internal readonly GreenNode? names;
        internal readonly SimpleAssignmentExpressionSyntax? simpleAssignmentExpression;
        internal readonly SyntaxToken? asteriskToken;
        internal readonly SyntaxToken? caretToken;

        internal ExportStatementSyntax(SyntaxKind kind, SyntaxToken exportKeyword, GreenNode? names, SimpleAssignmentExpressionSyntax? simpleAssignmentExpression, SyntaxToken? asteriskToken, SyntaxToken? caretToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(exportKeyword);
            this.exportKeyword = exportKeyword;
            if (names != null)
            {
                this.AdjustFlagsAndWidth(names);
                this.names = names;
            }
            if (simpleAssignmentExpression != null)
            {
                this.AdjustFlagsAndWidth(simpleAssignmentExpression);
                this.simpleAssignmentExpression = simpleAssignmentExpression;
            }
            if (asteriskToken != null)
            {
                this.AdjustFlagsAndWidth(asteriskToken);
                this.asteriskToken = asteriskToken;
            }
            if (caretToken != null)
            {
                this.AdjustFlagsAndWidth(caretToken);
                this.caretToken = caretToken;
            }
        }

        internal ExportStatementSyntax(SyntaxKind kind, SyntaxToken exportKeyword, GreenNode? names, SimpleAssignmentExpressionSyntax? simpleAssignmentExpression, SyntaxToken? asteriskToken, SyntaxToken? caretToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(exportKeyword);
            this.exportKeyword = exportKeyword;
            if (names != null)
            {
                this.AdjustFlagsAndWidth(names);
                this.names = names;
            }
            if (simpleAssignmentExpression != null)
            {
                this.AdjustFlagsAndWidth(simpleAssignmentExpression);
                this.simpleAssignmentExpression = simpleAssignmentExpression;
            }
            if (asteriskToken != null)
            {
                this.AdjustFlagsAndWidth(asteriskToken);
                this.asteriskToken = asteriskToken;
            }
            if (caretToken != null)
            {
                this.AdjustFlagsAndWidth(caretToken);
                this.caretToken = caretToken;
            }
        }

        internal ExportStatementSyntax(SyntaxKind kind, SyntaxToken exportKeyword, GreenNode? names, SimpleAssignmentExpressionSyntax? simpleAssignmentExpression, SyntaxToken? asteriskToken, SyntaxToken? caretToken)
          : base(kind)
        {
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(exportKeyword);
            this.exportKeyword = exportKeyword;
            if (names != null)
            {
                this.AdjustFlagsAndWidth(names);
                this.names = names;
            }
            if (simpleAssignmentExpression != null)
            {
                this.AdjustFlagsAndWidth(simpleAssignmentExpression);
                this.simpleAssignmentExpression = simpleAssignmentExpression;
            }
            if (asteriskToken != null)
            {
                this.AdjustFlagsAndWidth(asteriskToken);
                this.asteriskToken = asteriskToken;
            }
            if (caretToken != null)
            {
                this.AdjustFlagsAndWidth(caretToken);
                this.caretToken = caretToken;
            }
        }

        public SyntaxToken ExportKeyword => this.exportKeyword;
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<IdentifierNameSyntax> Names => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<IdentifierNameSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MoonScriptSyntaxNode>(this.names));
        public SimpleAssignmentExpressionSyntax? SimpleAssignmentExpression => this.simpleAssignmentExpression;
        public SyntaxToken? AsteriskToken => this.asteriskToken;
        public SyntaxToken? CaretToken => this.caretToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.exportKeyword,
                1 => this.names,
                2 => this.simpleAssignmentExpression,
                3 => this.asteriskToken,
                4 => this.caretToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.ExportStatementSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitExportStatement(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitExportStatement(this);

        public ExportStatementSyntax Update(SyntaxToken exportKeyword, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<IdentifierNameSyntax> names, SimpleAssignmentExpressionSyntax simpleAssignmentExpression, SyntaxToken asteriskToken, SyntaxToken caretToken)
        {
            if (exportKeyword != this.ExportKeyword || names != this.Names || simpleAssignmentExpression != this.SimpleAssignmentExpression || asteriskToken != this.AsteriskToken || caretToken != this.CaretToken)
            {
                var newNode = SyntaxFactory.ExportStatement(exportKeyword, names, simpleAssignmentExpression, asteriskToken, caretToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ExportStatementSyntax(this.Kind, this.exportKeyword, this.names, this.simpleAssignmentExpression, this.asteriskToken, this.caretToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ExportStatementSyntax(this.Kind, this.exportKeyword, this.names, this.simpleAssignmentExpression, this.asteriskToken, this.caretToken, GetDiagnostics(), annotations);

        internal ExportStatementSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 5;
            var exportKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(exportKeyword);
            this.exportKeyword = exportKeyword;
            var names = (GreenNode?)reader.ReadValue();
            if (names != null)
            {
                AdjustFlagsAndWidth(names);
                this.names = names;
            }
            var simpleAssignmentExpression = (SimpleAssignmentExpressionSyntax?)reader.ReadValue();
            if (simpleAssignmentExpression != null)
            {
                AdjustFlagsAndWidth(simpleAssignmentExpression);
                this.simpleAssignmentExpression = simpleAssignmentExpression;
            }
            var asteriskToken = (SyntaxToken?)reader.ReadValue();
            if (asteriskToken != null)
            {
                AdjustFlagsAndWidth(asteriskToken);
                this.asteriskToken = asteriskToken;
            }
            var caretToken = (SyntaxToken?)reader.ReadValue();
            if (caretToken != null)
            {
                AdjustFlagsAndWidth(caretToken);
                this.caretToken = caretToken;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.exportKeyword);
            writer.WriteValue(this.names);
            writer.WriteValue(this.simpleAssignmentExpression);
            writer.WriteValue(this.asteriskToken);
            writer.WriteValue(this.caretToken);
        }

        static ExportStatementSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ExportStatementSyntax), r => new ExportStatementSyntax(r));
        }
    }

    internal sealed partial class ForStatementSyntax : StatementSyntax
    {
        internal readonly SyntaxToken forKeyword;
        internal readonly IdentifierNameSyntax name;
        internal readonly SyntaxToken equalsToken;
        internal readonly ExpressionSyntax initial;
        internal readonly SyntaxToken firstCommaToken;
        internal readonly ExpressionSyntax limit;
        internal readonly SyntaxToken secondCommaToken;
        internal readonly ExpressionSyntax step;
        internal readonly SyntaxToken? doKeyword;
        internal readonly BlockSyntax block;

        internal ForStatementSyntax(SyntaxKind kind, SyntaxToken forKeyword, IdentifierNameSyntax name, SyntaxToken equalsToken, ExpressionSyntax initial, SyntaxToken firstCommaToken, ExpressionSyntax limit, SyntaxToken secondCommaToken, ExpressionSyntax step, SyntaxToken? doKeyword, BlockSyntax block, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 10;
            this.AdjustFlagsAndWidth(forKeyword);
            this.forKeyword = forKeyword;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            this.AdjustFlagsAndWidth(initial);
            this.initial = initial;
            this.AdjustFlagsAndWidth(firstCommaToken);
            this.firstCommaToken = firstCommaToken;
            this.AdjustFlagsAndWidth(limit);
            this.limit = limit;
            this.AdjustFlagsAndWidth(secondCommaToken);
            this.secondCommaToken = secondCommaToken;
            this.AdjustFlagsAndWidth(step);
            this.step = step;
            if (doKeyword != null)
            {
                this.AdjustFlagsAndWidth(doKeyword);
                this.doKeyword = doKeyword;
            }
            this.AdjustFlagsAndWidth(block);
            this.block = block;
        }

        internal ForStatementSyntax(SyntaxKind kind, SyntaxToken forKeyword, IdentifierNameSyntax name, SyntaxToken equalsToken, ExpressionSyntax initial, SyntaxToken firstCommaToken, ExpressionSyntax limit, SyntaxToken secondCommaToken, ExpressionSyntax step, SyntaxToken? doKeyword, BlockSyntax block, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 10;
            this.AdjustFlagsAndWidth(forKeyword);
            this.forKeyword = forKeyword;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            this.AdjustFlagsAndWidth(initial);
            this.initial = initial;
            this.AdjustFlagsAndWidth(firstCommaToken);
            this.firstCommaToken = firstCommaToken;
            this.AdjustFlagsAndWidth(limit);
            this.limit = limit;
            this.AdjustFlagsAndWidth(secondCommaToken);
            this.secondCommaToken = secondCommaToken;
            this.AdjustFlagsAndWidth(step);
            this.step = step;
            if (doKeyword != null)
            {
                this.AdjustFlagsAndWidth(doKeyword);
                this.doKeyword = doKeyword;
            }
            this.AdjustFlagsAndWidth(block);
            this.block = block;
        }

        internal ForStatementSyntax(SyntaxKind kind, SyntaxToken forKeyword, IdentifierNameSyntax name, SyntaxToken equalsToken, ExpressionSyntax initial, SyntaxToken firstCommaToken, ExpressionSyntax limit, SyntaxToken secondCommaToken, ExpressionSyntax step, SyntaxToken? doKeyword, BlockSyntax block)
          : base(kind)
        {
            this.SlotCount = 10;
            this.AdjustFlagsAndWidth(forKeyword);
            this.forKeyword = forKeyword;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            this.AdjustFlagsAndWidth(initial);
            this.initial = initial;
            this.AdjustFlagsAndWidth(firstCommaToken);
            this.firstCommaToken = firstCommaToken;
            this.AdjustFlagsAndWidth(limit);
            this.limit = limit;
            this.AdjustFlagsAndWidth(secondCommaToken);
            this.secondCommaToken = secondCommaToken;
            this.AdjustFlagsAndWidth(step);
            this.step = step;
            if (doKeyword != null)
            {
                this.AdjustFlagsAndWidth(doKeyword);
                this.doKeyword = doKeyword;
            }
            this.AdjustFlagsAndWidth(block);
            this.block = block;
        }

        public SyntaxToken ForKeyword => this.forKeyword;
        public IdentifierNameSyntax Name => this.name;
        public SyntaxToken EqualsToken => this.equalsToken;
        public ExpressionSyntax Initial => this.initial;
        public SyntaxToken FirstCommaToken => this.firstCommaToken;
        public ExpressionSyntax Limit => this.limit;
        public SyntaxToken SecondCommaToken => this.secondCommaToken;
        public ExpressionSyntax Step => this.step;
        public SyntaxToken? DoKeyword => this.doKeyword;
        public BlockSyntax Block => this.block;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.forKeyword,
                1 => this.name,
                2 => this.equalsToken,
                3 => this.initial,
                4 => this.firstCommaToken,
                5 => this.limit,
                6 => this.secondCommaToken,
                7 => this.step,
                8 => this.doKeyword,
                9 => this.block,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.ForStatementSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitForStatement(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitForStatement(this);

        public ForStatementSyntax Update(SyntaxToken forKeyword, IdentifierNameSyntax name, SyntaxToken equalsToken, ExpressionSyntax initial, SyntaxToken firstCommaToken, ExpressionSyntax limit, SyntaxToken secondCommaToken, ExpressionSyntax step, SyntaxToken doKeyword, BlockSyntax block)
        {
            if (forKeyword != this.ForKeyword || name != this.Name || equalsToken != this.EqualsToken || initial != this.Initial || firstCommaToken != this.FirstCommaToken || limit != this.Limit || secondCommaToken != this.SecondCommaToken || step != this.Step || doKeyword != this.DoKeyword || block != this.Block)
            {
                var newNode = SyntaxFactory.ForStatement(forKeyword, name, equalsToken, initial, firstCommaToken, limit, secondCommaToken, step, doKeyword, block);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ForStatementSyntax(this.Kind, this.forKeyword, this.name, this.equalsToken, this.initial, this.firstCommaToken, this.limit, this.secondCommaToken, this.step, this.doKeyword, this.block, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ForStatementSyntax(this.Kind, this.forKeyword, this.name, this.equalsToken, this.initial, this.firstCommaToken, this.limit, this.secondCommaToken, this.step, this.doKeyword, this.block, GetDiagnostics(), annotations);

        internal ForStatementSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 10;
            var forKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(forKeyword);
            this.forKeyword = forKeyword;
            var name = (IdentifierNameSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(name);
            this.name = name;
            var equalsToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            var initial = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(initial);
            this.initial = initial;
            var firstCommaToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(firstCommaToken);
            this.firstCommaToken = firstCommaToken;
            var limit = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(limit);
            this.limit = limit;
            var secondCommaToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(secondCommaToken);
            this.secondCommaToken = secondCommaToken;
            var step = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(step);
            this.step = step;
            var doKeyword = (SyntaxToken?)reader.ReadValue();
            if (doKeyword != null)
            {
                AdjustFlagsAndWidth(doKeyword);
                this.doKeyword = doKeyword;
            }
            var block = (BlockSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(block);
            this.block = block;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.forKeyword);
            writer.WriteValue(this.name);
            writer.WriteValue(this.equalsToken);
            writer.WriteValue(this.initial);
            writer.WriteValue(this.firstCommaToken);
            writer.WriteValue(this.limit);
            writer.WriteValue(this.secondCommaToken);
            writer.WriteValue(this.step);
            writer.WriteValue(this.doKeyword);
            writer.WriteValue(this.block);
        }

        static ForStatementSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ForStatementSyntax), r => new ForStatementSyntax(r));
        }
    }

    internal sealed partial class ForInStatementSyntax : StatementSyntax
    {
        internal readonly SyntaxToken forKeyword;
        internal readonly GreenNode? names;
        internal readonly SyntaxToken inKeyword;
        internal readonly ExpressionSyntax iteration;
        internal readonly SyntaxToken? doKeyword;
        internal readonly BlockSyntax block;

        internal ForInStatementSyntax(SyntaxKind kind, SyntaxToken forKeyword, GreenNode? names, SyntaxToken inKeyword, ExpressionSyntax iteration, SyntaxToken? doKeyword, BlockSyntax block, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 6;
            this.AdjustFlagsAndWidth(forKeyword);
            this.forKeyword = forKeyword;
            if (names != null)
            {
                this.AdjustFlagsAndWidth(names);
                this.names = names;
            }
            this.AdjustFlagsAndWidth(inKeyword);
            this.inKeyword = inKeyword;
            this.AdjustFlagsAndWidth(iteration);
            this.iteration = iteration;
            if (doKeyword != null)
            {
                this.AdjustFlagsAndWidth(doKeyword);
                this.doKeyword = doKeyword;
            }
            this.AdjustFlagsAndWidth(block);
            this.block = block;
        }

        internal ForInStatementSyntax(SyntaxKind kind, SyntaxToken forKeyword, GreenNode? names, SyntaxToken inKeyword, ExpressionSyntax iteration, SyntaxToken? doKeyword, BlockSyntax block, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 6;
            this.AdjustFlagsAndWidth(forKeyword);
            this.forKeyword = forKeyword;
            if (names != null)
            {
                this.AdjustFlagsAndWidth(names);
                this.names = names;
            }
            this.AdjustFlagsAndWidth(inKeyword);
            this.inKeyword = inKeyword;
            this.AdjustFlagsAndWidth(iteration);
            this.iteration = iteration;
            if (doKeyword != null)
            {
                this.AdjustFlagsAndWidth(doKeyword);
                this.doKeyword = doKeyword;
            }
            this.AdjustFlagsAndWidth(block);
            this.block = block;
        }

        internal ForInStatementSyntax(SyntaxKind kind, SyntaxToken forKeyword, GreenNode? names, SyntaxToken inKeyword, ExpressionSyntax iteration, SyntaxToken? doKeyword, BlockSyntax block)
          : base(kind)
        {
            this.SlotCount = 6;
            this.AdjustFlagsAndWidth(forKeyword);
            this.forKeyword = forKeyword;
            if (names != null)
            {
                this.AdjustFlagsAndWidth(names);
                this.names = names;
            }
            this.AdjustFlagsAndWidth(inKeyword);
            this.inKeyword = inKeyword;
            this.AdjustFlagsAndWidth(iteration);
            this.iteration = iteration;
            if (doKeyword != null)
            {
                this.AdjustFlagsAndWidth(doKeyword);
                this.doKeyword = doKeyword;
            }
            this.AdjustFlagsAndWidth(block);
            this.block = block;
        }

        public SyntaxToken ForKeyword => this.forKeyword;
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<IdentifierNameSyntax> Names => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<IdentifierNameSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MoonScriptSyntaxNode>(this.names));
        public SyntaxToken InKeyword => this.inKeyword;
        public ExpressionSyntax Iteration => this.iteration;
        public SyntaxToken? DoKeyword => this.doKeyword;
        public BlockSyntax Block => this.block;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.forKeyword,
                1 => this.names,
                2 => this.inKeyword,
                3 => this.iteration,
                4 => this.doKeyword,
                5 => this.block,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.ForInStatementSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitForInStatement(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitForInStatement(this);

        public ForInStatementSyntax Update(SyntaxToken forKeyword, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<IdentifierNameSyntax> names, SyntaxToken inKeyword, ExpressionSyntax iteration, SyntaxToken doKeyword, BlockSyntax block)
        {
            if (forKeyword != this.ForKeyword || names != this.Names || inKeyword != this.InKeyword || iteration != this.Iteration || doKeyword != this.DoKeyword || block != this.Block)
            {
                var newNode = SyntaxFactory.ForInStatement(forKeyword, names, inKeyword, iteration, doKeyword, block);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ForInStatementSyntax(this.Kind, this.forKeyword, this.names, this.inKeyword, this.iteration, this.doKeyword, this.block, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ForInStatementSyntax(this.Kind, this.forKeyword, this.names, this.inKeyword, this.iteration, this.doKeyword, this.block, GetDiagnostics(), annotations);

        internal ForInStatementSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 6;
            var forKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(forKeyword);
            this.forKeyword = forKeyword;
            var names = (GreenNode?)reader.ReadValue();
            if (names != null)
            {
                AdjustFlagsAndWidth(names);
                this.names = names;
            }
            var inKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(inKeyword);
            this.inKeyword = inKeyword;
            var iteration = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(iteration);
            this.iteration = iteration;
            var doKeyword = (SyntaxToken?)reader.ReadValue();
            if (doKeyword != null)
            {
                AdjustFlagsAndWidth(doKeyword);
                this.doKeyword = doKeyword;
            }
            var block = (BlockSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(block);
            this.block = block;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.forKeyword);
            writer.WriteValue(this.names);
            writer.WriteValue(this.inKeyword);
            writer.WriteValue(this.iteration);
            writer.WriteValue(this.doKeyword);
            writer.WriteValue(this.block);
        }

        static ForInStatementSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ForInStatementSyntax), r => new ForInStatementSyntax(r));
        }
    }

    internal abstract partial class BaseConditionalStatementSyntax : StatementSyntax
    {
        internal BaseConditionalStatementSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal BaseConditionalStatementSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected BaseConditionalStatementSyntax(ObjectReader reader)
          : base(reader)
        {
        }

        public abstract ExpressionSyntax Condition { get; }

        public abstract BlockSyntax Block { get; }
    }

    internal sealed partial class IfStatementSyntax : BaseConditionalStatementSyntax
    {
        internal readonly ExpressionSyntax condition;
        internal readonly SyntaxToken? thenKeyword;
        internal readonly BlockSyntax block;
        internal readonly GreenNode? elseIfs;
        internal readonly ElseClauseSyntax? @else;

        internal IfStatementSyntax(SyntaxKind kind, ExpressionSyntax condition, SyntaxToken? thenKeyword, BlockSyntax block, GreenNode? elseIfs, ElseClauseSyntax? @else, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            if (thenKeyword != null)
            {
                this.AdjustFlagsAndWidth(thenKeyword);
                this.thenKeyword = thenKeyword;
            }
            this.AdjustFlagsAndWidth(block);
            this.block = block;
            if (elseIfs != null)
            {
                this.AdjustFlagsAndWidth(elseIfs);
                this.elseIfs = elseIfs;
            }
            if (@else != null)
            {
                this.AdjustFlagsAndWidth(@else);
                this.@else = @else;
            }
        }

        internal IfStatementSyntax(SyntaxKind kind, ExpressionSyntax condition, SyntaxToken? thenKeyword, BlockSyntax block, GreenNode? elseIfs, ElseClauseSyntax? @else, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            if (thenKeyword != null)
            {
                this.AdjustFlagsAndWidth(thenKeyword);
                this.thenKeyword = thenKeyword;
            }
            this.AdjustFlagsAndWidth(block);
            this.block = block;
            if (elseIfs != null)
            {
                this.AdjustFlagsAndWidth(elseIfs);
                this.elseIfs = elseIfs;
            }
            if (@else != null)
            {
                this.AdjustFlagsAndWidth(@else);
                this.@else = @else;
            }
        }

        internal IfStatementSyntax(SyntaxKind kind, ExpressionSyntax condition, SyntaxToken? thenKeyword, BlockSyntax block, GreenNode? elseIfs, ElseClauseSyntax? @else)
          : base(kind)
        {
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            if (thenKeyword != null)
            {
                this.AdjustFlagsAndWidth(thenKeyword);
                this.thenKeyword = thenKeyword;
            }
            this.AdjustFlagsAndWidth(block);
            this.block = block;
            if (elseIfs != null)
            {
                this.AdjustFlagsAndWidth(elseIfs);
                this.elseIfs = elseIfs;
            }
            if (@else != null)
            {
                this.AdjustFlagsAndWidth(@else);
                this.@else = @else;
            }
        }

        public override ExpressionSyntax Condition => this.condition;
        public SyntaxToken? ThenKeyword => this.thenKeyword;
        public override BlockSyntax Block => this.block;
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ElseIfClauseSyntax> ElseIfs => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ElseIfClauseSyntax>(this.elseIfs);
        public ElseClauseSyntax? Else => this.@else;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.condition,
                1 => this.thenKeyword,
                2 => this.block,
                3 => this.elseIfs,
                4 => this.@else,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.IfStatementSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitIfStatement(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitIfStatement(this);

        public IfStatementSyntax Update(ExpressionSyntax condition, SyntaxToken thenKeyword, BlockSyntax block, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ElseIfClauseSyntax> elseIfs, ElseClauseSyntax @else)
        {
            if (condition != this.Condition || thenKeyword != this.ThenKeyword || block != this.Block || elseIfs != this.ElseIfs || @else != this.Else)
            {
                var newNode = SyntaxFactory.IfStatement(condition, thenKeyword, block, elseIfs, @else);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new IfStatementSyntax(this.Kind, this.condition, this.thenKeyword, this.block, this.elseIfs, this.@else, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new IfStatementSyntax(this.Kind, this.condition, this.thenKeyword, this.block, this.elseIfs, this.@else, GetDiagnostics(), annotations);

        internal IfStatementSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 5;
            var condition = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(condition);
            this.condition = condition;
            var thenKeyword = (SyntaxToken?)reader.ReadValue();
            if (thenKeyword != null)
            {
                AdjustFlagsAndWidth(thenKeyword);
                this.thenKeyword = thenKeyword;
            }
            var block = (BlockSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(block);
            this.block = block;
            var elseIfs = (GreenNode?)reader.ReadValue();
            if (elseIfs != null)
            {
                AdjustFlagsAndWidth(elseIfs);
                this.elseIfs = elseIfs;
            }
            var @else = (ElseClauseSyntax?)reader.ReadValue();
            if (@else != null)
            {
                AdjustFlagsAndWidth(@else);
                this.@else = @else;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.condition);
            writer.WriteValue(this.thenKeyword);
            writer.WriteValue(this.block);
            writer.WriteValue(this.elseIfs);
            writer.WriteValue(this.@else);
        }

        static IfStatementSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(IfStatementSyntax), r => new IfStatementSyntax(r));
        }
    }

    internal sealed partial class ImportStatementSytnax : StatementSyntax
    {
        internal readonly SyntaxToken importKeyword;
        internal readonly GreenNode? names;
        internal readonly SyntaxToken fromKeyword;
        internal readonly IdentifierNameSyntax from;

        internal ImportStatementSytnax(SyntaxKind kind, SyntaxToken importKeyword, GreenNode? names, SyntaxToken fromKeyword, IdentifierNameSyntax from, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(importKeyword);
            this.importKeyword = importKeyword;
            if (names != null)
            {
                this.AdjustFlagsAndWidth(names);
                this.names = names;
            }
            this.AdjustFlagsAndWidth(fromKeyword);
            this.fromKeyword = fromKeyword;
            this.AdjustFlagsAndWidth(from);
            this.from = from;
        }

        internal ImportStatementSytnax(SyntaxKind kind, SyntaxToken importKeyword, GreenNode? names, SyntaxToken fromKeyword, IdentifierNameSyntax from, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(importKeyword);
            this.importKeyword = importKeyword;
            if (names != null)
            {
                this.AdjustFlagsAndWidth(names);
                this.names = names;
            }
            this.AdjustFlagsAndWidth(fromKeyword);
            this.fromKeyword = fromKeyword;
            this.AdjustFlagsAndWidth(from);
            this.from = from;
        }

        internal ImportStatementSytnax(SyntaxKind kind, SyntaxToken importKeyword, GreenNode? names, SyntaxToken fromKeyword, IdentifierNameSyntax from)
          : base(kind)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(importKeyword);
            this.importKeyword = importKeyword;
            if (names != null)
            {
                this.AdjustFlagsAndWidth(names);
                this.names = names;
            }
            this.AdjustFlagsAndWidth(fromKeyword);
            this.fromKeyword = fromKeyword;
            this.AdjustFlagsAndWidth(from);
            this.from = from;
        }

        public SyntaxToken ImportKeyword => this.importKeyword;
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ImportNameSyntax> Names => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ImportNameSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MoonScriptSyntaxNode>(this.names));
        public SyntaxToken FromKeyword => this.fromKeyword;
        public IdentifierNameSyntax From => this.from;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.importKeyword,
                1 => this.names,
                2 => this.fromKeyword,
                3 => this.from,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.ImportStatementSytnax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitImportStatementSytnax(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitImportStatementSytnax(this);

        public ImportStatementSytnax Update(SyntaxToken importKeyword, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ImportNameSyntax> names, SyntaxToken fromKeyword, IdentifierNameSyntax from)
        {
            if (importKeyword != this.ImportKeyword || names != this.Names || fromKeyword != this.FromKeyword || from != this.From)
            {
                var newNode = SyntaxFactory.ImportStatementSytnax(importKeyword, names, fromKeyword, from);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ImportStatementSytnax(this.Kind, this.importKeyword, this.names, this.fromKeyword, this.from, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ImportStatementSytnax(this.Kind, this.importKeyword, this.names, this.fromKeyword, this.from, GetDiagnostics(), annotations);

        internal ImportStatementSytnax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var importKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(importKeyword);
            this.importKeyword = importKeyword;
            var names = (GreenNode?)reader.ReadValue();
            if (names != null)
            {
                AdjustFlagsAndWidth(names);
                this.names = names;
            }
            var fromKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(fromKeyword);
            this.fromKeyword = fromKeyword;
            var from = (IdentifierNameSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(from);
            this.from = from;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.importKeyword);
            writer.WriteValue(this.names);
            writer.WriteValue(this.fromKeyword);
            writer.WriteValue(this.from);
        }

        static ImportStatementSytnax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ImportStatementSytnax), r => new ImportStatementSytnax(r));
        }
    }

    internal sealed partial class LocalStatementSyntax : StatementSyntax
    {
        internal readonly SyntaxToken localKeyword;
        internal readonly GreenNode? names;
        internal readonly SimpleAssignmentExpressionSyntax? simpleAssignmentExpression;
        internal readonly SyntaxToken? asteriskToken;

        internal LocalStatementSyntax(SyntaxKind kind, SyntaxToken localKeyword, GreenNode? names, SimpleAssignmentExpressionSyntax? simpleAssignmentExpression, SyntaxToken? asteriskToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(localKeyword);
            this.localKeyword = localKeyword;
            if (names != null)
            {
                this.AdjustFlagsAndWidth(names);
                this.names = names;
            }
            if (simpleAssignmentExpression != null)
            {
                this.AdjustFlagsAndWidth(simpleAssignmentExpression);
                this.simpleAssignmentExpression = simpleAssignmentExpression;
            }
            if (asteriskToken != null)
            {
                this.AdjustFlagsAndWidth(asteriskToken);
                this.asteriskToken = asteriskToken;
            }
        }

        internal LocalStatementSyntax(SyntaxKind kind, SyntaxToken localKeyword, GreenNode? names, SimpleAssignmentExpressionSyntax? simpleAssignmentExpression, SyntaxToken? asteriskToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(localKeyword);
            this.localKeyword = localKeyword;
            if (names != null)
            {
                this.AdjustFlagsAndWidth(names);
                this.names = names;
            }
            if (simpleAssignmentExpression != null)
            {
                this.AdjustFlagsAndWidth(simpleAssignmentExpression);
                this.simpleAssignmentExpression = simpleAssignmentExpression;
            }
            if (asteriskToken != null)
            {
                this.AdjustFlagsAndWidth(asteriskToken);
                this.asteriskToken = asteriskToken;
            }
        }

        internal LocalStatementSyntax(SyntaxKind kind, SyntaxToken localKeyword, GreenNode? names, SimpleAssignmentExpressionSyntax? simpleAssignmentExpression, SyntaxToken? asteriskToken)
          : base(kind)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(localKeyword);
            this.localKeyword = localKeyword;
            if (names != null)
            {
                this.AdjustFlagsAndWidth(names);
                this.names = names;
            }
            if (simpleAssignmentExpression != null)
            {
                this.AdjustFlagsAndWidth(simpleAssignmentExpression);
                this.simpleAssignmentExpression = simpleAssignmentExpression;
            }
            if (asteriskToken != null)
            {
                this.AdjustFlagsAndWidth(asteriskToken);
                this.asteriskToken = asteriskToken;
            }
        }

        public SyntaxToken LocalKeyword => this.localKeyword;
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<IdentifierNameSyntax> Names => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<IdentifierNameSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MoonScriptSyntaxNode>(this.names));
        public SimpleAssignmentExpressionSyntax? SimpleAssignmentExpression => this.simpleAssignmentExpression;
        public SyntaxToken? AsteriskToken => this.asteriskToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.localKeyword,
                1 => this.names,
                2 => this.simpleAssignmentExpression,
                3 => this.asteriskToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.LocalStatementSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitLocalStatement(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitLocalStatement(this);

        public LocalStatementSyntax Update(SyntaxToken localKeyword, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<IdentifierNameSyntax> names, SimpleAssignmentExpressionSyntax simpleAssignmentExpression, SyntaxToken asteriskToken)
        {
            if (localKeyword != this.LocalKeyword || names != this.Names || simpleAssignmentExpression != this.SimpleAssignmentExpression || asteriskToken != this.AsteriskToken)
            {
                var newNode = SyntaxFactory.LocalStatement(localKeyword, names, simpleAssignmentExpression, asteriskToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new LocalStatementSyntax(this.Kind, this.localKeyword, this.names, this.simpleAssignmentExpression, this.asteriskToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new LocalStatementSyntax(this.Kind, this.localKeyword, this.names, this.simpleAssignmentExpression, this.asteriskToken, GetDiagnostics(), annotations);

        internal LocalStatementSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var localKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(localKeyword);
            this.localKeyword = localKeyword;
            var names = (GreenNode?)reader.ReadValue();
            if (names != null)
            {
                AdjustFlagsAndWidth(names);
                this.names = names;
            }
            var simpleAssignmentExpression = (SimpleAssignmentExpressionSyntax?)reader.ReadValue();
            if (simpleAssignmentExpression != null)
            {
                AdjustFlagsAndWidth(simpleAssignmentExpression);
                this.simpleAssignmentExpression = simpleAssignmentExpression;
            }
            var asteriskToken = (SyntaxToken?)reader.ReadValue();
            if (asteriskToken != null)
            {
                AdjustFlagsAndWidth(asteriskToken);
                this.asteriskToken = asteriskToken;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.localKeyword);
            writer.WriteValue(this.names);
            writer.WriteValue(this.simpleAssignmentExpression);
            writer.WriteValue(this.asteriskToken);
        }

        static LocalStatementSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(LocalStatementSyntax), r => new LocalStatementSyntax(r));
        }
    }

    internal sealed partial class SwitchStatementSyntax : StatementSyntax
    {
        internal readonly ExpressionSyntax expression;
        internal readonly GreenNode? whens;
        internal readonly ElseClauseSyntax @else;

        internal SwitchStatementSyntax(SyntaxKind kind, ExpressionSyntax expression, GreenNode? whens, ElseClauseSyntax @else, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            if (whens != null)
            {
                this.AdjustFlagsAndWidth(whens);
                this.whens = whens;
            }
            this.AdjustFlagsAndWidth(@else);
            this.@else = @else;
        }

        internal SwitchStatementSyntax(SyntaxKind kind, ExpressionSyntax expression, GreenNode? whens, ElseClauseSyntax @else, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            if (whens != null)
            {
                this.AdjustFlagsAndWidth(whens);
                this.whens = whens;
            }
            this.AdjustFlagsAndWidth(@else);
            this.@else = @else;
        }

        internal SwitchStatementSyntax(SyntaxKind kind, ExpressionSyntax expression, GreenNode? whens, ElseClauseSyntax @else)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            if (whens != null)
            {
                this.AdjustFlagsAndWidth(whens);
                this.whens = whens;
            }
            this.AdjustFlagsAndWidth(@else);
            this.@else = @else;
        }

        public ExpressionSyntax Expression => this.expression;
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<WhenClauseSyntax> Whens => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<WhenClauseSyntax>(this.whens);
        public ElseClauseSyntax Else => this.@else;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.expression,
                1 => this.whens,
                2 => this.@else,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.SwitchStatementSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitSwitchStatement(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitSwitchStatement(this);

        public SwitchStatementSyntax Update(ExpressionSyntax expression, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<WhenClauseSyntax> whens, ElseClauseSyntax @else)
        {
            if (expression != this.Expression || whens != this.Whens || @else != this.Else)
            {
                var newNode = SyntaxFactory.SwitchStatement(expression, whens, @else);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new SwitchStatementSyntax(this.Kind, this.expression, this.whens, this.@else, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new SwitchStatementSyntax(this.Kind, this.expression, this.whens, this.@else, GetDiagnostics(), annotations);

        internal SwitchStatementSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var expression = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(expression);
            this.expression = expression;
            var whens = (GreenNode?)reader.ReadValue();
            if (whens != null)
            {
                AdjustFlagsAndWidth(whens);
                this.whens = whens;
            }
            var @else = (ElseClauseSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(@else);
            this.@else = @else;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.expression);
            writer.WriteValue(this.whens);
            writer.WriteValue(this.@else);
        }

        static SwitchStatementSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(SwitchStatementSyntax), r => new SwitchStatementSyntax(r));
        }
    }

    internal sealed partial class UnlessStatementSyntax : BaseConditionalStatementSyntax
    {
        internal readonly SyntaxToken unlessKeyword;
        internal readonly ExpressionSyntax condition;
        internal readonly SyntaxToken? thenKeyword;
        internal readonly BlockSyntax block;

        internal UnlessStatementSyntax(SyntaxKind kind, SyntaxToken unlessKeyword, ExpressionSyntax condition, SyntaxToken? thenKeyword, BlockSyntax block, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(unlessKeyword);
            this.unlessKeyword = unlessKeyword;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            if (thenKeyword != null)
            {
                this.AdjustFlagsAndWidth(thenKeyword);
                this.thenKeyword = thenKeyword;
            }
            this.AdjustFlagsAndWidth(block);
            this.block = block;
        }

        internal UnlessStatementSyntax(SyntaxKind kind, SyntaxToken unlessKeyword, ExpressionSyntax condition, SyntaxToken? thenKeyword, BlockSyntax block, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(unlessKeyword);
            this.unlessKeyword = unlessKeyword;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            if (thenKeyword != null)
            {
                this.AdjustFlagsAndWidth(thenKeyword);
                this.thenKeyword = thenKeyword;
            }
            this.AdjustFlagsAndWidth(block);
            this.block = block;
        }

        internal UnlessStatementSyntax(SyntaxKind kind, SyntaxToken unlessKeyword, ExpressionSyntax condition, SyntaxToken? thenKeyword, BlockSyntax block)
          : base(kind)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(unlessKeyword);
            this.unlessKeyword = unlessKeyword;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            if (thenKeyword != null)
            {
                this.AdjustFlagsAndWidth(thenKeyword);
                this.thenKeyword = thenKeyword;
            }
            this.AdjustFlagsAndWidth(block);
            this.block = block;
        }

        public SyntaxToken UnlessKeyword => this.unlessKeyword;
        public override ExpressionSyntax Condition => this.condition;
        public SyntaxToken? ThenKeyword => this.thenKeyword;
        public override BlockSyntax Block => this.block;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.unlessKeyword,
                1 => this.condition,
                2 => this.thenKeyword,
                3 => this.block,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.UnlessStatementSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitUnlessStatement(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitUnlessStatement(this);

        public UnlessStatementSyntax Update(SyntaxToken unlessKeyword, ExpressionSyntax condition, SyntaxToken thenKeyword, BlockSyntax block)
        {
            if (unlessKeyword != this.UnlessKeyword || condition != this.Condition || thenKeyword != this.ThenKeyword || block != this.Block)
            {
                var newNode = SyntaxFactory.UnlessStatement(unlessKeyword, condition, thenKeyword, block);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new UnlessStatementSyntax(this.Kind, this.unlessKeyword, this.condition, this.thenKeyword, this.block, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new UnlessStatementSyntax(this.Kind, this.unlessKeyword, this.condition, this.thenKeyword, this.block, GetDiagnostics(), annotations);

        internal UnlessStatementSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var unlessKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(unlessKeyword);
            this.unlessKeyword = unlessKeyword;
            var condition = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(condition);
            this.condition = condition;
            var thenKeyword = (SyntaxToken?)reader.ReadValue();
            if (thenKeyword != null)
            {
                AdjustFlagsAndWidth(thenKeyword);
                this.thenKeyword = thenKeyword;
            }
            var block = (BlockSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(block);
            this.block = block;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.unlessKeyword);
            writer.WriteValue(this.condition);
            writer.WriteValue(this.thenKeyword);
            writer.WriteValue(this.block);
        }

        static UnlessStatementSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(UnlessStatementSyntax), r => new UnlessStatementSyntax(r));
        }
    }

    internal sealed partial class UsingClauseSyntax : MoonScriptSyntaxNode
    {
        internal readonly SyntaxToken usingKeyword;
        internal readonly SyntaxToken? nilKeyword;
        internal readonly GreenNode? names;

        internal UsingClauseSyntax(SyntaxKind kind, SyntaxToken usingKeyword, SyntaxToken? nilKeyword, GreenNode? names, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(usingKeyword);
            this.usingKeyword = usingKeyword;
            if (nilKeyword != null)
            {
                this.AdjustFlagsAndWidth(nilKeyword);
                this.nilKeyword = nilKeyword;
            }
            if (names != null)
            {
                this.AdjustFlagsAndWidth(names);
                this.names = names;
            }
        }

        internal UsingClauseSyntax(SyntaxKind kind, SyntaxToken usingKeyword, SyntaxToken? nilKeyword, GreenNode? names, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(usingKeyword);
            this.usingKeyword = usingKeyword;
            if (nilKeyword != null)
            {
                this.AdjustFlagsAndWidth(nilKeyword);
                this.nilKeyword = nilKeyword;
            }
            if (names != null)
            {
                this.AdjustFlagsAndWidth(names);
                this.names = names;
            }
        }

        internal UsingClauseSyntax(SyntaxKind kind, SyntaxToken usingKeyword, SyntaxToken? nilKeyword, GreenNode? names)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(usingKeyword);
            this.usingKeyword = usingKeyword;
            if (nilKeyword != null)
            {
                this.AdjustFlagsAndWidth(nilKeyword);
                this.nilKeyword = nilKeyword;
            }
            if (names != null)
            {
                this.AdjustFlagsAndWidth(names);
                this.names = names;
            }
        }

        public SyntaxToken UsingKeyword => this.usingKeyword;
        public SyntaxToken? NilKeyword => this.nilKeyword;
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<IdentifierNameSyntax> Names => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<IdentifierNameSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MoonScriptSyntaxNode>(this.names));

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.usingKeyword,
                1 => this.nilKeyword,
                2 => this.names,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.UsingClauseSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitUsingClause(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitUsingClause(this);

        public UsingClauseSyntax Update(SyntaxToken usingKeyword, SyntaxToken nilKeyword, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<IdentifierNameSyntax> names)
        {
            if (usingKeyword != this.UsingKeyword || nilKeyword != this.NilKeyword || names != this.Names)
            {
                var newNode = SyntaxFactory.UsingClause(usingKeyword, nilKeyword, names);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new UsingClauseSyntax(this.Kind, this.usingKeyword, this.nilKeyword, this.names, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new UsingClauseSyntax(this.Kind, this.usingKeyword, this.nilKeyword, this.names, GetDiagnostics(), annotations);

        internal UsingClauseSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var usingKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(usingKeyword);
            this.usingKeyword = usingKeyword;
            var nilKeyword = (SyntaxToken?)reader.ReadValue();
            if (nilKeyword != null)
            {
                AdjustFlagsAndWidth(nilKeyword);
                this.nilKeyword = nilKeyword;
            }
            var names = (GreenNode?)reader.ReadValue();
            if (names != null)
            {
                AdjustFlagsAndWidth(names);
                this.names = names;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.usingKeyword);
            writer.WriteValue(this.nilKeyword);
            writer.WriteValue(this.names);
        }

        static UsingClauseSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(UsingClauseSyntax), r => new UsingClauseSyntax(r));
        }
    }

    internal sealed partial class WhileStatementSyntax : StatementSyntax
    {
        internal readonly SyntaxToken whileKeyword;
        internal readonly ExpressionSyntax condition;
        internal readonly SyntaxToken? doKeyword;
        internal readonly BlockSyntax block;

        internal WhileStatementSyntax(SyntaxKind kind, SyntaxToken whileKeyword, ExpressionSyntax condition, SyntaxToken? doKeyword, BlockSyntax block, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(whileKeyword);
            this.whileKeyword = whileKeyword;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            if (doKeyword != null)
            {
                this.AdjustFlagsAndWidth(doKeyword);
                this.doKeyword = doKeyword;
            }
            this.AdjustFlagsAndWidth(block);
            this.block = block;
        }

        internal WhileStatementSyntax(SyntaxKind kind, SyntaxToken whileKeyword, ExpressionSyntax condition, SyntaxToken? doKeyword, BlockSyntax block, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(whileKeyword);
            this.whileKeyword = whileKeyword;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            if (doKeyword != null)
            {
                this.AdjustFlagsAndWidth(doKeyword);
                this.doKeyword = doKeyword;
            }
            this.AdjustFlagsAndWidth(block);
            this.block = block;
        }

        internal WhileStatementSyntax(SyntaxKind kind, SyntaxToken whileKeyword, ExpressionSyntax condition, SyntaxToken? doKeyword, BlockSyntax block)
          : base(kind)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(whileKeyword);
            this.whileKeyword = whileKeyword;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            if (doKeyword != null)
            {
                this.AdjustFlagsAndWidth(doKeyword);
                this.doKeyword = doKeyword;
            }
            this.AdjustFlagsAndWidth(block);
            this.block = block;
        }

        public SyntaxToken WhileKeyword => this.whileKeyword;
        public ExpressionSyntax Condition => this.condition;
        public SyntaxToken? DoKeyword => this.doKeyword;
        public BlockSyntax Block => this.block;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.whileKeyword,
                1 => this.condition,
                2 => this.doKeyword,
                3 => this.block,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.WhileStatementSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitWhileStatement(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitWhileStatement(this);

        public WhileStatementSyntax Update(SyntaxToken whileKeyword, ExpressionSyntax condition, SyntaxToken doKeyword, BlockSyntax block)
        {
            if (whileKeyword != this.WhileKeyword || condition != this.Condition || doKeyword != this.DoKeyword || block != this.Block)
            {
                var newNode = SyntaxFactory.WhileStatement(whileKeyword, condition, doKeyword, block);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new WhileStatementSyntax(this.Kind, this.whileKeyword, this.condition, this.doKeyword, this.block, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new WhileStatementSyntax(this.Kind, this.whileKeyword, this.condition, this.doKeyword, this.block, GetDiagnostics(), annotations);

        internal WhileStatementSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var whileKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(whileKeyword);
            this.whileKeyword = whileKeyword;
            var condition = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(condition);
            this.condition = condition;
            var doKeyword = (SyntaxToken?)reader.ReadValue();
            if (doKeyword != null)
            {
                AdjustFlagsAndWidth(doKeyword);
                this.doKeyword = doKeyword;
            }
            var block = (BlockSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(block);
            this.block = block;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.whileKeyword);
            writer.WriteValue(this.condition);
            writer.WriteValue(this.doKeyword);
            writer.WriteValue(this.block);
        }

        static WhileStatementSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(WhileStatementSyntax), r => new WhileStatementSyntax(r));
        }
    }

    internal sealed partial class WithStatementSyntax : StatementSyntax
    {
        internal readonly SyntaxToken withKeyword;
        internal readonly ExpressionSyntax expression;
        internal readonly BlockSyntax block;

        internal WithStatementSyntax(SyntaxKind kind, SyntaxToken withKeyword, ExpressionSyntax expression, BlockSyntax block, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(withKeyword);
            this.withKeyword = withKeyword;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(block);
            this.block = block;
        }

        internal WithStatementSyntax(SyntaxKind kind, SyntaxToken withKeyword, ExpressionSyntax expression, BlockSyntax block, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(withKeyword);
            this.withKeyword = withKeyword;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(block);
            this.block = block;
        }

        internal WithStatementSyntax(SyntaxKind kind, SyntaxToken withKeyword, ExpressionSyntax expression, BlockSyntax block)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(withKeyword);
            this.withKeyword = withKeyword;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(block);
            this.block = block;
        }

        public SyntaxToken WithKeyword => this.withKeyword;
        public ExpressionSyntax Expression => this.expression;
        public BlockSyntax Block => this.block;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.withKeyword,
                1 => this.expression,
                2 => this.block,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.WithStatementSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitWithStatement(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitWithStatement(this);

        public WithStatementSyntax Update(SyntaxToken withKeyword, ExpressionSyntax expression, BlockSyntax block)
        {
            if (withKeyword != this.WithKeyword || expression != this.Expression || block != this.Block)
            {
                var newNode = SyntaxFactory.WithStatement(withKeyword, expression, block);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new WithStatementSyntax(this.Kind, this.withKeyword, this.expression, this.block, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new WithStatementSyntax(this.Kind, this.withKeyword, this.expression, this.block, GetDiagnostics(), annotations);

        internal WithStatementSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var withKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(withKeyword);
            this.withKeyword = withKeyword;
            var expression = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(expression);
            this.expression = expression;
            var block = (BlockSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(block);
            this.block = block;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.withKeyword);
            writer.WriteValue(this.expression);
            writer.WriteValue(this.block);
        }

        static WithStatementSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(WithStatementSyntax), r => new WithStatementSyntax(r));
        }
    }

    internal sealed partial class DestructuringAssignmentStatementSyntax : StatementSyntax
    {
        internal readonly DestructuringUnitSyntax unit;
        internal readonly SyntaxToken equalsToken;
        internal readonly ExpressionSyntax expression;

        internal DestructuringAssignmentStatementSyntax(SyntaxKind kind, DestructuringUnitSyntax unit, SyntaxToken equalsToken, ExpressionSyntax expression, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(unit);
            this.unit = unit;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        internal DestructuringAssignmentStatementSyntax(SyntaxKind kind, DestructuringUnitSyntax unit, SyntaxToken equalsToken, ExpressionSyntax expression, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(unit);
            this.unit = unit;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        internal DestructuringAssignmentStatementSyntax(SyntaxKind kind, DestructuringUnitSyntax unit, SyntaxToken equalsToken, ExpressionSyntax expression)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(unit);
            this.unit = unit;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        public DestructuringUnitSyntax Unit => this.unit;
        public SyntaxToken EqualsToken => this.equalsToken;
        public ExpressionSyntax Expression => this.expression;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.unit,
                1 => this.equalsToken,
                2 => this.expression,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.DestructuringAssignmentStatementSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitDestructuringAssignmentStatement(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitDestructuringAssignmentStatement(this);

        public DestructuringAssignmentStatementSyntax Update(DestructuringUnitSyntax unit, SyntaxToken equalsToken, ExpressionSyntax expression)
        {
            if (unit != this.Unit || equalsToken != this.EqualsToken || expression != this.Expression)
            {
                var newNode = SyntaxFactory.DestructuringAssignmentStatement(unit, equalsToken, expression);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new DestructuringAssignmentStatementSyntax(this.Kind, this.unit, this.equalsToken, this.expression, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new DestructuringAssignmentStatementSyntax(this.Kind, this.unit, this.equalsToken, this.expression, GetDiagnostics(), annotations);

        internal DestructuringAssignmentStatementSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var unit = (DestructuringUnitSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(unit);
            this.unit = unit;
            var equalsToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            var expression = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.unit);
            writer.WriteValue(this.equalsToken);
            writer.WriteValue(this.expression);
        }

        static DestructuringAssignmentStatementSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(DestructuringAssignmentStatementSyntax), r => new DestructuringAssignmentStatementSyntax(r));
        }
    }

    internal abstract partial class DestructuringUnitSyntax : MoonScriptSyntaxNode
    {
        internal DestructuringUnitSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal DestructuringUnitSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected DestructuringUnitSyntax(ObjectReader reader)
          : base(reader)
        {
        }
    }

    internal sealed partial class DestructuringIdentifierNameSyntax : DestructuringUnitSyntax
    {
        internal readonly IdentifierNameSyntax name;

        internal DestructuringIdentifierNameSyntax(SyntaxKind kind, IdentifierNameSyntax name, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
        }

        internal DestructuringIdentifierNameSyntax(SyntaxKind kind, IdentifierNameSyntax name, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
        }

        internal DestructuringIdentifierNameSyntax(SyntaxKind kind, IdentifierNameSyntax name)
          : base(kind)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
        }

        public IdentifierNameSyntax Name => this.name;

        internal override GreenNode? GetSlot(int index)
            => index == 0 ? this.name : null;

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.DestructuringIdentifierNameSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitDestructuringIdentifierName(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitDestructuringIdentifierName(this);

        public DestructuringIdentifierNameSyntax Update(IdentifierNameSyntax name)
        {
            if (name != this.Name)
            {
                var newNode = SyntaxFactory.DestructuringIdentifierName(name);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new DestructuringIdentifierNameSyntax(this.Kind, this.name, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new DestructuringIdentifierNameSyntax(this.Kind, this.name, GetDiagnostics(), annotations);

        internal DestructuringIdentifierNameSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 1;
            var name = (IdentifierNameSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(name);
            this.name = name;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.name);
        }

        static DestructuringIdentifierNameSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(DestructuringIdentifierNameSyntax), r => new DestructuringIdentifierNameSyntax(r));
        }
    }

    internal sealed partial class DestructuringListSyntax : DestructuringUnitSyntax
    {
        internal readonly GreenNode? units;

        internal DestructuringListSyntax(SyntaxKind kind, GreenNode? units, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 1;
            if (units != null)
            {
                this.AdjustFlagsAndWidth(units);
                this.units = units;
            }
        }

        internal DestructuringListSyntax(SyntaxKind kind, GreenNode? units, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 1;
            if (units != null)
            {
                this.AdjustFlagsAndWidth(units);
                this.units = units;
            }
        }

        internal DestructuringListSyntax(SyntaxKind kind, GreenNode? units)
          : base(kind)
        {
            this.SlotCount = 1;
            if (units != null)
            {
                this.AdjustFlagsAndWidth(units);
                this.units = units;
            }
        }

        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<DestructuringUnitSyntax> Units => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<DestructuringUnitSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MoonScriptSyntaxNode>(this.units));

        internal override GreenNode? GetSlot(int index)
            => index == 0 ? this.units : null;

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.DestructuringListSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitDestructuringList(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitDestructuringList(this);

        public DestructuringListSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<DestructuringUnitSyntax> units)
        {
            if (units != this.Units)
            {
                var newNode = SyntaxFactory.DestructuringList(units);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new DestructuringListSyntax(this.Kind, this.units, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new DestructuringListSyntax(this.Kind, this.units, GetDiagnostics(), annotations);

        internal DestructuringListSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 1;
            var units = (GreenNode?)reader.ReadValue();
            if (units != null)
            {
                AdjustFlagsAndWidth(units);
                this.units = units;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.units);
        }

        static DestructuringListSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(DestructuringListSyntax), r => new DestructuringListSyntax(r));
        }
    }

    internal sealed partial class DestructuringFieldSyntax : DestructuringUnitSyntax
    {
        internal readonly DestructuringUnitSyntax? unit;
        internal readonly NameColonSyntax? nameColon;
        internal readonly DestructuringUnitSyntax? namedUnit;
        internal readonly ColonNameSyntax? colonName;

        internal DestructuringFieldSyntax(SyntaxKind kind, DestructuringUnitSyntax? unit, NameColonSyntax? nameColon, DestructuringUnitSyntax? namedUnit, ColonNameSyntax? colonName, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            if (unit != null)
            {
                this.AdjustFlagsAndWidth(unit);
                this.unit = unit;
            }
            if (nameColon != null)
            {
                this.AdjustFlagsAndWidth(nameColon);
                this.nameColon = nameColon;
            }
            if (namedUnit != null)
            {
                this.AdjustFlagsAndWidth(namedUnit);
                this.namedUnit = namedUnit;
            }
            if (colonName != null)
            {
                this.AdjustFlagsAndWidth(colonName);
                this.colonName = colonName;
            }
        }

        internal DestructuringFieldSyntax(SyntaxKind kind, DestructuringUnitSyntax? unit, NameColonSyntax? nameColon, DestructuringUnitSyntax? namedUnit, ColonNameSyntax? colonName, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 4;
            if (unit != null)
            {
                this.AdjustFlagsAndWidth(unit);
                this.unit = unit;
            }
            if (nameColon != null)
            {
                this.AdjustFlagsAndWidth(nameColon);
                this.nameColon = nameColon;
            }
            if (namedUnit != null)
            {
                this.AdjustFlagsAndWidth(namedUnit);
                this.namedUnit = namedUnit;
            }
            if (colonName != null)
            {
                this.AdjustFlagsAndWidth(colonName);
                this.colonName = colonName;
            }
        }

        internal DestructuringFieldSyntax(SyntaxKind kind, DestructuringUnitSyntax? unit, NameColonSyntax? nameColon, DestructuringUnitSyntax? namedUnit, ColonNameSyntax? colonName)
          : base(kind)
        {
            this.SlotCount = 4;
            if (unit != null)
            {
                this.AdjustFlagsAndWidth(unit);
                this.unit = unit;
            }
            if (nameColon != null)
            {
                this.AdjustFlagsAndWidth(nameColon);
                this.nameColon = nameColon;
            }
            if (namedUnit != null)
            {
                this.AdjustFlagsAndWidth(namedUnit);
                this.namedUnit = namedUnit;
            }
            if (colonName != null)
            {
                this.AdjustFlagsAndWidth(colonName);
                this.colonName = colonName;
            }
        }

        public DestructuringUnitSyntax? Unit => this.unit;
        public NameColonSyntax? NameColon => this.nameColon;
        public DestructuringUnitSyntax? NamedUnit => this.namedUnit;
        public ColonNameSyntax? ColonName => this.colonName;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.unit,
                1 => this.nameColon,
                2 => this.namedUnit,
                3 => this.colonName,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.DestructuringFieldSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitDestructuringField(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitDestructuringField(this);

        public DestructuringFieldSyntax Update(DestructuringUnitSyntax unit, NameColonSyntax nameColon, DestructuringUnitSyntax namedUnit, ColonNameSyntax colonName)
        {
            if (unit != this.Unit || nameColon != this.NameColon || namedUnit != this.NamedUnit || colonName != this.ColonName)
            {
                var newNode = SyntaxFactory.DestructuringField(unit, nameColon, namedUnit, colonName);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new DestructuringFieldSyntax(this.Kind, this.unit, this.nameColon, this.namedUnit, this.colonName, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new DestructuringFieldSyntax(this.Kind, this.unit, this.nameColon, this.namedUnit, this.colonName, GetDiagnostics(), annotations);

        internal DestructuringFieldSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var unit = (DestructuringUnitSyntax?)reader.ReadValue();
            if (unit != null)
            {
                AdjustFlagsAndWidth(unit);
                this.unit = unit;
            }
            var nameColon = (NameColonSyntax?)reader.ReadValue();
            if (nameColon != null)
            {
                AdjustFlagsAndWidth(nameColon);
                this.nameColon = nameColon;
            }
            var namedUnit = (DestructuringUnitSyntax?)reader.ReadValue();
            if (namedUnit != null)
            {
                AdjustFlagsAndWidth(namedUnit);
                this.namedUnit = namedUnit;
            }
            var colonName = (ColonNameSyntax?)reader.ReadValue();
            if (colonName != null)
            {
                AdjustFlagsAndWidth(colonName);
                this.colonName = colonName;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.unit);
            writer.WriteValue(this.nameColon);
            writer.WriteValue(this.namedUnit);
            writer.WriteValue(this.colonName);
        }

        static DestructuringFieldSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(DestructuringFieldSyntax), r => new DestructuringFieldSyntax(r));
        }
    }

    internal sealed partial class DestructuringTableSyntax : DestructuringUnitSyntax
    {
        internal readonly SyntaxToken? openBraceToken;
        internal readonly GreenNode? fields;
        internal readonly SyntaxToken? closeBraceToken;

        internal DestructuringTableSyntax(SyntaxKind kind, SyntaxToken? openBraceToken, GreenNode? fields, SyntaxToken? closeBraceToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            if (openBraceToken != null)
            {
                this.AdjustFlagsAndWidth(openBraceToken);
                this.openBraceToken = openBraceToken;
            }
            if (fields != null)
            {
                this.AdjustFlagsAndWidth(fields);
                this.fields = fields;
            }
            if (closeBraceToken != null)
            {
                this.AdjustFlagsAndWidth(closeBraceToken);
                this.closeBraceToken = closeBraceToken;
            }
        }

        internal DestructuringTableSyntax(SyntaxKind kind, SyntaxToken? openBraceToken, GreenNode? fields, SyntaxToken? closeBraceToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            if (openBraceToken != null)
            {
                this.AdjustFlagsAndWidth(openBraceToken);
                this.openBraceToken = openBraceToken;
            }
            if (fields != null)
            {
                this.AdjustFlagsAndWidth(fields);
                this.fields = fields;
            }
            if (closeBraceToken != null)
            {
                this.AdjustFlagsAndWidth(closeBraceToken);
                this.closeBraceToken = closeBraceToken;
            }
        }

        internal DestructuringTableSyntax(SyntaxKind kind, SyntaxToken? openBraceToken, GreenNode? fields, SyntaxToken? closeBraceToken)
          : base(kind)
        {
            this.SlotCount = 3;
            if (openBraceToken != null)
            {
                this.AdjustFlagsAndWidth(openBraceToken);
                this.openBraceToken = openBraceToken;
            }
            if (fields != null)
            {
                this.AdjustFlagsAndWidth(fields);
                this.fields = fields;
            }
            if (closeBraceToken != null)
            {
                this.AdjustFlagsAndWidth(closeBraceToken);
                this.closeBraceToken = closeBraceToken;
            }
        }

        public SyntaxToken? OpenBraceToken => this.openBraceToken;
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<DestructuringFieldSyntax> Fields => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<DestructuringFieldSyntax>(this.fields);
        public SyntaxToken? CloseBraceToken => this.closeBraceToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.openBraceToken,
                1 => this.fields,
                2 => this.closeBraceToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.DestructuringTableSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitDestructuringTable(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitDestructuringTable(this);

        public DestructuringTableSyntax Update(SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<DestructuringFieldSyntax> fields, SyntaxToken closeBraceToken)
        {
            if (openBraceToken != this.OpenBraceToken || fields != this.Fields || closeBraceToken != this.CloseBraceToken)
            {
                var newNode = SyntaxFactory.DestructuringTable(openBraceToken, fields, closeBraceToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new DestructuringTableSyntax(this.Kind, this.openBraceToken, this.fields, this.closeBraceToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new DestructuringTableSyntax(this.Kind, this.openBraceToken, this.fields, this.closeBraceToken, GetDiagnostics(), annotations);

        internal DestructuringTableSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var openBraceToken = (SyntaxToken?)reader.ReadValue();
            if (openBraceToken != null)
            {
                AdjustFlagsAndWidth(openBraceToken);
                this.openBraceToken = openBraceToken;
            }
            var fields = (GreenNode?)reader.ReadValue();
            if (fields != null)
            {
                AdjustFlagsAndWidth(fields);
                this.fields = fields;
            }
            var closeBraceToken = (SyntaxToken?)reader.ReadValue();
            if (closeBraceToken != null)
            {
                AdjustFlagsAndWidth(closeBraceToken);
                this.closeBraceToken = closeBraceToken;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.openBraceToken);
            writer.WriteValue(this.fields);
            writer.WriteValue(this.closeBraceToken);
        }

        static DestructuringTableSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(DestructuringTableSyntax), r => new DestructuringTableSyntax(r));
        }
    }

    internal abstract partial class LineDecoratorSyntax : MoonScriptSyntaxNode
    {
        internal LineDecoratorSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal LineDecoratorSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected LineDecoratorSyntax(ObjectReader reader)
          : base(reader)
        {
        }
    }

    internal sealed partial class ForLineDecoratorSyntax : LineDecoratorSyntax
    {
        internal readonly SyntaxToken forKeyword;
        internal readonly IdentifierNameSyntax name;
        internal readonly SyntaxToken equalsToken;
        internal readonly ExpressionSyntax initial;
        internal readonly SyntaxToken firstCommaToken;
        internal readonly ExpressionSyntax limit;
        internal readonly SyntaxToken secondCommaToken;
        internal readonly ExpressionSyntax step;

        internal ForLineDecoratorSyntax(SyntaxKind kind, SyntaxToken forKeyword, IdentifierNameSyntax name, SyntaxToken equalsToken, ExpressionSyntax initial, SyntaxToken firstCommaToken, ExpressionSyntax limit, SyntaxToken secondCommaToken, ExpressionSyntax step, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 8;
            this.AdjustFlagsAndWidth(forKeyword);
            this.forKeyword = forKeyword;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            this.AdjustFlagsAndWidth(initial);
            this.initial = initial;
            this.AdjustFlagsAndWidth(firstCommaToken);
            this.firstCommaToken = firstCommaToken;
            this.AdjustFlagsAndWidth(limit);
            this.limit = limit;
            this.AdjustFlagsAndWidth(secondCommaToken);
            this.secondCommaToken = secondCommaToken;
            this.AdjustFlagsAndWidth(step);
            this.step = step;
        }

        internal ForLineDecoratorSyntax(SyntaxKind kind, SyntaxToken forKeyword, IdentifierNameSyntax name, SyntaxToken equalsToken, ExpressionSyntax initial, SyntaxToken firstCommaToken, ExpressionSyntax limit, SyntaxToken secondCommaToken, ExpressionSyntax step, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 8;
            this.AdjustFlagsAndWidth(forKeyword);
            this.forKeyword = forKeyword;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            this.AdjustFlagsAndWidth(initial);
            this.initial = initial;
            this.AdjustFlagsAndWidth(firstCommaToken);
            this.firstCommaToken = firstCommaToken;
            this.AdjustFlagsAndWidth(limit);
            this.limit = limit;
            this.AdjustFlagsAndWidth(secondCommaToken);
            this.secondCommaToken = secondCommaToken;
            this.AdjustFlagsAndWidth(step);
            this.step = step;
        }

        internal ForLineDecoratorSyntax(SyntaxKind kind, SyntaxToken forKeyword, IdentifierNameSyntax name, SyntaxToken equalsToken, ExpressionSyntax initial, SyntaxToken firstCommaToken, ExpressionSyntax limit, SyntaxToken secondCommaToken, ExpressionSyntax step)
          : base(kind)
        {
            this.SlotCount = 8;
            this.AdjustFlagsAndWidth(forKeyword);
            this.forKeyword = forKeyword;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            this.AdjustFlagsAndWidth(initial);
            this.initial = initial;
            this.AdjustFlagsAndWidth(firstCommaToken);
            this.firstCommaToken = firstCommaToken;
            this.AdjustFlagsAndWidth(limit);
            this.limit = limit;
            this.AdjustFlagsAndWidth(secondCommaToken);
            this.secondCommaToken = secondCommaToken;
            this.AdjustFlagsAndWidth(step);
            this.step = step;
        }

        public SyntaxToken ForKeyword => this.forKeyword;
        public IdentifierNameSyntax Name => this.name;
        public SyntaxToken EqualsToken => this.equalsToken;
        public ExpressionSyntax Initial => this.initial;
        public SyntaxToken FirstCommaToken => this.firstCommaToken;
        public ExpressionSyntax Limit => this.limit;
        public SyntaxToken SecondCommaToken => this.secondCommaToken;
        public ExpressionSyntax Step => this.step;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.forKeyword,
                1 => this.name,
                2 => this.equalsToken,
                3 => this.initial,
                4 => this.firstCommaToken,
                5 => this.limit,
                6 => this.secondCommaToken,
                7 => this.step,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.ForLineDecoratorSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitForLineDecorator(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitForLineDecorator(this);

        public ForLineDecoratorSyntax Update(SyntaxToken forKeyword, IdentifierNameSyntax name, SyntaxToken equalsToken, ExpressionSyntax initial, SyntaxToken firstCommaToken, ExpressionSyntax limit, SyntaxToken secondCommaToken, ExpressionSyntax step)
        {
            if (forKeyword != this.ForKeyword || name != this.Name || equalsToken != this.EqualsToken || initial != this.Initial || firstCommaToken != this.FirstCommaToken || limit != this.Limit || secondCommaToken != this.SecondCommaToken || step != this.Step)
            {
                var newNode = SyntaxFactory.ForLineDecorator(forKeyword, name, equalsToken, initial, firstCommaToken, limit, secondCommaToken, step);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ForLineDecoratorSyntax(this.Kind, this.forKeyword, this.name, this.equalsToken, this.initial, this.firstCommaToken, this.limit, this.secondCommaToken, this.step, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ForLineDecoratorSyntax(this.Kind, this.forKeyword, this.name, this.equalsToken, this.initial, this.firstCommaToken, this.limit, this.secondCommaToken, this.step, GetDiagnostics(), annotations);

        internal ForLineDecoratorSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 8;
            var forKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(forKeyword);
            this.forKeyword = forKeyword;
            var name = (IdentifierNameSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(name);
            this.name = name;
            var equalsToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            var initial = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(initial);
            this.initial = initial;
            var firstCommaToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(firstCommaToken);
            this.firstCommaToken = firstCommaToken;
            var limit = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(limit);
            this.limit = limit;
            var secondCommaToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(secondCommaToken);
            this.secondCommaToken = secondCommaToken;
            var step = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(step);
            this.step = step;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.forKeyword);
            writer.WriteValue(this.name);
            writer.WriteValue(this.equalsToken);
            writer.WriteValue(this.initial);
            writer.WriteValue(this.firstCommaToken);
            writer.WriteValue(this.limit);
            writer.WriteValue(this.secondCommaToken);
            writer.WriteValue(this.step);
        }

        static ForLineDecoratorSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ForLineDecoratorSyntax), r => new ForLineDecoratorSyntax(r));
        }
    }

    internal sealed partial class ForInLineDecoratorSyntax : LineDecoratorSyntax
    {
        internal readonly SyntaxToken forKeyword;
        internal readonly GreenNode? names;
        internal readonly SyntaxToken inKeyword;
        internal readonly ExpressionSyntax iteration;

        internal ForInLineDecoratorSyntax(SyntaxKind kind, SyntaxToken forKeyword, GreenNode? names, SyntaxToken inKeyword, ExpressionSyntax iteration, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(forKeyword);
            this.forKeyword = forKeyword;
            if (names != null)
            {
                this.AdjustFlagsAndWidth(names);
                this.names = names;
            }
            this.AdjustFlagsAndWidth(inKeyword);
            this.inKeyword = inKeyword;
            this.AdjustFlagsAndWidth(iteration);
            this.iteration = iteration;
        }

        internal ForInLineDecoratorSyntax(SyntaxKind kind, SyntaxToken forKeyword, GreenNode? names, SyntaxToken inKeyword, ExpressionSyntax iteration, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(forKeyword);
            this.forKeyword = forKeyword;
            if (names != null)
            {
                this.AdjustFlagsAndWidth(names);
                this.names = names;
            }
            this.AdjustFlagsAndWidth(inKeyword);
            this.inKeyword = inKeyword;
            this.AdjustFlagsAndWidth(iteration);
            this.iteration = iteration;
        }

        internal ForInLineDecoratorSyntax(SyntaxKind kind, SyntaxToken forKeyword, GreenNode? names, SyntaxToken inKeyword, ExpressionSyntax iteration)
          : base(kind)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(forKeyword);
            this.forKeyword = forKeyword;
            if (names != null)
            {
                this.AdjustFlagsAndWidth(names);
                this.names = names;
            }
            this.AdjustFlagsAndWidth(inKeyword);
            this.inKeyword = inKeyword;
            this.AdjustFlagsAndWidth(iteration);
            this.iteration = iteration;
        }

        public SyntaxToken ForKeyword => this.forKeyword;
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<IdentifierNameSyntax> Names => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<IdentifierNameSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MoonScriptSyntaxNode>(this.names));
        public SyntaxToken InKeyword => this.inKeyword;
        public ExpressionSyntax Iteration => this.iteration;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.forKeyword,
                1 => this.names,
                2 => this.inKeyword,
                3 => this.iteration,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.ForInLineDecoratorSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitForInLineDecorator(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitForInLineDecorator(this);

        public ForInLineDecoratorSyntax Update(SyntaxToken forKeyword, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<IdentifierNameSyntax> names, SyntaxToken inKeyword, ExpressionSyntax iteration)
        {
            if (forKeyword != this.ForKeyword || names != this.Names || inKeyword != this.InKeyword || iteration != this.Iteration)
            {
                var newNode = SyntaxFactory.ForInLineDecorator(forKeyword, names, inKeyword, iteration);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ForInLineDecoratorSyntax(this.Kind, this.forKeyword, this.names, this.inKeyword, this.iteration, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ForInLineDecoratorSyntax(this.Kind, this.forKeyword, this.names, this.inKeyword, this.iteration, GetDiagnostics(), annotations);

        internal ForInLineDecoratorSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var forKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(forKeyword);
            this.forKeyword = forKeyword;
            var names = (GreenNode?)reader.ReadValue();
            if (names != null)
            {
                AdjustFlagsAndWidth(names);
                this.names = names;
            }
            var inKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(inKeyword);
            this.inKeyword = inKeyword;
            var iteration = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(iteration);
            this.iteration = iteration;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.forKeyword);
            writer.WriteValue(this.names);
            writer.WriteValue(this.inKeyword);
            writer.WriteValue(this.iteration);
        }

        static ForInLineDecoratorSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ForInLineDecoratorSyntax), r => new ForInLineDecoratorSyntax(r));
        }
    }

    internal abstract partial class ConditionalLineDecoratorSyntax : LineDecoratorSyntax
    {
        internal ConditionalLineDecoratorSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal ConditionalLineDecoratorSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected ConditionalLineDecoratorSyntax(ObjectReader reader)
          : base(reader)
        {
        }

        public abstract ExpressionSyntax Condition { get; }
    }

    internal sealed partial class IfLineDecoratorSyntax : ConditionalLineDecoratorSyntax
    {
        internal readonly SyntaxToken ifKeyword;
        internal readonly ExpressionSyntax condition;

        internal IfLineDecoratorSyntax(SyntaxKind kind, SyntaxToken ifKeyword, ExpressionSyntax condition, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(ifKeyword);
            this.ifKeyword = ifKeyword;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
        }

        internal IfLineDecoratorSyntax(SyntaxKind kind, SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(ifKeyword);
            this.ifKeyword = ifKeyword;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
        }

        internal IfLineDecoratorSyntax(SyntaxKind kind, SyntaxToken ifKeyword, ExpressionSyntax condition)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(ifKeyword);
            this.ifKeyword = ifKeyword;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
        }

        public SyntaxToken IfKeyword => this.ifKeyword;
        public override ExpressionSyntax Condition => this.condition;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.ifKeyword,
                1 => this.condition,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.IfLineDecoratorSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitIfLineDecorator(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitIfLineDecorator(this);

        public IfLineDecoratorSyntax Update(SyntaxToken ifKeyword, ExpressionSyntax condition)
        {
            if (ifKeyword != this.IfKeyword || condition != this.Condition)
            {
                var newNode = SyntaxFactory.IfLineDecorator(ifKeyword, condition);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new IfLineDecoratorSyntax(this.Kind, this.ifKeyword, this.condition, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new IfLineDecoratorSyntax(this.Kind, this.ifKeyword, this.condition, GetDiagnostics(), annotations);

        internal IfLineDecoratorSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var ifKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(ifKeyword);
            this.ifKeyword = ifKeyword;
            var condition = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(condition);
            this.condition = condition;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.ifKeyword);
            writer.WriteValue(this.condition);
        }

        static IfLineDecoratorSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(IfLineDecoratorSyntax), r => new IfLineDecoratorSyntax(r));
        }
    }

    internal sealed partial class UnlessLineDecoratorSyntax : ConditionalLineDecoratorSyntax
    {
        internal readonly SyntaxToken unlessKeyword;
        internal readonly ExpressionSyntax condition;

        internal UnlessLineDecoratorSyntax(SyntaxKind kind, SyntaxToken unlessKeyword, ExpressionSyntax condition, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(unlessKeyword);
            this.unlessKeyword = unlessKeyword;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
        }

        internal UnlessLineDecoratorSyntax(SyntaxKind kind, SyntaxToken unlessKeyword, ExpressionSyntax condition, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(unlessKeyword);
            this.unlessKeyword = unlessKeyword;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
        }

        internal UnlessLineDecoratorSyntax(SyntaxKind kind, SyntaxToken unlessKeyword, ExpressionSyntax condition)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(unlessKeyword);
            this.unlessKeyword = unlessKeyword;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
        }

        public SyntaxToken UnlessKeyword => this.unlessKeyword;
        public override ExpressionSyntax Condition => this.condition;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.unlessKeyword,
                1 => this.condition,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.UnlessLineDecoratorSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitUnlessLineDecorator(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitUnlessLineDecorator(this);

        public UnlessLineDecoratorSyntax Update(SyntaxToken unlessKeyword, ExpressionSyntax condition)
        {
            if (unlessKeyword != this.UnlessKeyword || condition != this.Condition)
            {
                var newNode = SyntaxFactory.UnlessLineDecorator(unlessKeyword, condition);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new UnlessLineDecoratorSyntax(this.Kind, this.unlessKeyword, this.condition, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new UnlessLineDecoratorSyntax(this.Kind, this.unlessKeyword, this.condition, GetDiagnostics(), annotations);

        internal UnlessLineDecoratorSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var unlessKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(unlessKeyword);
            this.unlessKeyword = unlessKeyword;
            var condition = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(condition);
            this.condition = condition;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.unlessKeyword);
            writer.WriteValue(this.condition);
        }

        static UnlessLineDecoratorSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(UnlessLineDecoratorSyntax), r => new UnlessLineDecoratorSyntax(r));
        }
    }

    internal sealed partial class WhileLineDecoratorSyntax : LineDecoratorSyntax
    {
        internal readonly SyntaxToken whileKeyword;
        internal readonly ExpressionSyntax condition;

        internal WhileLineDecoratorSyntax(SyntaxKind kind, SyntaxToken whileKeyword, ExpressionSyntax condition, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(whileKeyword);
            this.whileKeyword = whileKeyword;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
        }

        internal WhileLineDecoratorSyntax(SyntaxKind kind, SyntaxToken whileKeyword, ExpressionSyntax condition, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(whileKeyword);
            this.whileKeyword = whileKeyword;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
        }

        internal WhileLineDecoratorSyntax(SyntaxKind kind, SyntaxToken whileKeyword, ExpressionSyntax condition)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(whileKeyword);
            this.whileKeyword = whileKeyword;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
        }

        public SyntaxToken WhileKeyword => this.whileKeyword;
        public ExpressionSyntax Condition => this.condition;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.whileKeyword,
                1 => this.condition,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.WhileLineDecoratorSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitWhileLineDecorator(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitWhileLineDecorator(this);

        public WhileLineDecoratorSyntax Update(SyntaxToken whileKeyword, ExpressionSyntax condition)
        {
            if (whileKeyword != this.WhileKeyword || condition != this.Condition)
            {
                var newNode = SyntaxFactory.WhileLineDecorator(whileKeyword, condition);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new WhileLineDecoratorSyntax(this.Kind, this.whileKeyword, this.condition, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new WhileLineDecoratorSyntax(this.Kind, this.whileKeyword, this.condition, GetDiagnostics(), annotations);

        internal WhileLineDecoratorSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var whileKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(whileKeyword);
            this.whileKeyword = whileKeyword;
            var condition = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(condition);
            this.condition = condition;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.whileKeyword);
            writer.WriteValue(this.condition);
        }

        static WhileLineDecoratorSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(WhileLineDecoratorSyntax), r => new WhileLineDecoratorSyntax(r));
        }
    }

    internal sealed partial class ChunkSyntax : MoonScriptSyntaxNode
    {
        internal readonly BlockSyntax block;
        internal readonly SyntaxToken endOfFileToken;

        internal ChunkSyntax(SyntaxKind kind, BlockSyntax block, SyntaxToken endOfFileToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(block);
            this.block = block;
            this.AdjustFlagsAndWidth(endOfFileToken);
            this.endOfFileToken = endOfFileToken;
        }

        internal ChunkSyntax(SyntaxKind kind, BlockSyntax block, SyntaxToken endOfFileToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(block);
            this.block = block;
            this.AdjustFlagsAndWidth(endOfFileToken);
            this.endOfFileToken = endOfFileToken;
        }

        internal ChunkSyntax(SyntaxKind kind, BlockSyntax block, SyntaxToken endOfFileToken)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(block);
            this.block = block;
            this.AdjustFlagsAndWidth(endOfFileToken);
            this.endOfFileToken = endOfFileToken;
        }

        public BlockSyntax Block => this.block;
        public SyntaxToken EndOfFileToken => this.endOfFileToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.block,
                1 => this.endOfFileToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.ChunkSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitChunk(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitChunk(this);

        public ChunkSyntax Update(BlockSyntax block, SyntaxToken endOfFileToken)
        {
            if (block != this.Block || endOfFileToken != this.EndOfFileToken)
            {
                var newNode = SyntaxFactory.Chunk(block, endOfFileToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ChunkSyntax(this.Kind, this.block, this.endOfFileToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ChunkSyntax(this.Kind, this.block, this.endOfFileToken, GetDiagnostics(), annotations);

        internal ChunkSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var block = (BlockSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(block);
            this.block = block;
            var endOfFileToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(endOfFileToken);
            this.endOfFileToken = endOfFileToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.block);
            writer.WriteValue(this.endOfFileToken);
        }

        static ChunkSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ChunkSyntax), r => new ChunkSyntax(r));
        }
    }

    internal sealed partial class BlockSyntax : MoonScriptSyntaxNode
    {
        internal readonly GreenNode? statements;

        internal BlockSyntax(SyntaxKind kind, GreenNode? statements, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 1;
            if (statements != null)
            {
                this.AdjustFlagsAndWidth(statements);
                this.statements = statements;
            }
        }

        internal BlockSyntax(SyntaxKind kind, GreenNode? statements, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 1;
            if (statements != null)
            {
                this.AdjustFlagsAndWidth(statements);
                this.statements = statements;
            }
        }

        internal BlockSyntax(SyntaxKind kind, GreenNode? statements)
          : base(kind)
        {
            this.SlotCount = 1;
            if (statements != null)
            {
                this.AdjustFlagsAndWidth(statements);
                this.statements = statements;
            }
        }

        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<StatementSyntax> Statements => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<StatementSyntax>(this.statements);

        internal override GreenNode? GetSlot(int index)
            => index == 0 ? this.statements : null;

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.BlockSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitBlock(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitBlock(this);

        public BlockSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<StatementSyntax> statements)
        {
            if (statements != this.Statements)
            {
                var newNode = SyntaxFactory.Block(statements);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new BlockSyntax(this.Kind, this.statements, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new BlockSyntax(this.Kind, this.statements, GetDiagnostics(), annotations);

        internal BlockSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 1;
            var statements = (GreenNode?)reader.ReadValue();
            if (statements != null)
            {
                AdjustFlagsAndWidth(statements);
                this.statements = statements;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.statements);
        }

        static BlockSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(BlockSyntax), r => new BlockSyntax(r));
        }
    }

    internal sealed partial class SkippedTokensTriviaSyntax : StructuredTriviaSyntax
    {
        internal readonly GreenNode? tokens;

        internal SkippedTokensTriviaSyntax(SyntaxKind kind, GreenNode? tokens, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 1;
            if (tokens != null)
            {
                this.AdjustFlagsAndWidth(tokens);
                this.tokens = tokens;
            }
        }

        internal SkippedTokensTriviaSyntax(SyntaxKind kind, GreenNode? tokens, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 1;
            if (tokens != null)
            {
                this.AdjustFlagsAndWidth(tokens);
                this.tokens = tokens;
            }
        }

        internal SkippedTokensTriviaSyntax(SyntaxKind kind, GreenNode? tokens)
          : base(kind)
        {
            this.SlotCount = 1;
            if (tokens != null)
            {
                this.AdjustFlagsAndWidth(tokens);
                this.tokens = tokens;
            }
        }

        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Tokens => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.tokens);

        internal override GreenNode? GetSlot(int index)
            => index == 0 ? this.tokens : null;

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.SkippedTokensTriviaSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitSkippedTokensTrivia(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitSkippedTokensTrivia(this);

        public SkippedTokensTriviaSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> tokens)
        {
            if (tokens != this.Tokens)
            {
                var newNode = SyntaxFactory.SkippedTokensTrivia(tokens);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new SkippedTokensTriviaSyntax(this.Kind, this.tokens, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new SkippedTokensTriviaSyntax(this.Kind, this.tokens, GetDiagnostics(), annotations);

        internal SkippedTokensTriviaSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 1;
            var tokens = (GreenNode?)reader.ReadValue();
            if (tokens != null)
            {
                AdjustFlagsAndWidth(tokens);
                this.tokens = tokens;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.tokens);
        }

        static SkippedTokensTriviaSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(SkippedTokensTriviaSyntax), r => new SkippedTokensTriviaSyntax(r));
        }
    }

    /// <summary>Class which represents the syntax node for the list of expressions.</summary>
    internal sealed partial class ExpressionListSyntax : MoonScriptSyntaxNode
    {
        internal readonly GreenNode? expressions;

        internal ExpressionListSyntax(SyntaxKind kind, GreenNode? expressions, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 1;
            if (expressions != null)
            {
                this.AdjustFlagsAndWidth(expressions);
                this.expressions = expressions;
            }
        }

        internal ExpressionListSyntax(SyntaxKind kind, GreenNode? expressions, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 1;
            if (expressions != null)
            {
                this.AdjustFlagsAndWidth(expressions);
                this.expressions = expressions;
            }
        }

        internal ExpressionListSyntax(SyntaxKind kind, GreenNode? expressions)
          : base(kind)
        {
            this.SlotCount = 1;
            if (expressions != null)
            {
                this.AdjustFlagsAndWidth(expressions);
                this.expressions = expressions;
            }
        }

        /// <summary>SeparatedSyntaxList of ExpressionSyntax nodes representing the list of expressions.</summary>
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> Expressions => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MoonScriptSyntaxNode>(this.expressions));

        internal override GreenNode? GetSlot(int index)
            => index == 0 ? this.expressions : null;

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.ExpressionListSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitExpressionList(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitExpressionList(this);

        public ExpressionListSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> expressions)
        {
            if (expressions != this.Expressions)
            {
                var newNode = SyntaxFactory.ExpressionList(expressions);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ExpressionListSyntax(this.Kind, this.expressions, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ExpressionListSyntax(this.Kind, this.expressions, GetDiagnostics(), annotations);

        internal ExpressionListSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 1;
            var expressions = (GreenNode?)reader.ReadValue();
            if (expressions != null)
            {
                AdjustFlagsAndWidth(expressions);
                this.expressions = expressions;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.expressions);
        }

        static ExpressionListSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ExpressionListSyntax), r => new ExpressionListSyntax(r));
        }
    }

    /// <summary>Parameter list syntax.</summary>
    internal sealed partial class ParameterListSyntax : MoonScriptSyntaxNode
    {
        internal readonly SyntaxToken openParenToken;
        internal readonly GreenNode? parameters;
        internal readonly UsingClauseSyntax? @using;
        internal readonly SyntaxToken closeParenToken;

        internal ParameterListSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode? parameters, UsingClauseSyntax? @using, SyntaxToken closeParenToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            if (parameters != null)
            {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            if (@using != null)
            {
                this.AdjustFlagsAndWidth(@using);
                this.@using = @using;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal ParameterListSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode? parameters, UsingClauseSyntax? @using, SyntaxToken closeParenToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            if (parameters != null)
            {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            if (@using != null)
            {
                this.AdjustFlagsAndWidth(@using);
                this.@using = @using;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal ParameterListSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode? parameters, UsingClauseSyntax? @using, SyntaxToken closeParenToken)
          : base(kind)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            if (parameters != null)
            {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            if (@using != null)
            {
                this.AdjustFlagsAndWidth(@using);
                this.@using = @using;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        /// <summary>Gets the open paren token.</summary>
        public SyntaxToken OpenParenToken => this.openParenToken;
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ParameterSyntax> Parameters => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ParameterSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MoonScriptSyntaxNode>(this.parameters));
        public UsingClauseSyntax? Using => this.@using;
        /// <summary>Gets the close paren token.</summary>
        public SyntaxToken CloseParenToken => this.closeParenToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.openParenToken,
                1 => this.parameters,
                2 => this.@using,
                3 => this.closeParenToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.ParameterListSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitParameterList(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitParameterList(this);

        public ParameterListSyntax Update(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ParameterSyntax> parameters, UsingClauseSyntax @using, SyntaxToken closeParenToken)
        {
            if (openParenToken != this.OpenParenToken || parameters != this.Parameters || @using != this.Using || closeParenToken != this.CloseParenToken)
            {
                var newNode = SyntaxFactory.ParameterList(openParenToken, parameters, @using, closeParenToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ParameterListSyntax(this.Kind, this.openParenToken, this.parameters, this.@using, this.closeParenToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ParameterListSyntax(this.Kind, this.openParenToken, this.parameters, this.@using, this.closeParenToken, GetDiagnostics(), annotations);

        internal ParameterListSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var openParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            var parameters = (GreenNode?)reader.ReadValue();
            if (parameters != null)
            {
                AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            var @using = (UsingClauseSyntax?)reader.ReadValue();
            if (@using != null)
            {
                AdjustFlagsAndWidth(@using);
                this.@using = @using;
            }
            var closeParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.openParenToken);
            writer.WriteValue(this.parameters);
            writer.WriteValue(this.@using);
            writer.WriteValue(this.closeParenToken);
        }

        static ParameterListSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ParameterListSyntax), r => new ParameterListSyntax(r));
        }
    }

    /// <summary>Parameter syntax.</summary>
    internal sealed partial class ParameterSyntax : MoonScriptSyntaxNode
    {
        internal readonly SyntaxToken identifier;
        internal readonly SyntaxToken equalsToken;
        internal readonly ExpressionSyntax defaultValue;

        internal ParameterSyntax(SyntaxKind kind, SyntaxToken identifier, SyntaxToken equalsToken, ExpressionSyntax defaultValue, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            this.AdjustFlagsAndWidth(defaultValue);
            this.defaultValue = defaultValue;
        }

        internal ParameterSyntax(SyntaxKind kind, SyntaxToken identifier, SyntaxToken equalsToken, ExpressionSyntax defaultValue, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            this.AdjustFlagsAndWidth(defaultValue);
            this.defaultValue = defaultValue;
        }

        internal ParameterSyntax(SyntaxKind kind, SyntaxToken identifier, SyntaxToken equalsToken, ExpressionSyntax defaultValue)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            this.AdjustFlagsAndWidth(defaultValue);
            this.defaultValue = defaultValue;
        }

        /// <summary>Gets the identifier.</summary>
        public SyntaxToken Identifier => this.identifier;
        public SyntaxToken EqualsToken => this.equalsToken;
        public ExpressionSyntax DefaultValue => this.defaultValue;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.identifier,
                1 => this.equalsToken,
                2 => this.defaultValue,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.ParameterSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitParameter(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitParameter(this);

        public ParameterSyntax Update(SyntaxToken identifier, SyntaxToken equalsToken, ExpressionSyntax defaultValue)
        {
            if (identifier != this.Identifier || equalsToken != this.EqualsToken || defaultValue != this.DefaultValue)
            {
                var newNode = SyntaxFactory.Parameter(identifier, equalsToken, defaultValue);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ParameterSyntax(this.Kind, this.identifier, this.equalsToken, this.defaultValue, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ParameterSyntax(this.Kind, this.identifier, this.equalsToken, this.defaultValue, GetDiagnostics(), annotations);

        internal ParameterSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var identifier = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            var equalsToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            var defaultValue = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(defaultValue);
            this.defaultValue = defaultValue;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.identifier);
            writer.WriteValue(this.equalsToken);
            writer.WriteValue(this.defaultValue);
        }

        static ParameterSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ParameterSyntax), r => new ParameterSyntax(r));
        }
    }

    /// <summary>Class which represents the syntax node for the list of arguments.</summary>
    internal sealed partial class ArgumentListSyntax : MoonScriptSyntaxNode
    {
        internal readonly SyntaxToken? exclamationToken;
        internal readonly SyntaxToken? openParenToken;
        internal readonly GreenNode? arguments;
        internal readonly SyntaxToken? closeParenToken;

        internal ArgumentListSyntax(SyntaxKind kind, SyntaxToken? exclamationToken, SyntaxToken? openParenToken, GreenNode? arguments, SyntaxToken? closeParenToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            if (exclamationToken != null)
            {
                this.AdjustFlagsAndWidth(exclamationToken);
                this.exclamationToken = exclamationToken;
            }
            if (openParenToken != null)
            {
                this.AdjustFlagsAndWidth(openParenToken);
                this.openParenToken = openParenToken;
            }
            if (arguments != null)
            {
                this.AdjustFlagsAndWidth(arguments);
                this.arguments = arguments;
            }
            if (closeParenToken != null)
            {
                this.AdjustFlagsAndWidth(closeParenToken);
                this.closeParenToken = closeParenToken;
            }
        }

        internal ArgumentListSyntax(SyntaxKind kind, SyntaxToken? exclamationToken, SyntaxToken? openParenToken, GreenNode? arguments, SyntaxToken? closeParenToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 4;
            if (exclamationToken != null)
            {
                this.AdjustFlagsAndWidth(exclamationToken);
                this.exclamationToken = exclamationToken;
            }
            if (openParenToken != null)
            {
                this.AdjustFlagsAndWidth(openParenToken);
                this.openParenToken = openParenToken;
            }
            if (arguments != null)
            {
                this.AdjustFlagsAndWidth(arguments);
                this.arguments = arguments;
            }
            if (closeParenToken != null)
            {
                this.AdjustFlagsAndWidth(closeParenToken);
                this.closeParenToken = closeParenToken;
            }
        }

        internal ArgumentListSyntax(SyntaxKind kind, SyntaxToken? exclamationToken, SyntaxToken? openParenToken, GreenNode? arguments, SyntaxToken? closeParenToken)
          : base(kind)
        {
            this.SlotCount = 4;
            if (exclamationToken != null)
            {
                this.AdjustFlagsAndWidth(exclamationToken);
                this.exclamationToken = exclamationToken;
            }
            if (openParenToken != null)
            {
                this.AdjustFlagsAndWidth(openParenToken);
                this.openParenToken = openParenToken;
            }
            if (arguments != null)
            {
                this.AdjustFlagsAndWidth(arguments);
                this.arguments = arguments;
            }
            if (closeParenToken != null)
            {
                this.AdjustFlagsAndWidth(closeParenToken);
                this.closeParenToken = closeParenToken;
            }
        }

        public SyntaxToken? ExclamationToken => this.exclamationToken;
        /// <summary>SyntaxToken representing open parenthesis.</summary>
        public SyntaxToken? OpenParenToken => this.openParenToken;
        /// <summary>SeparatedSyntaxList of ArgumentSyntax representing the list of arguments.</summary>
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ArgumentSyntax> Arguments => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ArgumentSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MoonScriptSyntaxNode>(this.arguments));
        /// <summary>SyntaxToken representing close parenthesis.</summary>
        public SyntaxToken? CloseParenToken => this.closeParenToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.exclamationToken,
                1 => this.openParenToken,
                2 => this.arguments,
                3 => this.closeParenToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.ArgumentListSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitArgumentList(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitArgumentList(this);

        public ArgumentListSyntax Update(SyntaxToken exclamationToken, SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeParenToken)
        {
            if (exclamationToken != this.ExclamationToken || openParenToken != this.OpenParenToken || arguments != this.Arguments || closeParenToken != this.CloseParenToken)
            {
                var newNode = SyntaxFactory.ArgumentList(exclamationToken, openParenToken, arguments, closeParenToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ArgumentListSyntax(this.Kind, this.exclamationToken, this.openParenToken, this.arguments, this.closeParenToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ArgumentListSyntax(this.Kind, this.exclamationToken, this.openParenToken, this.arguments, this.closeParenToken, GetDiagnostics(), annotations);

        internal ArgumentListSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var exclamationToken = (SyntaxToken?)reader.ReadValue();
            if (exclamationToken != null)
            {
                AdjustFlagsAndWidth(exclamationToken);
                this.exclamationToken = exclamationToken;
            }
            var openParenToken = (SyntaxToken?)reader.ReadValue();
            if (openParenToken != null)
            {
                AdjustFlagsAndWidth(openParenToken);
                this.openParenToken = openParenToken;
            }
            var arguments = (GreenNode?)reader.ReadValue();
            if (arguments != null)
            {
                AdjustFlagsAndWidth(arguments);
                this.arguments = arguments;
            }
            var closeParenToken = (SyntaxToken?)reader.ReadValue();
            if (closeParenToken != null)
            {
                AdjustFlagsAndWidth(closeParenToken);
                this.closeParenToken = closeParenToken;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.exclamationToken);
            writer.WriteValue(this.openParenToken);
            writer.WriteValue(this.arguments);
            writer.WriteValue(this.closeParenToken);
        }

        static ArgumentListSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ArgumentListSyntax), r => new ArgumentListSyntax(r));
        }
    }

    /// <summary>Class which represents the syntax node for argument.</summary>
    internal sealed partial class ArgumentSyntax : MoonScriptSyntaxNode
    {
        internal readonly ExpressionSyntax expression;

        internal ArgumentSyntax(SyntaxKind kind, ExpressionSyntax expression, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        internal ArgumentSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        internal ArgumentSyntax(SyntaxKind kind, ExpressionSyntax expression)
          : base(kind)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        /// <summary>ExpressionSyntax node representing the argument.</summary>
        public ExpressionSyntax Expression => this.expression;

        internal override GreenNode? GetSlot(int index)
            => index == 0 ? this.expression : null;

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.ArgumentSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitArgument(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitArgument(this);

        public ArgumentSyntax Update(ExpressionSyntax expression)
        {
            if (expression != this.Expression)
            {
                var newNode = SyntaxFactory.Argument(expression);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ArgumentSyntax(this.Kind, this.expression, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ArgumentSyntax(this.Kind, this.expression, GetDiagnostics(), annotations);

        internal ArgumentSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 1;
            var expression = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.expression);
        }

        static ArgumentSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ArgumentSyntax), r => new ArgumentSyntax(r));
        }
    }

    internal sealed partial class NameColonSyntax : MoonScriptSyntaxNode
    {
        internal readonly IdentifierNameSyntax name;
        internal readonly SyntaxToken colonToken;

        internal NameColonSyntax(SyntaxKind kind, IdentifierNameSyntax name, SyntaxToken colonToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
        }

        internal NameColonSyntax(SyntaxKind kind, IdentifierNameSyntax name, SyntaxToken colonToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
        }

        internal NameColonSyntax(SyntaxKind kind, IdentifierNameSyntax name, SyntaxToken colonToken)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
        }

        public IdentifierNameSyntax Name => this.name;
        public SyntaxToken ColonToken => this.colonToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.name,
                1 => this.colonToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.NameColonSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitNameColon(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitNameColon(this);

        public NameColonSyntax Update(IdentifierNameSyntax name, SyntaxToken colonToken)
        {
            if (name != this.Name || colonToken != this.ColonToken)
            {
                var newNode = SyntaxFactory.NameColon(name, colonToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new NameColonSyntax(this.Kind, this.name, this.colonToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new NameColonSyntax(this.Kind, this.name, this.colonToken, GetDiagnostics(), annotations);

        internal NameColonSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var name = (IdentifierNameSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(name);
            this.name = name;
            var colonToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.name);
            writer.WriteValue(this.colonToken);
        }

        static NameColonSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(NameColonSyntax), r => new NameColonSyntax(r));
        }
    }

    internal sealed partial class ColonNameSyntax : MoonScriptSyntaxNode
    {
        internal readonly SyntaxToken colonToken;
        internal readonly IdentifierNameSyntax name;

        internal ColonNameSyntax(SyntaxKind kind, SyntaxToken colonToken, IdentifierNameSyntax name, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
        }

        internal ColonNameSyntax(SyntaxKind kind, SyntaxToken colonToken, IdentifierNameSyntax name, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
        }

        internal ColonNameSyntax(SyntaxKind kind, SyntaxToken colonToken, IdentifierNameSyntax name)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
        }

        public SyntaxToken ColonToken => this.colonToken;
        public IdentifierNameSyntax Name => this.name;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.colonToken,
                1 => this.name,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.ColonNameSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitColonName(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitColonName(this);

        public ColonNameSyntax Update(SyntaxToken colonToken, IdentifierNameSyntax name)
        {
            if (colonToken != this.ColonToken || name != this.Name)
            {
                var newNode = SyntaxFactory.ColonName(colonToken, name);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ColonNameSyntax(this.Kind, this.colonToken, this.name, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ColonNameSyntax(this.Kind, this.colonToken, this.name, GetDiagnostics(), annotations);

        internal ColonNameSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var colonToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            var name = (IdentifierNameSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(name);
            this.name = name;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.colonToken);
            writer.WriteValue(this.name);
        }

        static ColonNameSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ColonNameSyntax), r => new ColonNameSyntax(r));
        }
    }

    internal sealed partial class BackSlashNameSyntax : MoonScriptSyntaxNode
    {
        internal readonly SyntaxToken backSlashToken;
        internal readonly IdentifierNameSyntax name;

        internal BackSlashNameSyntax(SyntaxKind kind, SyntaxToken backSlashToken, IdentifierNameSyntax name, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(backSlashToken);
            this.backSlashToken = backSlashToken;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
        }

        internal BackSlashNameSyntax(SyntaxKind kind, SyntaxToken backSlashToken, IdentifierNameSyntax name, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(backSlashToken);
            this.backSlashToken = backSlashToken;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
        }

        internal BackSlashNameSyntax(SyntaxKind kind, SyntaxToken backSlashToken, IdentifierNameSyntax name)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(backSlashToken);
            this.backSlashToken = backSlashToken;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
        }

        public SyntaxToken BackSlashToken => this.backSlashToken;
        public IdentifierNameSyntax Name => this.name;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.backSlashToken,
                1 => this.name,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.BackSlashNameSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitBackSlashName(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitBackSlashName(this);

        public BackSlashNameSyntax Update(SyntaxToken backSlashToken, IdentifierNameSyntax name)
        {
            if (backSlashToken != this.BackSlashToken || name != this.Name)
            {
                var newNode = SyntaxFactory.BackSlashName(backSlashToken, name);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new BackSlashNameSyntax(this.Kind, this.backSlashToken, this.name, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new BackSlashNameSyntax(this.Kind, this.backSlashToken, this.name, GetDiagnostics(), annotations);

        internal BackSlashNameSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var backSlashToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(backSlashToken);
            this.backSlashToken = backSlashToken;
            var name = (IdentifierNameSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(name);
            this.name = name;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.backSlashToken);
            writer.WriteValue(this.name);
        }

        static BackSlashNameSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(BackSlashNameSyntax), r => new BackSlashNameSyntax(r));
        }
    }

    internal sealed partial class ImplicitSelfCallSyntax : MoonScriptSyntaxNode
    {
        internal readonly ExpressionSyntax expression;
        internal readonly BackSlashNameSyntax backSlashName;

        internal ImplicitSelfCallSyntax(SyntaxKind kind, ExpressionSyntax expression, BackSlashNameSyntax backSlashName, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(backSlashName);
            this.backSlashName = backSlashName;
        }

        internal ImplicitSelfCallSyntax(SyntaxKind kind, ExpressionSyntax expression, BackSlashNameSyntax backSlashName, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(backSlashName);
            this.backSlashName = backSlashName;
        }

        internal ImplicitSelfCallSyntax(SyntaxKind kind, ExpressionSyntax expression, BackSlashNameSyntax backSlashName)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(backSlashName);
            this.backSlashName = backSlashName;
        }

        /// <summary>ExpressionSyntax node representing the expression part of the implicit self call.</summary>
        public ExpressionSyntax Expression => this.expression;
        /// <summary>IdentifierNameSyntax representing the identifier name.</summary>
        public BackSlashNameSyntax BackSlashName => this.backSlashName;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.expression,
                1 => this.backSlashName,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.ImplicitSelfCallSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitImplicitSelfCall(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitImplicitSelfCall(this);

        public ImplicitSelfCallSyntax Update(ExpressionSyntax expression, BackSlashNameSyntax backSlashName)
        {
            if (expression != this.Expression || backSlashName != this.BackSlashName)
            {
                var newNode = SyntaxFactory.ImplicitSelfCall(expression, backSlashName);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ImplicitSelfCallSyntax(this.Kind, this.expression, this.backSlashName, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ImplicitSelfCallSyntax(this.Kind, this.expression, this.backSlashName, GetDiagnostics(), annotations);

        internal ImplicitSelfCallSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var expression = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(expression);
            this.expression = expression;
            var backSlashName = (BackSlashNameSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(backSlashName);
            this.backSlashName = backSlashName;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.expression);
            writer.WriteValue(this.backSlashName);
        }

        static ImplicitSelfCallSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ImplicitSelfCallSyntax), r => new ImplicitSelfCallSyntax(r));
        }
    }

    internal sealed partial class ImportNameSyntax : MoonScriptSyntaxNode
    {
        internal readonly SyntaxToken? backSlashToken;
        internal readonly IdentifierNameSyntax name;

        internal ImportNameSyntax(SyntaxKind kind, SyntaxToken? backSlashToken, IdentifierNameSyntax name, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            if (backSlashToken != null)
            {
                this.AdjustFlagsAndWidth(backSlashToken);
                this.backSlashToken = backSlashToken;
            }
            this.AdjustFlagsAndWidth(name);
            this.name = name;
        }

        internal ImportNameSyntax(SyntaxKind kind, SyntaxToken? backSlashToken, IdentifierNameSyntax name, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            if (backSlashToken != null)
            {
                this.AdjustFlagsAndWidth(backSlashToken);
                this.backSlashToken = backSlashToken;
            }
            this.AdjustFlagsAndWidth(name);
            this.name = name;
        }

        internal ImportNameSyntax(SyntaxKind kind, SyntaxToken? backSlashToken, IdentifierNameSyntax name)
          : base(kind)
        {
            this.SlotCount = 2;
            if (backSlashToken != null)
            {
                this.AdjustFlagsAndWidth(backSlashToken);
                this.backSlashToken = backSlashToken;
            }
            this.AdjustFlagsAndWidth(name);
            this.name = name;
        }

        public SyntaxToken? BackSlashToken => this.backSlashToken;
        public IdentifierNameSyntax Name => this.name;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.backSlashToken,
                1 => this.name,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.ImportNameSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitImportName(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitImportName(this);

        public ImportNameSyntax Update(SyntaxToken backSlashToken, IdentifierNameSyntax name)
        {
            if (backSlashToken != this.BackSlashToken || name != this.Name)
            {
                var newNode = SyntaxFactory.ImportName(backSlashToken, name);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ImportNameSyntax(this.Kind, this.backSlashToken, this.name, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ImportNameSyntax(this.Kind, this.backSlashToken, this.name, GetDiagnostics(), annotations);

        internal ImportNameSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var backSlashToken = (SyntaxToken?)reader.ReadValue();
            if (backSlashToken != null)
            {
                AdjustFlagsAndWidth(backSlashToken);
                this.backSlashToken = backSlashToken;
            }
            var name = (IdentifierNameSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(name);
            this.name = name;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.backSlashToken);
            writer.WriteValue(this.name);
        }

        static ImportNameSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ImportNameSyntax), r => new ImportNameSyntax(r));
        }
    }

    internal partial class MoonScriptSyntaxVisitor<TResult>
    {
        public virtual TResult VisitIdentifierName(IdentifierNameSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitLiteralExpression(LiteralExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitSelfExpression(SelfExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitSuperExpression(SuperExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitTypeExpression(TypeExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitParenthesizedExpression(ParenthesizedExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitClassExpression(ClassExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitAnomymousClassExpression(AnomymousClassExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitDoExpression(DoExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitForExpression(ForExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitForInExpression(ForInExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitIfExpression(IfExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitElseIfClause(ElseIfClauseSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitElseClause(ElseClauseSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitSwitchExpression(SwitchExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitWhenClause(WhenClauseSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitUnlessExpression(UnlessExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitWhileExpression(WhileExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitWithExpression(WithExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitListComprehensionExpression(ListComprehensionExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitTableComprehensionExpression(TableComprehensionExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitForComprehensionClause(ForComprehensionClauseSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitForInComprehensionClause(ForInComprehensionClauseSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitWhenComprehensionClause(WhenComprehensionClauseSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitNumericallyIterateExpression(NumericallyIterateExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitSlicingExpression(SlicingExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitInvocationExpression(InvocationExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitLambdaExpression(LambdaExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitBinaryExpression(BinaryExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitUnaryExpression(UnaryExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitSimpleAssignmentExpression(SimpleAssignmentExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitUpdateAssignmentExpression(UpdateAssignmentExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitExpressionStatement(ExpressionStatementSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitBreakStatement(BreakStatementSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitClassStatement(ClassStatementSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitMemberStatement(MemberStatementSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitContinueStatement(ContinueStatementSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitDoStatement(DoStatementSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitExportStatement(ExportStatementSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitForStatement(ForStatementSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitForInStatement(ForInStatementSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitIfStatement(IfStatementSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitImportStatementSytnax(ImportStatementSytnax node) => this.DefaultVisit(node);
        public virtual TResult VisitLocalStatement(LocalStatementSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitSwitchStatement(SwitchStatementSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitUnlessStatement(UnlessStatementSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitUsingClause(UsingClauseSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitWhileStatement(WhileStatementSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitWithStatement(WithStatementSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitDestructuringAssignmentStatement(DestructuringAssignmentStatementSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitDestructuringIdentifierName(DestructuringIdentifierNameSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitDestructuringList(DestructuringListSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitDestructuringField(DestructuringFieldSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitDestructuringTable(DestructuringTableSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitForLineDecorator(ForLineDecoratorSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitForInLineDecorator(ForInLineDecoratorSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitIfLineDecorator(IfLineDecoratorSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitUnlessLineDecorator(UnlessLineDecoratorSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitWhileLineDecorator(WhileLineDecoratorSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitChunk(ChunkSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitBlock(BlockSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitSkippedTokensTrivia(SkippedTokensTriviaSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitExpressionList(ExpressionListSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitParameterList(ParameterListSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitParameter(ParameterSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitArgumentList(ArgumentListSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitArgument(ArgumentSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitNameColon(NameColonSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitColonName(ColonNameSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitBackSlashName(BackSlashNameSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitImplicitSelfCall(ImplicitSelfCallSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitImportName(ImportNameSyntax node) => this.DefaultVisit(node);
    }

    internal partial class MoonScriptSyntaxVisitor
    {
        public virtual void VisitIdentifierName(IdentifierNameSyntax node) => this.DefaultVisit(node);
        public virtual void VisitLiteralExpression(LiteralExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitSelfExpression(SelfExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitSuperExpression(SuperExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitTypeExpression(TypeExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitParenthesizedExpression(ParenthesizedExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitClassExpression(ClassExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitAnomymousClassExpression(AnomymousClassExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitDoExpression(DoExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitForExpression(ForExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitForInExpression(ForInExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitIfExpression(IfExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitElseIfClause(ElseIfClauseSyntax node) => this.DefaultVisit(node);
        public virtual void VisitElseClause(ElseClauseSyntax node) => this.DefaultVisit(node);
        public virtual void VisitSwitchExpression(SwitchExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitWhenClause(WhenClauseSyntax node) => this.DefaultVisit(node);
        public virtual void VisitUnlessExpression(UnlessExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitWhileExpression(WhileExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitWithExpression(WithExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitListComprehensionExpression(ListComprehensionExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitTableComprehensionExpression(TableComprehensionExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitForComprehensionClause(ForComprehensionClauseSyntax node) => this.DefaultVisit(node);
        public virtual void VisitForInComprehensionClause(ForInComprehensionClauseSyntax node) => this.DefaultVisit(node);
        public virtual void VisitWhenComprehensionClause(WhenComprehensionClauseSyntax node) => this.DefaultVisit(node);
        public virtual void VisitNumericallyIterateExpression(NumericallyIterateExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitSlicingExpression(SlicingExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitInvocationExpression(InvocationExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitLambdaExpression(LambdaExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitBinaryExpression(BinaryExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitUnaryExpression(UnaryExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitSimpleAssignmentExpression(SimpleAssignmentExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitUpdateAssignmentExpression(UpdateAssignmentExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitExpressionStatement(ExpressionStatementSyntax node) => this.DefaultVisit(node);
        public virtual void VisitBreakStatement(BreakStatementSyntax node) => this.DefaultVisit(node);
        public virtual void VisitClassStatement(ClassStatementSyntax node) => this.DefaultVisit(node);
        public virtual void VisitMemberStatement(MemberStatementSyntax node) => this.DefaultVisit(node);
        public virtual void VisitContinueStatement(ContinueStatementSyntax node) => this.DefaultVisit(node);
        public virtual void VisitDoStatement(DoStatementSyntax node) => this.DefaultVisit(node);
        public virtual void VisitExportStatement(ExportStatementSyntax node) => this.DefaultVisit(node);
        public virtual void VisitForStatement(ForStatementSyntax node) => this.DefaultVisit(node);
        public virtual void VisitForInStatement(ForInStatementSyntax node) => this.DefaultVisit(node);
        public virtual void VisitIfStatement(IfStatementSyntax node) => this.DefaultVisit(node);
        public virtual void VisitImportStatementSytnax(ImportStatementSytnax node) => this.DefaultVisit(node);
        public virtual void VisitLocalStatement(LocalStatementSyntax node) => this.DefaultVisit(node);
        public virtual void VisitSwitchStatement(SwitchStatementSyntax node) => this.DefaultVisit(node);
        public virtual void VisitUnlessStatement(UnlessStatementSyntax node) => this.DefaultVisit(node);
        public virtual void VisitUsingClause(UsingClauseSyntax node) => this.DefaultVisit(node);
        public virtual void VisitWhileStatement(WhileStatementSyntax node) => this.DefaultVisit(node);
        public virtual void VisitWithStatement(WithStatementSyntax node) => this.DefaultVisit(node);
        public virtual void VisitDestructuringAssignmentStatement(DestructuringAssignmentStatementSyntax node) => this.DefaultVisit(node);
        public virtual void VisitDestructuringIdentifierName(DestructuringIdentifierNameSyntax node) => this.DefaultVisit(node);
        public virtual void VisitDestructuringList(DestructuringListSyntax node) => this.DefaultVisit(node);
        public virtual void VisitDestructuringField(DestructuringFieldSyntax node) => this.DefaultVisit(node);
        public virtual void VisitDestructuringTable(DestructuringTableSyntax node) => this.DefaultVisit(node);
        public virtual void VisitForLineDecorator(ForLineDecoratorSyntax node) => this.DefaultVisit(node);
        public virtual void VisitForInLineDecorator(ForInLineDecoratorSyntax node) => this.DefaultVisit(node);
        public virtual void VisitIfLineDecorator(IfLineDecoratorSyntax node) => this.DefaultVisit(node);
        public virtual void VisitUnlessLineDecorator(UnlessLineDecoratorSyntax node) => this.DefaultVisit(node);
        public virtual void VisitWhileLineDecorator(WhileLineDecoratorSyntax node) => this.DefaultVisit(node);
        public virtual void VisitChunk(ChunkSyntax node) => this.DefaultVisit(node);
        public virtual void VisitBlock(BlockSyntax node) => this.DefaultVisit(node);
        public virtual void VisitSkippedTokensTrivia(SkippedTokensTriviaSyntax node) => this.DefaultVisit(node);
        public virtual void VisitExpressionList(ExpressionListSyntax node) => this.DefaultVisit(node);
        public virtual void VisitParameterList(ParameterListSyntax node) => this.DefaultVisit(node);
        public virtual void VisitParameter(ParameterSyntax node) => this.DefaultVisit(node);
        public virtual void VisitArgumentList(ArgumentListSyntax node) => this.DefaultVisit(node);
        public virtual void VisitArgument(ArgumentSyntax node) => this.DefaultVisit(node);
        public virtual void VisitNameColon(NameColonSyntax node) => this.DefaultVisit(node);
        public virtual void VisitColonName(ColonNameSyntax node) => this.DefaultVisit(node);
        public virtual void VisitBackSlashName(BackSlashNameSyntax node) => this.DefaultVisit(node);
        public virtual void VisitImplicitSelfCall(ImplicitSelfCallSyntax node) => this.DefaultVisit(node);
        public virtual void VisitImportName(ImportNameSyntax node) => this.DefaultVisit(node);
    }

    internal partial class MoonScriptSyntaxRewriter : MoonScriptSyntaxVisitor<MoonScriptSyntaxNode>
    {
        public override MoonScriptSyntaxNode VisitIdentifierName(IdentifierNameSyntax node)
            => node.Update((SyntaxToken)Visit(node.Identifier));

        public override MoonScriptSyntaxNode VisitLiteralExpression(LiteralExpressionSyntax node)
            => node.Update((SyntaxToken)Visit(node.Token));

        public override MoonScriptSyntaxNode VisitSelfExpression(SelfExpressionSyntax node)
            => node.Update((SyntaxToken)Visit(node.Token));

        public override MoonScriptSyntaxNode VisitSuperExpression(SuperExpressionSyntax node)
            => node.Update((SyntaxToken)Visit(node.Token));

        public override MoonScriptSyntaxNode VisitTypeExpression(TypeExpressionSyntax node)
            => node.Update((SyntaxToken)Visit(node.Token));

        public override MoonScriptSyntaxNode VisitParenthesizedExpression(ParenthesizedExpressionSyntax node)
            => node.Update((SyntaxToken)Visit(node.OpenParenToken), (ExpressionSyntax)Visit(node.Expression), (SyntaxToken)Visit(node.CloseParenToken));

        public override MoonScriptSyntaxNode VisitClassExpression(ClassExpressionSyntax node)
            => node.Update((SyntaxToken)Visit(node.ClassKeyword), (IdentifierNameSyntax)Visit(node.Name), (SyntaxToken)Visit(node.ExtendsKeyword), (IdentifierNameSyntax)Visit(node.BaseName), VisitList(node.Statements));

        public override MoonScriptSyntaxNode VisitAnomymousClassExpression(AnomymousClassExpressionSyntax node)
            => node.Update((SyntaxToken)Visit(node.ClassKeyword), (SyntaxToken)Visit(node.ExtendsKeyword), (IdentifierNameSyntax)Visit(node.BaseName), VisitList(node.Statements));

        public override MoonScriptSyntaxNode VisitDoExpression(DoExpressionSyntax node)
            => node.Update((SyntaxToken)Visit(node.DoKeyword), (BlockSyntax)Visit(node.Block));

        public override MoonScriptSyntaxNode VisitForExpression(ForExpressionSyntax node)
            => node.Update((SyntaxToken)Visit(node.ForKeyword), (IdentifierNameSyntax)Visit(node.Name), (SyntaxToken)Visit(node.EqualsToken), (ExpressionSyntax)Visit(node.Initial), (SyntaxToken)Visit(node.FirstCommaToken), (ExpressionSyntax)Visit(node.Limit), (SyntaxToken)Visit(node.SecondCommaToken), (ExpressionSyntax)Visit(node.Step), (SyntaxToken)Visit(node.DoKeyword), (BlockSyntax)Visit(node.Block));

        public override MoonScriptSyntaxNode VisitForInExpression(ForInExpressionSyntax node)
            => node.Update((SyntaxToken)Visit(node.ForKeyword), VisitList(node.Names), (SyntaxToken)Visit(node.InKeyword), (ExpressionSyntax)Visit(node.Iteration), (SyntaxToken)Visit(node.DoKeyword), (BlockSyntax)Visit(node.Block));

        public override MoonScriptSyntaxNode VisitIfExpression(IfExpressionSyntax node)
            => node.Update((SyntaxToken)Visit(node.IfKeyword), (ExpressionSyntax)Visit(node.Condition), (SyntaxToken)Visit(node.ThenKeyword), (BlockSyntax)Visit(node.Block), VisitList(node.ElseIfs), (ElseClauseSyntax)Visit(node.Else));

        public override MoonScriptSyntaxNode VisitElseIfClause(ElseIfClauseSyntax node)
            => node.Update((SyntaxToken)Visit(node.ElseIfKeyword), (ExpressionSyntax)Visit(node.Condition), (SyntaxToken)Visit(node.ThenKeyword), (BlockSyntax)Visit(node.Block));

        public override MoonScriptSyntaxNode VisitElseClause(ElseClauseSyntax node)
            => node.Update((SyntaxToken)Visit(node.ElseKeyword), (BlockSyntax)Visit(node.Block));

        public override MoonScriptSyntaxNode VisitSwitchExpression(SwitchExpressionSyntax node)
            => node.Update((ExpressionSyntax)Visit(node.Expression), VisitList(node.Whens), (ElseClauseSyntax)Visit(node.Else));

        public override MoonScriptSyntaxNode VisitWhenClause(WhenClauseSyntax node)
            => node.Update((SyntaxToken)Visit(node.WhenKeyword), (ExpressionListSyntax)Visit(node.Values), (SyntaxToken)Visit(node.ThenKeyword), (BlockSyntax)Visit(node.Block));

        public override MoonScriptSyntaxNode VisitUnlessExpression(UnlessExpressionSyntax node)
            => node.Update((SyntaxToken)Visit(node.UnlessKeyword), (ExpressionSyntax)Visit(node.Condition), (SyntaxToken)Visit(node.ThenKeyword), (BlockSyntax)Visit(node.Block));

        public override MoonScriptSyntaxNode VisitWhileExpression(WhileExpressionSyntax node)
            => node.Update((SyntaxToken)Visit(node.WhileKeyword), (ExpressionSyntax)Visit(node.Condition), (SyntaxToken)Visit(node.DoKeyword), (BlockSyntax)Visit(node.Block));

        public override MoonScriptSyntaxNode VisitWithExpression(WithExpressionSyntax node)
            => node.Update((SyntaxToken)Visit(node.WithKeyword), (ExpressionSyntax)Visit(node.Expression), (BlockSyntax)Visit(node.Block));

        public override MoonScriptSyntaxNode VisitListComprehensionExpression(ListComprehensionExpressionSyntax node)
            => node.Update((SyntaxToken)Visit(node.OpenBracketToken), (ExpressionSyntax)Visit(node.Expression), (BaseComprehensionClauseSyntax)Visit(node.FirstClause), VisitList(node.RestClauses), (SyntaxToken)Visit(node.CloseBracketToken));

        public override MoonScriptSyntaxNode VisitTableComprehensionExpression(TableComprehensionExpressionSyntax node)
            => node.Update((SyntaxToken)Visit(node.OpenBraceToken), (ExpressionSyntax)Visit(node.Expression), (BaseComprehensionClauseSyntax)Visit(node.FirstClause), VisitList(node.RestClauses), (SyntaxToken)Visit(node.CloseBraceToken));

        public override MoonScriptSyntaxNode VisitForComprehensionClause(ForComprehensionClauseSyntax node)
            => node.Update((SyntaxToken)Visit(node.ForKeyword), (IdentifierNameSyntax)Visit(node.Name), (SyntaxToken)Visit(node.EqualsToken), (ExpressionSyntax)Visit(node.Initial), (SyntaxToken)Visit(node.FirstCommaToken), (ExpressionSyntax)Visit(node.Limit), (SyntaxToken)Visit(node.SecondCommaToken), (ExpressionSyntax)Visit(node.Step));

        public override MoonScriptSyntaxNode VisitForInComprehensionClause(ForInComprehensionClauseSyntax node)
            => node.Update((SyntaxToken)Visit(node.ForKeyword), VisitList(node.Names), (SyntaxToken)Visit(node.InKeyword), (ExpressionSyntax)Visit(node.Iteration));

        public override MoonScriptSyntaxNode VisitWhenComprehensionClause(WhenComprehensionClauseSyntax node)
            => node.Update((SyntaxToken)Visit(node.WhenKeyword), (ExpressionSyntax)Visit(node.Condition));

        public override MoonScriptSyntaxNode VisitNumericallyIterateExpression(NumericallyIterateExpressionSyntax node)
            => node.Update((SyntaxToken)Visit(node.AsteriskToken), (ExpressionSyntax)Visit(node.Expression));

        public override MoonScriptSyntaxNode VisitSlicingExpression(SlicingExpressionSyntax node)
            => node.Update((ExpressionSyntax)Visit(node.NumericallyIterateExpression), (SyntaxToken)Visit(node.OpenBracketToken), (ExpressionSyntax)Visit(node.Initial), (SyntaxToken)Visit(node.FirstCommaToken), (ExpressionSyntax)Visit(node.Limit), (SyntaxToken)Visit(node.SecondCommaToken), (ExpressionSyntax)Visit(node.Step), (SyntaxToken)Visit(node.CloseBracketToken));

        public override MoonScriptSyntaxNode VisitInvocationExpression(InvocationExpressionSyntax node)
            => node.Update((ExpressionSyntax)Visit(node.Expression), (ImplicitSelfCallSyntax)Visit(node.SelfCall), (ArgumentListSyntax)Visit(node.ArgumentList));

        public override MoonScriptSyntaxNode VisitLambdaExpression(LambdaExpressionSyntax node)
            => node.Update((ParameterListSyntax)Visit(node.Parameters), (SyntaxToken)Visit(node.Arrow), (BlockSyntax)Visit(node.Block));

        public override MoonScriptSyntaxNode VisitBinaryExpression(BinaryExpressionSyntax node)
            => node.Update((ExpressionSyntax)Visit(node.Left), (SyntaxToken)Visit(node.OperatorToken), (ExpressionSyntax)Visit(node.Right));

        public override MoonScriptSyntaxNode VisitUnaryExpression(UnaryExpressionSyntax node)
            => node.Update((SyntaxToken)Visit(node.OperatorToken), (ExpressionSyntax)Visit(node.Operand));

        public override MoonScriptSyntaxNode VisitSimpleAssignmentExpression(SimpleAssignmentExpressionSyntax node)
            => node.Update((ExpressionListSyntax)Visit(node.Left), (SyntaxToken)Visit(node.EqualsToken), (ExpressionListSyntax)Visit(node.Right));

        public override MoonScriptSyntaxNode VisitUpdateAssignmentExpression(UpdateAssignmentExpressionSyntax node)
            => node.Update((ExpressionSyntax)Visit(node.Left), (SyntaxToken)Visit(node.OperatorToken), (ExpressionListSyntax)Visit(node.Right));

        public override MoonScriptSyntaxNode VisitExpressionStatement(ExpressionStatementSyntax node)
            => node.Update((ExpressionSyntax)Visit(node.Expression), (LineDecoratorSyntax)Visit(node.LineDecorator));

        public override MoonScriptSyntaxNode VisitBreakStatement(BreakStatementSyntax node)
            => node.Update((SyntaxToken)Visit(node.BreakKeyword), (ConditionalLineDecoratorSyntax)Visit(node.LineDecorator));

        public override MoonScriptSyntaxNode VisitClassStatement(ClassStatementSyntax node)
            => node.Update((SyntaxToken)Visit(node.ClassKeyword), (IdentifierNameSyntax)Visit(node.Name), (SyntaxToken)Visit(node.ExtendsKeyword), (IdentifierNameSyntax)Visit(node.BaseName), VisitList(node.Statements));

        public override MoonScriptSyntaxNode VisitMemberStatement(MemberStatementSyntax node)
            => node.Update((SyntaxToken)Visit(node.CommercialAtToken), (NameColonSyntax)Visit(node.NameColon), (ExpressionSyntax)Visit(node.Expression));

        public override MoonScriptSyntaxNode VisitContinueStatement(ContinueStatementSyntax node)
            => node.Update((SyntaxToken)Visit(node.BreakKeyword), (ConditionalLineDecoratorSyntax)Visit(node.LineDecorator));

        public override MoonScriptSyntaxNode VisitDoStatement(DoStatementSyntax node)
            => node.Update((SyntaxToken)Visit(node.DoKeyword), (BlockSyntax)Visit(node.Block));

        public override MoonScriptSyntaxNode VisitExportStatement(ExportStatementSyntax node)
            => node.Update((SyntaxToken)Visit(node.ExportKeyword), VisitList(node.Names), (SimpleAssignmentExpressionSyntax)Visit(node.SimpleAssignmentExpression), (SyntaxToken)Visit(node.AsteriskToken), (SyntaxToken)Visit(node.CaretToken));

        public override MoonScriptSyntaxNode VisitForStatement(ForStatementSyntax node)
            => node.Update((SyntaxToken)Visit(node.ForKeyword), (IdentifierNameSyntax)Visit(node.Name), (SyntaxToken)Visit(node.EqualsToken), (ExpressionSyntax)Visit(node.Initial), (SyntaxToken)Visit(node.FirstCommaToken), (ExpressionSyntax)Visit(node.Limit), (SyntaxToken)Visit(node.SecondCommaToken), (ExpressionSyntax)Visit(node.Step), (SyntaxToken)Visit(node.DoKeyword), (BlockSyntax)Visit(node.Block));

        public override MoonScriptSyntaxNode VisitForInStatement(ForInStatementSyntax node)
            => node.Update((SyntaxToken)Visit(node.ForKeyword), VisitList(node.Names), (SyntaxToken)Visit(node.InKeyword), (ExpressionSyntax)Visit(node.Iteration), (SyntaxToken)Visit(node.DoKeyword), (BlockSyntax)Visit(node.Block));

        public override MoonScriptSyntaxNode VisitIfStatement(IfStatementSyntax node)
            => node.Update((ExpressionSyntax)Visit(node.Condition), (SyntaxToken)Visit(node.ThenKeyword), (BlockSyntax)Visit(node.Block), VisitList(node.ElseIfs), (ElseClauseSyntax)Visit(node.Else));

        public override MoonScriptSyntaxNode VisitImportStatementSytnax(ImportStatementSytnax node)
            => node.Update((SyntaxToken)Visit(node.ImportKeyword), VisitList(node.Names), (SyntaxToken)Visit(node.FromKeyword), (IdentifierNameSyntax)Visit(node.From));

        public override MoonScriptSyntaxNode VisitLocalStatement(LocalStatementSyntax node)
            => node.Update((SyntaxToken)Visit(node.LocalKeyword), VisitList(node.Names), (SimpleAssignmentExpressionSyntax)Visit(node.SimpleAssignmentExpression), (SyntaxToken)Visit(node.AsteriskToken));

        public override MoonScriptSyntaxNode VisitSwitchStatement(SwitchStatementSyntax node)
            => node.Update((ExpressionSyntax)Visit(node.Expression), VisitList(node.Whens), (ElseClauseSyntax)Visit(node.Else));

        public override MoonScriptSyntaxNode VisitUnlessStatement(UnlessStatementSyntax node)
            => node.Update((SyntaxToken)Visit(node.UnlessKeyword), (ExpressionSyntax)Visit(node.Condition), (SyntaxToken)Visit(node.ThenKeyword), (BlockSyntax)Visit(node.Block));

        public override MoonScriptSyntaxNode VisitUsingClause(UsingClauseSyntax node)
            => node.Update((SyntaxToken)Visit(node.UsingKeyword), (SyntaxToken)Visit(node.NilKeyword), VisitList(node.Names));

        public override MoonScriptSyntaxNode VisitWhileStatement(WhileStatementSyntax node)
            => node.Update((SyntaxToken)Visit(node.WhileKeyword), (ExpressionSyntax)Visit(node.Condition), (SyntaxToken)Visit(node.DoKeyword), (BlockSyntax)Visit(node.Block));

        public override MoonScriptSyntaxNode VisitWithStatement(WithStatementSyntax node)
            => node.Update((SyntaxToken)Visit(node.WithKeyword), (ExpressionSyntax)Visit(node.Expression), (BlockSyntax)Visit(node.Block));

        public override MoonScriptSyntaxNode VisitDestructuringAssignmentStatement(DestructuringAssignmentStatementSyntax node)
            => node.Update((DestructuringUnitSyntax)Visit(node.Unit), (SyntaxToken)Visit(node.EqualsToken), (ExpressionSyntax)Visit(node.Expression));

        public override MoonScriptSyntaxNode VisitDestructuringIdentifierName(DestructuringIdentifierNameSyntax node)
            => node.Update((IdentifierNameSyntax)Visit(node.Name));

        public override MoonScriptSyntaxNode VisitDestructuringList(DestructuringListSyntax node)
            => node.Update(VisitList(node.Units));

        public override MoonScriptSyntaxNode VisitDestructuringField(DestructuringFieldSyntax node)
            => node.Update((DestructuringUnitSyntax)Visit(node.Unit), (NameColonSyntax)Visit(node.NameColon), (DestructuringUnitSyntax)Visit(node.NamedUnit), (ColonNameSyntax)Visit(node.ColonName));

        public override MoonScriptSyntaxNode VisitDestructuringTable(DestructuringTableSyntax node)
            => node.Update((SyntaxToken)Visit(node.OpenBraceToken), VisitList(node.Fields), (SyntaxToken)Visit(node.CloseBraceToken));

        public override MoonScriptSyntaxNode VisitForLineDecorator(ForLineDecoratorSyntax node)
            => node.Update((SyntaxToken)Visit(node.ForKeyword), (IdentifierNameSyntax)Visit(node.Name), (SyntaxToken)Visit(node.EqualsToken), (ExpressionSyntax)Visit(node.Initial), (SyntaxToken)Visit(node.FirstCommaToken), (ExpressionSyntax)Visit(node.Limit), (SyntaxToken)Visit(node.SecondCommaToken), (ExpressionSyntax)Visit(node.Step));

        public override MoonScriptSyntaxNode VisitForInLineDecorator(ForInLineDecoratorSyntax node)
            => node.Update((SyntaxToken)Visit(node.ForKeyword), VisitList(node.Names), (SyntaxToken)Visit(node.InKeyword), (ExpressionSyntax)Visit(node.Iteration));

        public override MoonScriptSyntaxNode VisitIfLineDecorator(IfLineDecoratorSyntax node)
            => node.Update((SyntaxToken)Visit(node.IfKeyword), (ExpressionSyntax)Visit(node.Condition));

        public override MoonScriptSyntaxNode VisitUnlessLineDecorator(UnlessLineDecoratorSyntax node)
            => node.Update((SyntaxToken)Visit(node.UnlessKeyword), (ExpressionSyntax)Visit(node.Condition));

        public override MoonScriptSyntaxNode VisitWhileLineDecorator(WhileLineDecoratorSyntax node)
            => node.Update((SyntaxToken)Visit(node.WhileKeyword), (ExpressionSyntax)Visit(node.Condition));

        public override MoonScriptSyntaxNode VisitChunk(ChunkSyntax node)
            => node.Update((BlockSyntax)Visit(node.Block), (SyntaxToken)Visit(node.EndOfFileToken));

        public override MoonScriptSyntaxNode VisitBlock(BlockSyntax node)
            => node.Update(VisitList(node.Statements));

        public override MoonScriptSyntaxNode VisitSkippedTokensTrivia(SkippedTokensTriviaSyntax node)
            => node.Update(VisitList(node.Tokens));

        public override MoonScriptSyntaxNode VisitExpressionList(ExpressionListSyntax node)
            => node.Update(VisitList(node.Expressions));

        public override MoonScriptSyntaxNode VisitParameterList(ParameterListSyntax node)
            => node.Update((SyntaxToken)Visit(node.OpenParenToken), VisitList(node.Parameters), (UsingClauseSyntax)Visit(node.Using), (SyntaxToken)Visit(node.CloseParenToken));

        public override MoonScriptSyntaxNode VisitParameter(ParameterSyntax node)
            => node.Update((SyntaxToken)Visit(node.Identifier), (SyntaxToken)Visit(node.EqualsToken), (ExpressionSyntax)Visit(node.DefaultValue));

        public override MoonScriptSyntaxNode VisitArgumentList(ArgumentListSyntax node)
            => node.Update((SyntaxToken)Visit(node.ExclamationToken), (SyntaxToken)Visit(node.OpenParenToken), VisitList(node.Arguments), (SyntaxToken)Visit(node.CloseParenToken));

        public override MoonScriptSyntaxNode VisitArgument(ArgumentSyntax node)
            => node.Update((ExpressionSyntax)Visit(node.Expression));

        public override MoonScriptSyntaxNode VisitNameColon(NameColonSyntax node)
            => node.Update((IdentifierNameSyntax)Visit(node.Name), (SyntaxToken)Visit(node.ColonToken));

        public override MoonScriptSyntaxNode VisitColonName(ColonNameSyntax node)
            => node.Update((SyntaxToken)Visit(node.ColonToken), (IdentifierNameSyntax)Visit(node.Name));

        public override MoonScriptSyntaxNode VisitBackSlashName(BackSlashNameSyntax node)
            => node.Update((SyntaxToken)Visit(node.BackSlashToken), (IdentifierNameSyntax)Visit(node.Name));

        public override MoonScriptSyntaxNode VisitImplicitSelfCall(ImplicitSelfCallSyntax node)
            => node.Update((ExpressionSyntax)Visit(node.Expression), (BackSlashNameSyntax)Visit(node.BackSlashName));

        public override MoonScriptSyntaxNode VisitImportName(ImportNameSyntax node)
            => node.Update((SyntaxToken)Visit(node.BackSlashToken), (IdentifierNameSyntax)Visit(node.Name));
    }

    internal partial class ContextAwareSyntax
    {

        private SyntaxFactoryContext context;

        public ContextAwareSyntax(SyntaxFactoryContext context)
            => this.context = context;

        public IdentifierNameSyntax IdentifierName(SyntaxToken identifier)
        {
#if DEBUG
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            switch (identifier.Kind)
            {
                case SyntaxKind.IdentifierToken:
                case SyntaxKind.GlobalEnvironmentKeyword:
                case SyntaxKind.EnvironmentKeyword: break;
                default: throw new ArgumentException(nameof(identifier));
            }
#endif

            int hash;
            var cached = MoonScriptSyntaxNodeCache.TryGetNode((int)SyntaxKind.IdentifierName, identifier, this.context, out hash);
            if (cached != null) return (IdentifierNameSyntax)cached;

            var result = new IdentifierNameSyntax(SyntaxKind.IdentifierName, identifier, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public LiteralExpressionSyntax LiteralExpression(SyntaxKind kind, SyntaxToken token)
        {
            switch (kind)
            {
                case SyntaxKind.NilLiteralExpression:
                case SyntaxKind.FalseLiteralExpression:
                case SyntaxKind.TrueLiteralExpression:
                case SyntaxKind.NumericLiteralExpression:
                case SyntaxKind.StringLiteralExpression:
                case SyntaxKind.VariousArgumentsExpression: break;
                default: throw new ArgumentException(nameof(kind));
            }
#if DEBUG
            if (token == null) throw new ArgumentNullException(nameof(token));
            switch (token.Kind)
            {
                case SyntaxKind.NilKeyword:
                case SyntaxKind.FalseKeyword:
                case SyntaxKind.TrueKeyword:
                case SyntaxKind.NumericLiteralToken:
                case SyntaxKind.StringLiteralToken:
                case SyntaxKind.MultiLineRawStringLiteralToken:
                case SyntaxKind.DotDotDotToken: break;
                default: throw new ArgumentException(nameof(token));
            }
#endif

            int hash;
            var cached = MoonScriptSyntaxNodeCache.TryGetNode((int)kind, token, this.context, out hash);
            if (cached != null) return (LiteralExpressionSyntax)cached;

            var result = new LiteralExpressionSyntax(kind, token, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public SelfExpressionSyntax SelfExpression(SyntaxToken token)
        {
#if DEBUG
            if (token == null) throw new ArgumentNullException(nameof(token));
            if (token.Kind != SyntaxKind.CommercialAtToken) throw new ArgumentException(nameof(token));
#endif

            int hash;
            var cached = MoonScriptSyntaxNodeCache.TryGetNode((int)SyntaxKind.SelfExpression, token, this.context, out hash);
            if (cached != null) return (SelfExpressionSyntax)cached;

            var result = new SelfExpressionSyntax(SyntaxKind.SelfExpression, token, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public SuperExpressionSyntax SuperExpression(SyntaxToken token)
        {
#if DEBUG
            if (token == null) throw new ArgumentNullException(nameof(token));
            if (token.Kind != SyntaxKind.SuperKeyword) throw new ArgumentException(nameof(token));
#endif

            int hash;
            var cached = MoonScriptSyntaxNodeCache.TryGetNode((int)SyntaxKind.SuperExpression, token, this.context, out hash);
            if (cached != null) return (SuperExpressionSyntax)cached;

            var result = new SuperExpressionSyntax(SyntaxKind.SuperExpression, token, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public TypeExpressionSyntax TypeExpression(SyntaxToken token)
        {
#if DEBUG
            if (token == null) throw new ArgumentNullException(nameof(token));
            if (token.Kind != SyntaxKind.CommercialAtCommercialAtToken) throw new ArgumentException(nameof(token));
#endif

            int hash;
            var cached = MoonScriptSyntaxNodeCache.TryGetNode((int)SyntaxKind.TypeExpression, token, this.context, out hash);
            if (cached != null) return (TypeExpressionSyntax)cached;

            var result = new TypeExpressionSyntax(SyntaxKind.TypeExpression, token, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public ParenthesizedExpressionSyntax ParenthesizedExpression(SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
        {
#if DEBUG
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
#endif

            int hash;
            var cached = MoonScriptSyntaxNodeCache.TryGetNode((int)SyntaxKind.ParenthesizedExpression, openParenToken, expression, closeParenToken, this.context, out hash);
            if (cached != null) return (ParenthesizedExpressionSyntax)cached;

            var result = new ParenthesizedExpressionSyntax(SyntaxKind.ParenthesizedExpression, openParenToken, expression, closeParenToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public ClassExpressionSyntax ClassExpression(SyntaxToken classKeyword, IdentifierNameSyntax name, SyntaxToken extendsKeyword, IdentifierNameSyntax baseName, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<StatementSyntax> statements)
        {
#if DEBUG
            if (classKeyword == null) throw new ArgumentNullException(nameof(classKeyword));
            if (classKeyword.Kind != SyntaxKind.ClassKeyword) throw new ArgumentException(nameof(classKeyword));
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (extendsKeyword == null) throw new ArgumentNullException(nameof(extendsKeyword));
            if (extendsKeyword.Kind != SyntaxKind.ExtendsKeyword) throw new ArgumentException(nameof(extendsKeyword));
            if (baseName == null) throw new ArgumentNullException(nameof(baseName));
#endif

            return new ClassExpressionSyntax(SyntaxKind.ClassExpression, classKeyword, name, extendsKeyword, baseName, statements.Node, this.context);
        }

        public AnomymousClassExpressionSyntax AnomymousClassExpression(SyntaxToken classKeyword, SyntaxToken extendsKeyword, IdentifierNameSyntax baseName, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<StatementSyntax> statements)
        {
#if DEBUG
            if (classKeyword == null) throw new ArgumentNullException(nameof(classKeyword));
            if (classKeyword.Kind != SyntaxKind.ClassKeyword) throw new ArgumentException(nameof(classKeyword));
            if (extendsKeyword == null) throw new ArgumentNullException(nameof(extendsKeyword));
            if (extendsKeyword.Kind != SyntaxKind.ExtendsKeyword) throw new ArgumentException(nameof(extendsKeyword));
            if (baseName == null) throw new ArgumentNullException(nameof(baseName));
#endif

            return new AnomymousClassExpressionSyntax(SyntaxKind.AnomymousClassExpression, classKeyword, extendsKeyword, baseName, statements.Node, this.context);
        }

        public DoExpressionSyntax DoExpression(SyntaxToken doKeyword, BlockSyntax block)
        {
#if DEBUG
            if (doKeyword == null) throw new ArgumentNullException(nameof(doKeyword));
            if (doKeyword.Kind != SyntaxKind.DoKeyword) throw new ArgumentException(nameof(doKeyword));
            if (block == null) throw new ArgumentNullException(nameof(block));
#endif

            int hash;
            var cached = MoonScriptSyntaxNodeCache.TryGetNode((int)SyntaxKind.DoExpression, doKeyword, block, this.context, out hash);
            if (cached != null) return (DoExpressionSyntax)cached;

            var result = new DoExpressionSyntax(SyntaxKind.DoExpression, doKeyword, block, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public ForExpressionSyntax ForExpression(SyntaxToken forKeyword, IdentifierNameSyntax name, SyntaxToken equalsToken, ExpressionSyntax initial, SyntaxToken firstCommaToken, ExpressionSyntax limit, SyntaxToken secondCommaToken, ExpressionSyntax step, SyntaxToken? doKeyword, BlockSyntax block)
        {
#if DEBUG
            if (forKeyword == null) throw new ArgumentNullException(nameof(forKeyword));
            if (forKeyword.Kind != SyntaxKind.ForKeyword) throw new ArgumentException(nameof(forKeyword));
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (equalsToken == null) throw new ArgumentNullException(nameof(equalsToken));
            if (equalsToken.Kind != SyntaxKind.EqualsToken) throw new ArgumentException(nameof(equalsToken));
            if (initial == null) throw new ArgumentNullException(nameof(initial));
            if (firstCommaToken == null) throw new ArgumentNullException(nameof(firstCommaToken));
            if (firstCommaToken.Kind != SyntaxKind.CommaToken) throw new ArgumentException(nameof(firstCommaToken));
            if (limit == null) throw new ArgumentNullException(nameof(limit));
            if (secondCommaToken == null) throw new ArgumentNullException(nameof(secondCommaToken));
            if (secondCommaToken.Kind != SyntaxKind.CommaToken) throw new ArgumentException(nameof(secondCommaToken));
            if (step == null) throw new ArgumentNullException(nameof(step));
            if (doKeyword != null)
            {
                switch (doKeyword.Kind)
                {
                    case SyntaxKind.DoKeyword:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(doKeyword));
                }
            }
            if (block == null) throw new ArgumentNullException(nameof(block));
#endif

            return new ForExpressionSyntax(SyntaxKind.ForExpression, forKeyword, name, equalsToken, initial, firstCommaToken, limit, secondCommaToken, step, doKeyword, block, this.context);
        }

        public ForInExpressionSyntax ForInExpression(SyntaxToken forKeyword, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<IdentifierNameSyntax> names, SyntaxToken inKeyword, ExpressionSyntax iteration, SyntaxToken? doKeyword, BlockSyntax block)
        {
#if DEBUG
            if (forKeyword == null) throw new ArgumentNullException(nameof(forKeyword));
            if (forKeyword.Kind != SyntaxKind.ForKeyword) throw new ArgumentException(nameof(forKeyword));
            if (inKeyword == null) throw new ArgumentNullException(nameof(inKeyword));
            if (inKeyword.Kind != SyntaxKind.InKeyword) throw new ArgumentException(nameof(inKeyword));
            if (iteration == null) throw new ArgumentNullException(nameof(iteration));
            if (doKeyword != null)
            {
                switch (doKeyword.Kind)
                {
                    case SyntaxKind.DoKeyword:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(doKeyword));
                }
            }
            if (block == null) throw new ArgumentNullException(nameof(block));
#endif

            return new ForInExpressionSyntax(SyntaxKind.ForInExpression, forKeyword, names.Node, inKeyword, iteration, doKeyword, block, this.context);
        }

        public IfExpressionSyntax IfExpression(SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken? thenKeyword, BlockSyntax block, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ElseIfClauseSyntax> elseIfs, ElseClauseSyntax? @else)
        {
#if DEBUG
            if (ifKeyword == null) throw new ArgumentNullException(nameof(ifKeyword));
            if (ifKeyword.Kind != SyntaxKind.IfKeyword) throw new ArgumentException(nameof(ifKeyword));
            if (condition == null) throw new ArgumentNullException(nameof(condition));
            if (thenKeyword != null)
            {
                switch (thenKeyword.Kind)
                {
                    case SyntaxKind.ThenKeyword:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(thenKeyword));
                }
            }
            if (block == null) throw new ArgumentNullException(nameof(block));
#endif

            return new IfExpressionSyntax(SyntaxKind.IfExpression, ifKeyword, condition, thenKeyword, block, elseIfs.Node, @else, this.context);
        }

        public ElseIfClauseSyntax ElseIfClause(SyntaxToken elseIfKeyword, ExpressionSyntax condition, SyntaxToken thenKeyword, BlockSyntax block)
        {
#if DEBUG
            if (elseIfKeyword == null) throw new ArgumentNullException(nameof(elseIfKeyword));
            if (elseIfKeyword.Kind != SyntaxKind.ElseIfKeyword) throw new ArgumentException(nameof(elseIfKeyword));
            if (condition == null) throw new ArgumentNullException(nameof(condition));
            if (thenKeyword == null) throw new ArgumentNullException(nameof(thenKeyword));
            if (thenKeyword.Kind != SyntaxKind.ThenKeyword) throw new ArgumentException(nameof(thenKeyword));
            if (block == null) throw new ArgumentNullException(nameof(block));
#endif

            return new ElseIfClauseSyntax(SyntaxKind.ElseIfClause, elseIfKeyword, condition, thenKeyword, block, this.context);
        }

        public ElseClauseSyntax ElseClause(SyntaxToken elseKeyword, BlockSyntax block)
        {
#if DEBUG
            if (elseKeyword == null) throw new ArgumentNullException(nameof(elseKeyword));
            if (elseKeyword.Kind != SyntaxKind.ElseKeyword) throw new ArgumentException(nameof(elseKeyword));
            if (block == null) throw new ArgumentNullException(nameof(block));
#endif

            int hash;
            var cached = MoonScriptSyntaxNodeCache.TryGetNode((int)SyntaxKind.ElseClause, elseKeyword, block, this.context, out hash);
            if (cached != null) return (ElseClauseSyntax)cached;

            var result = new ElseClauseSyntax(SyntaxKind.ElseClause, elseKeyword, block, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public SwitchExpressionSyntax SwitchExpression(ExpressionSyntax expression, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<WhenClauseSyntax> whens, ElseClauseSyntax @else)
        {
#if DEBUG
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (@else == null) throw new ArgumentNullException(nameof(@else));
#endif

            int hash;
            var cached = MoonScriptSyntaxNodeCache.TryGetNode((int)SyntaxKind.SwitchExpression, expression, whens.Node, @else, this.context, out hash);
            if (cached != null) return (SwitchExpressionSyntax)cached;

            var result = new SwitchExpressionSyntax(SyntaxKind.SwitchExpression, expression, whens.Node, @else, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public WhenClauseSyntax WhenClause(SyntaxToken whenKeyword, ExpressionListSyntax values, SyntaxToken? thenKeyword, BlockSyntax block)
        {
#if DEBUG
            if (whenKeyword == null) throw new ArgumentNullException(nameof(whenKeyword));
            if (whenKeyword.Kind != SyntaxKind.WhenKeyword) throw new ArgumentException(nameof(whenKeyword));
            if (values == null) throw new ArgumentNullException(nameof(values));
            if (thenKeyword != null)
            {
                switch (thenKeyword.Kind)
                {
                    case SyntaxKind.ThenKeyword:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(thenKeyword));
                }
            }
            if (block == null) throw new ArgumentNullException(nameof(block));
#endif

            return new WhenClauseSyntax(SyntaxKind.WhenClause, whenKeyword, values, thenKeyword, block, this.context);
        }

        public UnlessExpressionSyntax UnlessExpression(SyntaxToken unlessKeyword, ExpressionSyntax condition, SyntaxToken? thenKeyword, BlockSyntax block)
        {
#if DEBUG
            if (unlessKeyword == null) throw new ArgumentNullException(nameof(unlessKeyword));
            if (unlessKeyword.Kind != SyntaxKind.UnlessKeyword) throw new ArgumentException(nameof(unlessKeyword));
            if (condition == null) throw new ArgumentNullException(nameof(condition));
            if (thenKeyword != null)
            {
                switch (thenKeyword.Kind)
                {
                    case SyntaxKind.ThenKeyword:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(thenKeyword));
                }
            }
            if (block == null) throw new ArgumentNullException(nameof(block));
#endif

            return new UnlessExpressionSyntax(SyntaxKind.UnlessExpression, unlessKeyword, condition, thenKeyword, block, this.context);
        }

        public WhileExpressionSyntax WhileExpression(SyntaxToken whileKeyword, ExpressionSyntax condition, SyntaxToken? doKeyword, BlockSyntax block)
        {
#if DEBUG
            if (whileKeyword == null) throw new ArgumentNullException(nameof(whileKeyword));
            if (whileKeyword.Kind != SyntaxKind.WhileKeyword) throw new ArgumentException(nameof(whileKeyword));
            if (condition == null) throw new ArgumentNullException(nameof(condition));
            if (doKeyword != null)
            {
                switch (doKeyword.Kind)
                {
                    case SyntaxKind.DoKeyword:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(doKeyword));
                }
            }
            if (block == null) throw new ArgumentNullException(nameof(block));
#endif

            return new WhileExpressionSyntax(SyntaxKind.WhileExpression, whileKeyword, condition, doKeyword, block, this.context);
        }

        public WithExpressionSyntax WithExpression(SyntaxToken withKeyword, ExpressionSyntax expression, BlockSyntax block)
        {
#if DEBUG
            if (withKeyword == null) throw new ArgumentNullException(nameof(withKeyword));
            if (withKeyword.Kind != SyntaxKind.WithKeyword) throw new ArgumentException(nameof(withKeyword));
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (block == null) throw new ArgumentNullException(nameof(block));
#endif

            int hash;
            var cached = MoonScriptSyntaxNodeCache.TryGetNode((int)SyntaxKind.WithExpression, withKeyword, expression, block, this.context, out hash);
            if (cached != null) return (WithExpressionSyntax)cached;

            var result = new WithExpressionSyntax(SyntaxKind.WithExpression, withKeyword, expression, block, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public ListComprehensionExpressionSyntax ListComprehensionExpression(SyntaxToken openBracketToken, ExpressionSyntax expression, BaseComprehensionClauseSyntax firstClause, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<BaseComprehensionClauseSyntax> restClauses, SyntaxToken closeBracketToken)
        {
#if DEBUG
            if (openBracketToken == null) throw new ArgumentNullException(nameof(openBracketToken));
            if (openBracketToken.Kind != SyntaxKind.OpenBracketToken) throw new ArgumentException(nameof(openBracketToken));
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (firstClause == null) throw new ArgumentNullException(nameof(firstClause));
            if (closeBracketToken == null) throw new ArgumentNullException(nameof(closeBracketToken));
            if (closeBracketToken.Kind != SyntaxKind.CloseBracketToken) throw new ArgumentException(nameof(closeBracketToken));
#endif

            return new ListComprehensionExpressionSyntax(SyntaxKind.ListComprehensionExpression, openBracketToken, expression, firstClause, restClauses.Node, closeBracketToken, this.context);
        }

        public TableComprehensionExpressionSyntax TableComprehensionExpression(SyntaxToken openBraceToken, ExpressionSyntax expression, BaseComprehensionClauseSyntax firstClause, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<BaseComprehensionClauseSyntax> restClauses, SyntaxToken closeBraceToken)
        {
#if DEBUG
            if (openBraceToken == null) throw new ArgumentNullException(nameof(openBraceToken));
            if (openBraceToken.Kind != SyntaxKind.OpenBraceToken) throw new ArgumentException(nameof(openBraceToken));
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (firstClause == null) throw new ArgumentNullException(nameof(firstClause));
            if (closeBraceToken == null) throw new ArgumentNullException(nameof(closeBraceToken));
            if (closeBraceToken.Kind != SyntaxKind.CloseBraceToken) throw new ArgumentException(nameof(closeBraceToken));
#endif

            return new TableComprehensionExpressionSyntax(SyntaxKind.TableComprehensionExpression, openBraceToken, expression, firstClause, restClauses.Node, closeBraceToken, this.context);
        }

        public ForComprehensionClauseSyntax ForComprehensionClause(SyntaxToken forKeyword, IdentifierNameSyntax name, SyntaxToken equalsToken, ExpressionSyntax initial, SyntaxToken firstCommaToken, ExpressionSyntax limit, SyntaxToken secondCommaToken, ExpressionSyntax step)
        {
#if DEBUG
            if (forKeyword == null) throw new ArgumentNullException(nameof(forKeyword));
            if (forKeyword.Kind != SyntaxKind.ForKeyword) throw new ArgumentException(nameof(forKeyword));
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (equalsToken == null) throw new ArgumentNullException(nameof(equalsToken));
            if (equalsToken.Kind != SyntaxKind.EqualsToken) throw new ArgumentException(nameof(equalsToken));
            if (initial == null) throw new ArgumentNullException(nameof(initial));
            if (firstCommaToken == null) throw new ArgumentNullException(nameof(firstCommaToken));
            if (firstCommaToken.Kind != SyntaxKind.CommaToken) throw new ArgumentException(nameof(firstCommaToken));
            if (limit == null) throw new ArgumentNullException(nameof(limit));
            if (secondCommaToken == null) throw new ArgumentNullException(nameof(secondCommaToken));
            if (secondCommaToken.Kind != SyntaxKind.CommaToken) throw new ArgumentException(nameof(secondCommaToken));
            if (step == null) throw new ArgumentNullException(nameof(step));
#endif

            return new ForComprehensionClauseSyntax(SyntaxKind.ForComprehensionClause, forKeyword, name, equalsToken, initial, firstCommaToken, limit, secondCommaToken, step, this.context);
        }

        public ForInComprehensionClauseSyntax ForInComprehensionClause(SyntaxToken forKeyword, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<IdentifierNameSyntax> names, SyntaxToken inKeyword, ExpressionSyntax iteration)
        {
#if DEBUG
            if (forKeyword == null) throw new ArgumentNullException(nameof(forKeyword));
            if (forKeyword.Kind != SyntaxKind.ForKeyword) throw new ArgumentException(nameof(forKeyword));
            if (inKeyword == null) throw new ArgumentNullException(nameof(inKeyword));
            if (inKeyword.Kind != SyntaxKind.InKeyword) throw new ArgumentException(nameof(inKeyword));
            if (iteration == null) throw new ArgumentNullException(nameof(iteration));
#endif

            return new ForInComprehensionClauseSyntax(SyntaxKind.ForInComprehensionClause, forKeyword, names.Node, inKeyword, iteration, this.context);
        }

        public WhenComprehensionClauseSyntax WhenComprehensionClause(SyntaxToken whenKeyword, ExpressionSyntax condition)
        {
#if DEBUG
            if (whenKeyword == null) throw new ArgumentNullException(nameof(whenKeyword));
            if (whenKeyword.Kind != SyntaxKind.WhenKeyword) throw new ArgumentException(nameof(whenKeyword));
            if (condition == null) throw new ArgumentNullException(nameof(condition));
#endif

            int hash;
            var cached = MoonScriptSyntaxNodeCache.TryGetNode((int)SyntaxKind.WhenComprehensionClause, whenKeyword, condition, this.context, out hash);
            if (cached != null) return (WhenComprehensionClauseSyntax)cached;

            var result = new WhenComprehensionClauseSyntax(SyntaxKind.WhenComprehensionClause, whenKeyword, condition, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public NumericallyIterateExpressionSyntax NumericallyIterateExpression(SyntaxToken asteriskToken, ExpressionSyntax expression)
        {
#if DEBUG
            if (asteriskToken == null) throw new ArgumentNullException(nameof(asteriskToken));
            if (asteriskToken.Kind != SyntaxKind.AsteriskToken) throw new ArgumentException(nameof(asteriskToken));
            if (expression == null) throw new ArgumentNullException(nameof(expression));
#endif

            int hash;
            var cached = MoonScriptSyntaxNodeCache.TryGetNode((int)SyntaxKind.NumericallyIterateExpression, asteriskToken, expression, this.context, out hash);
            if (cached != null) return (NumericallyIterateExpressionSyntax)cached;

            var result = new NumericallyIterateExpressionSyntax(SyntaxKind.NumericallyIterateExpression, asteriskToken, expression, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public SlicingExpressionSyntax SlicingExpression(ExpressionSyntax numericallyIterateExpression, SyntaxToken openBracketToken, ExpressionSyntax? initial, SyntaxToken firstCommaToken, ExpressionSyntax? limit, SyntaxToken secondCommaToken, ExpressionSyntax step, SyntaxToken closeBracketToken)
        {
#if DEBUG
            if (numericallyIterateExpression == null) throw new ArgumentNullException(nameof(numericallyIterateExpression));
            if (openBracketToken == null) throw new ArgumentNullException(nameof(openBracketToken));
            if (openBracketToken.Kind != SyntaxKind.OpenBracketToken) throw new ArgumentException(nameof(openBracketToken));
            if (firstCommaToken == null) throw new ArgumentNullException(nameof(firstCommaToken));
            if (firstCommaToken.Kind != SyntaxKind.CommaToken) throw new ArgumentException(nameof(firstCommaToken));
            if (secondCommaToken == null) throw new ArgumentNullException(nameof(secondCommaToken));
            if (secondCommaToken.Kind != SyntaxKind.CommaToken) throw new ArgumentException(nameof(secondCommaToken));
            if (step == null) throw new ArgumentNullException(nameof(step));
            if (closeBracketToken == null) throw new ArgumentNullException(nameof(closeBracketToken));
            if (closeBracketToken.Kind != SyntaxKind.CloseBracketToken) throw new ArgumentException(nameof(closeBracketToken));
#endif

            return new SlicingExpressionSyntax(SyntaxKind.SlicingExpression, numericallyIterateExpression, openBracketToken, initial, firstCommaToken, limit, secondCommaToken, step, closeBracketToken, this.context);
        }

        public InvocationExpressionSyntax InvocationExpression(ExpressionSyntax? expression, ImplicitSelfCallSyntax? selfCall, ArgumentListSyntax argumentList)
        {
#if DEBUG
            if (argumentList == null) throw new ArgumentNullException(nameof(argumentList));
#endif

            int hash;
            var cached = MoonScriptSyntaxNodeCache.TryGetNode((int)SyntaxKind.InvocationExpression, expression, selfCall, argumentList, this.context, out hash);
            if (cached != null) return (InvocationExpressionSyntax)cached;

            var result = new InvocationExpressionSyntax(SyntaxKind.InvocationExpression, expression, selfCall, argumentList, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public LambdaExpressionSyntax LambdaExpression(ParameterListSyntax? parameters, SyntaxToken arrow, BlockSyntax block)
        {
#if DEBUG
            if (arrow == null) throw new ArgumentNullException(nameof(arrow));
            switch (arrow.Kind)
            {
                case SyntaxKind.MinusGreaterThanToken:
                case SyntaxKind.EqualsGreaterThanToken: break;
                default: throw new ArgumentException(nameof(arrow));
            }
            if (block == null) throw new ArgumentNullException(nameof(block));
#endif

            int hash;
            var cached = MoonScriptSyntaxNodeCache.TryGetNode((int)SyntaxKind.LambdaExpression, parameters, arrow, block, this.context, out hash);
            if (cached != null) return (LambdaExpressionSyntax)cached;

            var result = new LambdaExpressionSyntax(SyntaxKind.LambdaExpression, parameters, arrow, block, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public BinaryExpressionSyntax BinaryExpression(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)
        {
            switch (kind)
            {
                case SyntaxKind.AdditionExpression:
                case SyntaxKind.SubtractionExpression:
                case SyntaxKind.MultiplicationExpression:
                case SyntaxKind.DivisionExpression:
                case SyntaxKind.FloorDivisionExpression:
                case SyntaxKind.ExponentiationExpression:
                case SyntaxKind.ModuloExpression:
                case SyntaxKind.BitwiseAndExpression:
                case SyntaxKind.BitwiseExclusiveOrExpression:
                case SyntaxKind.BitwiseOrExpression:
                case SyntaxKind.BitwiseLeftShiftExpression:
                case SyntaxKind.BitwiseRightShiftExpression:
                case SyntaxKind.ConcatenationExpression:
                case SyntaxKind.LessThanExpression:
                case SyntaxKind.LessThanOrEqualExpression:
                case SyntaxKind.GreaterThanExpression:
                case SyntaxKind.GreaterThanOrEqualExpression:
                case SyntaxKind.EqualExpression:
                case SyntaxKind.NotEqualExpression:
                case SyntaxKind.AndExpression:
                case SyntaxKind.OrExpression: break;
                default: throw new ArgumentException(nameof(kind));
            }
#if DEBUG
            if (left == null) throw new ArgumentNullException(nameof(left));
            if (operatorToken == null) throw new ArgumentNullException(nameof(operatorToken));
            switch (operatorToken.Kind)
            {
                case SyntaxKind.PlusToken:
                case SyntaxKind.MinusToken:
                case SyntaxKind.AsteriskToken:
                case SyntaxKind.SlashToken:
                case SyntaxKind.SlashSlashToken:
                case SyntaxKind.CaretToken:
                case SyntaxKind.PersentToken:
                case SyntaxKind.AmpersandToken:
                case SyntaxKind.TildeToken:
                case SyntaxKind.BarToken:
                case SyntaxKind.LessThanLessThanToken:
                case SyntaxKind.GreaterThanGreaterThanToken:
                case SyntaxKind.DotDotToken:
                case SyntaxKind.LessThanToken:
                case SyntaxKind.LessThanEqualsToken:
                case SyntaxKind.GreaterThanToken:
                case SyntaxKind.GreaterThanEqualsToken:
                case SyntaxKind.EqualsEqualsToken:
                case SyntaxKind.TildeEqualsToken:
                case SyntaxKind.AndKeyword:
                case SyntaxKind.OrKeyword: break;
                default: throw new ArgumentException(nameof(operatorToken));
            }
            if (right == null) throw new ArgumentNullException(nameof(right));
#endif

            int hash;
            var cached = MoonScriptSyntaxNodeCache.TryGetNode((int)kind, left, operatorToken, right, this.context, out hash);
            if (cached != null) return (BinaryExpressionSyntax)cached;

            var result = new BinaryExpressionSyntax(kind, left, operatorToken, right, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public UnaryExpressionSyntax UnaryExpression(SyntaxKind kind, SyntaxToken operatorToken, ExpressionSyntax operand)
        {
            switch (kind)
            {
                case SyntaxKind.UnaryMinusExpression:
                case SyntaxKind.LogicalNotExpression:
                case SyntaxKind.LengthExpression:
                case SyntaxKind.BitwiseNotExpression: break;
                default: throw new ArgumentException(nameof(kind));
            }
#if DEBUG
            if (operatorToken == null) throw new ArgumentNullException(nameof(operatorToken));
            switch (operatorToken.Kind)
            {
                case SyntaxKind.MinusToken:
                case SyntaxKind.NotKeyword:
                case SyntaxKind.HashToken:
                case SyntaxKind.TildeToken: break;
                default: throw new ArgumentException(nameof(operatorToken));
            }
            if (operand == null) throw new ArgumentNullException(nameof(operand));
#endif

            int hash;
            var cached = MoonScriptSyntaxNodeCache.TryGetNode((int)kind, operatorToken, operand, this.context, out hash);
            if (cached != null) return (UnaryExpressionSyntax)cached;

            var result = new UnaryExpressionSyntax(kind, operatorToken, operand, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public SimpleAssignmentExpressionSyntax SimpleAssignmentExpression(ExpressionListSyntax left, SyntaxToken equalsToken, ExpressionListSyntax right)
        {
#if DEBUG
            if (left == null) throw new ArgumentNullException(nameof(left));
            if (equalsToken == null) throw new ArgumentNullException(nameof(equalsToken));
            if (equalsToken.Kind != SyntaxKind.EqualsToken) throw new ArgumentException(nameof(equalsToken));
            if (right == null) throw new ArgumentNullException(nameof(right));
#endif

            int hash;
            var cached = MoonScriptSyntaxNodeCache.TryGetNode((int)SyntaxKind.SimpleAssignmentExpression, left, equalsToken, right, this.context, out hash);
            if (cached != null) return (SimpleAssignmentExpressionSyntax)cached;

            var result = new SimpleAssignmentExpressionSyntax(SyntaxKind.SimpleAssignmentExpression, left, equalsToken, right, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public UpdateAssignmentExpressionSyntax UpdateAssignmentExpression(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionListSyntax right)
        {
            switch (kind)
            {
                case SyntaxKind.AdditionAssignmentExpression:
                case SyntaxKind.SubtractionAssignmentExpression:
                case SyntaxKind.MultiplicationAssignmentExpression:
                case SyntaxKind.DivisionAssignmentExpression:
                case SyntaxKind.FloorDivisionAssignmentExpression:
                case SyntaxKind.ExponentiationAssignmentExpression:
                case SyntaxKind.ModuloAssignmentExpression:
                case SyntaxKind.BitwiseAndAssignmentExpression:
                case SyntaxKind.BitwiseExclusiveOrAssignmentExpression:
                case SyntaxKind.BitwiseOrAssignmentExpression:
                case SyntaxKind.BitwiseLeftShiftAssignmentExpression:
                case SyntaxKind.BitwiseRightShiftAssignmentExpression:
                case SyntaxKind.ConcatenationAssignmentExpression:
                case SyntaxKind.AndAssignmentExpression:
                case SyntaxKind.OrAssignmentExpression: break;
                default: throw new ArgumentException(nameof(kind));
            }
#if DEBUG
            if (left == null) throw new ArgumentNullException(nameof(left));
            if (operatorToken == null) throw new ArgumentNullException(nameof(operatorToken));
            switch (operatorToken.Kind)
            {
                case SyntaxKind.PlusEqualsToken:
                case SyntaxKind.MinusEqualsToken:
                case SyntaxKind.AsteriskEqualsToken:
                case SyntaxKind.SlashEqualsToken:
                case SyntaxKind.SlashSlashEqualsToken:
                case SyntaxKind.CaretEqualsToken:
                case SyntaxKind.PersentEqualsToken:
                case SyntaxKind.AmpersandEqualsToken:
                case SyntaxKind.BarEqualsToken:
                case SyntaxKind.LessThanLessThanEqualsToken:
                case SyntaxKind.GreaterThanGreaterThanEqualsToken:
                case SyntaxKind.DotDotEqualsToken:
                case SyntaxKind.AndEqualsToken:
                case SyntaxKind.OrEqualsToken: break;
                default: throw new ArgumentException(nameof(operatorToken));
            }
            if (right == null) throw new ArgumentNullException(nameof(right));
#endif

            int hash;
            var cached = MoonScriptSyntaxNodeCache.TryGetNode((int)kind, left, operatorToken, right, this.context, out hash);
            if (cached != null) return (UpdateAssignmentExpressionSyntax)cached;

            var result = new UpdateAssignmentExpressionSyntax(kind, left, operatorToken, right, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public ExpressionStatementSyntax ExpressionStatement(ExpressionSyntax expression, LineDecoratorSyntax? lineDecorator)
        {
#if DEBUG
            if (expression == null) throw new ArgumentNullException(nameof(expression));
#endif

            int hash;
            var cached = MoonScriptSyntaxNodeCache.TryGetNode((int)SyntaxKind.ExpressionStatement, expression, lineDecorator, this.context, out hash);
            if (cached != null) return (ExpressionStatementSyntax)cached;

            var result = new ExpressionStatementSyntax(SyntaxKind.ExpressionStatement, expression, lineDecorator, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public BreakStatementSyntax BreakStatement(SyntaxToken breakKeyword, ConditionalLineDecoratorSyntax? lineDecorator)
        {
#if DEBUG
            if (breakKeyword == null) throw new ArgumentNullException(nameof(breakKeyword));
            if (breakKeyword.Kind != SyntaxKind.BreakKeyword) throw new ArgumentException(nameof(breakKeyword));
#endif

            int hash;
            var cached = MoonScriptSyntaxNodeCache.TryGetNode((int)SyntaxKind.BreakStatement, breakKeyword, lineDecorator, this.context, out hash);
            if (cached != null) return (BreakStatementSyntax)cached;

            var result = new BreakStatementSyntax(SyntaxKind.BreakStatement, breakKeyword, lineDecorator, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public ClassStatementSyntax ClassStatement(SyntaxToken classKeyword, IdentifierNameSyntax name, SyntaxToken extendsKeyword, IdentifierNameSyntax baseName, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<StatementSyntax> statements)
        {
#if DEBUG
            if (classKeyword == null) throw new ArgumentNullException(nameof(classKeyword));
            if (classKeyword.Kind != SyntaxKind.ClassKeyword) throw new ArgumentException(nameof(classKeyword));
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (extendsKeyword == null) throw new ArgumentNullException(nameof(extendsKeyword));
            if (extendsKeyword.Kind != SyntaxKind.ExtendsKeyword) throw new ArgumentException(nameof(extendsKeyword));
            if (baseName == null) throw new ArgumentNullException(nameof(baseName));
#endif

            return new ClassStatementSyntax(SyntaxKind.ClassStatement, classKeyword, name, extendsKeyword, baseName, statements.Node, this.context);
        }

        public MemberStatementSyntax MemberStatement(SyntaxToken? commercialAtToken, NameColonSyntax nameColon, ExpressionSyntax expression)
        {
#if DEBUG
            if (commercialAtToken != null)
            {
                switch (commercialAtToken.Kind)
                {
                    case SyntaxKind.CommercialAtToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(commercialAtToken));
                }
            }
            if (nameColon == null) throw new ArgumentNullException(nameof(nameColon));
            if (expression == null) throw new ArgumentNullException(nameof(expression));
#endif

            int hash;
            var cached = MoonScriptSyntaxNodeCache.TryGetNode((int)SyntaxKind.MemberStatement, commercialAtToken, nameColon, expression, this.context, out hash);
            if (cached != null) return (MemberStatementSyntax)cached;

            var result = new MemberStatementSyntax(SyntaxKind.MemberStatement, commercialAtToken, nameColon, expression, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public ContinueStatementSyntax ContinueStatement(SyntaxToken breakKeyword, ConditionalLineDecoratorSyntax? lineDecorator)
        {
#if DEBUG
            if (breakKeyword == null) throw new ArgumentNullException(nameof(breakKeyword));
            if (breakKeyword.Kind != SyntaxKind.BreakKeyword) throw new ArgumentException(nameof(breakKeyword));
#endif

            int hash;
            var cached = MoonScriptSyntaxNodeCache.TryGetNode((int)SyntaxKind.ContinueStatement, breakKeyword, lineDecorator, this.context, out hash);
            if (cached != null) return (ContinueStatementSyntax)cached;

            var result = new ContinueStatementSyntax(SyntaxKind.ContinueStatement, breakKeyword, lineDecorator, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public DoStatementSyntax DoStatement(SyntaxToken doKeyword, BlockSyntax block)
        {
#if DEBUG
            if (doKeyword == null) throw new ArgumentNullException(nameof(doKeyword));
            if (doKeyword.Kind != SyntaxKind.DoKeyword) throw new ArgumentException(nameof(doKeyword));
            if (block == null) throw new ArgumentNullException(nameof(block));
#endif

            int hash;
            var cached = MoonScriptSyntaxNodeCache.TryGetNode((int)SyntaxKind.DoStatement, doKeyword, block, this.context, out hash);
            if (cached != null) return (DoStatementSyntax)cached;

            var result = new DoStatementSyntax(SyntaxKind.DoStatement, doKeyword, block, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public ExportStatementSyntax ExportStatement(SyntaxToken exportKeyword, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<IdentifierNameSyntax> names, SimpleAssignmentExpressionSyntax? simpleAssignmentExpression, SyntaxToken? asteriskToken, SyntaxToken? caretToken)
        {
#if DEBUG
            if (exportKeyword == null) throw new ArgumentNullException(nameof(exportKeyword));
            if (exportKeyword.Kind != SyntaxKind.ExportKeyword) throw new ArgumentException(nameof(exportKeyword));
            if (asteriskToken != null)
            {
                switch (asteriskToken.Kind)
                {
                    case SyntaxKind.AsteriskToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(asteriskToken));
                }
            }
            if (caretToken != null)
            {
                switch (caretToken.Kind)
                {
                    case SyntaxKind.CaretToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(caretToken));
                }
            }
#endif

            return new ExportStatementSyntax(SyntaxKind.ExportStatement, exportKeyword, names.Node, simpleAssignmentExpression, asteriskToken, caretToken, this.context);
        }

        public ForStatementSyntax ForStatement(SyntaxToken forKeyword, IdentifierNameSyntax name, SyntaxToken equalsToken, ExpressionSyntax initial, SyntaxToken firstCommaToken, ExpressionSyntax limit, SyntaxToken secondCommaToken, ExpressionSyntax step, SyntaxToken? doKeyword, BlockSyntax block)
        {
#if DEBUG
            if (forKeyword == null) throw new ArgumentNullException(nameof(forKeyword));
            if (forKeyword.Kind != SyntaxKind.ForKeyword) throw new ArgumentException(nameof(forKeyword));
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (equalsToken == null) throw new ArgumentNullException(nameof(equalsToken));
            if (equalsToken.Kind != SyntaxKind.EqualsToken) throw new ArgumentException(nameof(equalsToken));
            if (initial == null) throw new ArgumentNullException(nameof(initial));
            if (firstCommaToken == null) throw new ArgumentNullException(nameof(firstCommaToken));
            if (firstCommaToken.Kind != SyntaxKind.CommaToken) throw new ArgumentException(nameof(firstCommaToken));
            if (limit == null) throw new ArgumentNullException(nameof(limit));
            if (secondCommaToken == null) throw new ArgumentNullException(nameof(secondCommaToken));
            if (secondCommaToken.Kind != SyntaxKind.CommaToken) throw new ArgumentException(nameof(secondCommaToken));
            if (step == null) throw new ArgumentNullException(nameof(step));
            if (doKeyword != null)
            {
                switch (doKeyword.Kind)
                {
                    case SyntaxKind.DoKeyword:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(doKeyword));
                }
            }
            if (block == null) throw new ArgumentNullException(nameof(block));
#endif

            return new ForStatementSyntax(SyntaxKind.ForStatement, forKeyword, name, equalsToken, initial, firstCommaToken, limit, secondCommaToken, step, doKeyword, block, this.context);
        }

        public ForInStatementSyntax ForInStatement(SyntaxToken forKeyword, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<IdentifierNameSyntax> names, SyntaxToken inKeyword, ExpressionSyntax iteration, SyntaxToken? doKeyword, BlockSyntax block)
        {
#if DEBUG
            if (forKeyword == null) throw new ArgumentNullException(nameof(forKeyword));
            if (forKeyword.Kind != SyntaxKind.ForKeyword) throw new ArgumentException(nameof(forKeyword));
            if (inKeyword == null) throw new ArgumentNullException(nameof(inKeyword));
            if (inKeyword.Kind != SyntaxKind.InKeyword) throw new ArgumentException(nameof(inKeyword));
            if (iteration == null) throw new ArgumentNullException(nameof(iteration));
            if (doKeyword != null)
            {
                switch (doKeyword.Kind)
                {
                    case SyntaxKind.DoKeyword:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(doKeyword));
                }
            }
            if (block == null) throw new ArgumentNullException(nameof(block));
#endif

            return new ForInStatementSyntax(SyntaxKind.ForInStatement, forKeyword, names.Node, inKeyword, iteration, doKeyword, block, this.context);
        }

        public IfStatementSyntax IfStatement(ExpressionSyntax condition, SyntaxToken? thenKeyword, BlockSyntax block, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ElseIfClauseSyntax> elseIfs, ElseClauseSyntax? @else)
        {
#if DEBUG
            if (condition == null) throw new ArgumentNullException(nameof(condition));
            if (thenKeyword != null)
            {
                switch (thenKeyword.Kind)
                {
                    case SyntaxKind.ThenKeyword:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(thenKeyword));
                }
            }
            if (block == null) throw new ArgumentNullException(nameof(block));
#endif

            return new IfStatementSyntax(SyntaxKind.IfStatement, condition, thenKeyword, block, elseIfs.Node, @else, this.context);
        }

        public ImportStatementSytnax ImportStatementSytnax(SyntaxToken importKeyword, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ImportNameSyntax> names, SyntaxToken fromKeyword, IdentifierNameSyntax from)
        {
#if DEBUG
            if (importKeyword == null) throw new ArgumentNullException(nameof(importKeyword));
            if (importKeyword.Kind != SyntaxKind.ImportKeyword) throw new ArgumentException(nameof(importKeyword));
            if (fromKeyword == null) throw new ArgumentNullException(nameof(fromKeyword));
            if (fromKeyword.Kind != SyntaxKind.FromKeyword) throw new ArgumentException(nameof(fromKeyword));
            if (from == null) throw new ArgumentNullException(nameof(from));
#endif

            return new ImportStatementSytnax(SyntaxKind.ImportStatement, importKeyword, names.Node, fromKeyword, from, this.context);
        }

        public LocalStatementSyntax LocalStatement(SyntaxToken localKeyword, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<IdentifierNameSyntax> names, SimpleAssignmentExpressionSyntax? simpleAssignmentExpression, SyntaxToken? asteriskToken)
        {
#if DEBUG
            if (localKeyword == null) throw new ArgumentNullException(nameof(localKeyword));
            if (localKeyword.Kind != SyntaxKind.LocalKeyword) throw new ArgumentException(nameof(localKeyword));
            if (asteriskToken != null)
            {
                switch (asteriskToken.Kind)
                {
                    case SyntaxKind.AsteriskToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(asteriskToken));
                }
            }
#endif

            return new LocalStatementSyntax(SyntaxKind.LocalStatement, localKeyword, names.Node, simpleAssignmentExpression, asteriskToken, this.context);
        }

        public SwitchStatementSyntax SwitchStatement(ExpressionSyntax expression, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<WhenClauseSyntax> whens, ElseClauseSyntax @else)
        {
#if DEBUG
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (@else == null) throw new ArgumentNullException(nameof(@else));
#endif

            int hash;
            var cached = MoonScriptSyntaxNodeCache.TryGetNode((int)SyntaxKind.SwitchStatement, expression, whens.Node, @else, this.context, out hash);
            if (cached != null) return (SwitchStatementSyntax)cached;

            var result = new SwitchStatementSyntax(SyntaxKind.SwitchStatement, expression, whens.Node, @else, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public UnlessStatementSyntax UnlessStatement(SyntaxToken unlessKeyword, ExpressionSyntax condition, SyntaxToken? thenKeyword, BlockSyntax block)
        {
#if DEBUG
            if (unlessKeyword == null) throw new ArgumentNullException(nameof(unlessKeyword));
            if (unlessKeyword.Kind != SyntaxKind.UnlessKeyword) throw new ArgumentException(nameof(unlessKeyword));
            if (condition == null) throw new ArgumentNullException(nameof(condition));
            if (thenKeyword != null)
            {
                switch (thenKeyword.Kind)
                {
                    case SyntaxKind.ThenKeyword:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(thenKeyword));
                }
            }
            if (block == null) throw new ArgumentNullException(nameof(block));
#endif

            return new UnlessStatementSyntax(SyntaxKind.UnlessStatement, unlessKeyword, condition, thenKeyword, block, this.context);
        }

        public UsingClauseSyntax UsingClause(SyntaxToken usingKeyword, SyntaxToken? nilKeyword, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<IdentifierNameSyntax> names)
        {
#if DEBUG
            if (usingKeyword == null) throw new ArgumentNullException(nameof(usingKeyword));
            if (usingKeyword.Kind != SyntaxKind.UsingKeyword) throw new ArgumentException(nameof(usingKeyword));
            if (nilKeyword != null)
            {
                switch (nilKeyword.Kind)
                {
                    case SyntaxKind.NilKeyword:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(nilKeyword));
                }
            }
#endif

            int hash;
            var cached = MoonScriptSyntaxNodeCache.TryGetNode((int)SyntaxKind.UsingClause, usingKeyword, nilKeyword, names.Node, this.context, out hash);
            if (cached != null) return (UsingClauseSyntax)cached;

            var result = new UsingClauseSyntax(SyntaxKind.UsingClause, usingKeyword, nilKeyword, names.Node, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public WhileStatementSyntax WhileStatement(SyntaxToken whileKeyword, ExpressionSyntax condition, SyntaxToken? doKeyword, BlockSyntax block)
        {
#if DEBUG
            if (whileKeyword == null) throw new ArgumentNullException(nameof(whileKeyword));
            if (whileKeyword.Kind != SyntaxKind.WhileKeyword) throw new ArgumentException(nameof(whileKeyword));
            if (condition == null) throw new ArgumentNullException(nameof(condition));
            if (doKeyword != null)
            {
                switch (doKeyword.Kind)
                {
                    case SyntaxKind.DoKeyword:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(doKeyword));
                }
            }
            if (block == null) throw new ArgumentNullException(nameof(block));
#endif

            return new WhileStatementSyntax(SyntaxKind.WhileStatement, whileKeyword, condition, doKeyword, block, this.context);
        }

        public WithStatementSyntax WithStatement(SyntaxToken withKeyword, ExpressionSyntax expression, BlockSyntax block)
        {
#if DEBUG
            if (withKeyword == null) throw new ArgumentNullException(nameof(withKeyword));
            if (withKeyword.Kind != SyntaxKind.WithKeyword) throw new ArgumentException(nameof(withKeyword));
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (block == null) throw new ArgumentNullException(nameof(block));
#endif

            int hash;
            var cached = MoonScriptSyntaxNodeCache.TryGetNode((int)SyntaxKind.WithStatement, withKeyword, expression, block, this.context, out hash);
            if (cached != null) return (WithStatementSyntax)cached;

            var result = new WithStatementSyntax(SyntaxKind.WithStatement, withKeyword, expression, block, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public DestructuringAssignmentStatementSyntax DestructuringAssignmentStatement(DestructuringUnitSyntax unit, SyntaxToken equalsToken, ExpressionSyntax expression)
        {
#if DEBUG
            if (unit == null) throw new ArgumentNullException(nameof(unit));
            if (equalsToken == null) throw new ArgumentNullException(nameof(equalsToken));
            if (equalsToken.Kind != SyntaxKind.EqualsToken) throw new ArgumentException(nameof(equalsToken));
            if (expression == null) throw new ArgumentNullException(nameof(expression));
#endif

            int hash;
            var cached = MoonScriptSyntaxNodeCache.TryGetNode((int)SyntaxKind.DestructuringAssignmentStatement, unit, equalsToken, expression, this.context, out hash);
            if (cached != null) return (DestructuringAssignmentStatementSyntax)cached;

            var result = new DestructuringAssignmentStatementSyntax(SyntaxKind.DestructuringAssignmentStatement, unit, equalsToken, expression, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public DestructuringIdentifierNameSyntax DestructuringIdentifierName(IdentifierNameSyntax name)
        {
#if DEBUG
            if (name == null) throw new ArgumentNullException(nameof(name));
#endif

            int hash;
            var cached = MoonScriptSyntaxNodeCache.TryGetNode((int)SyntaxKind.DestructuringIdentifierName, name, this.context, out hash);
            if (cached != null) return (DestructuringIdentifierNameSyntax)cached;

            var result = new DestructuringIdentifierNameSyntax(SyntaxKind.DestructuringIdentifierName, name, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public DestructuringListSyntax DestructuringList(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<DestructuringUnitSyntax> units)
        {
#if DEBUG
#endif

            int hash;
            var cached = MoonScriptSyntaxNodeCache.TryGetNode((int)SyntaxKind.DestructuringList, units.Node, this.context, out hash);
            if (cached != null) return (DestructuringListSyntax)cached;

            var result = new DestructuringListSyntax(SyntaxKind.DestructuringList, units.Node, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public DestructuringFieldSyntax DestructuringField(DestructuringUnitSyntax? unit, NameColonSyntax? nameColon, DestructuringUnitSyntax? namedUnit, ColonNameSyntax? colonName)
        {
#if DEBUG
#endif

            return new DestructuringFieldSyntax(SyntaxKind.DestructuringField, unit, nameColon, namedUnit, colonName, this.context);
        }

        public DestructuringTableSyntax DestructuringTable(SyntaxToken? openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<DestructuringFieldSyntax> fields, SyntaxToken? closeBraceToken)
        {
#if DEBUG
            if (openBraceToken != null)
            {
                switch (openBraceToken.Kind)
                {
                    case SyntaxKind.OpenBraceToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(openBraceToken));
                }
            }
            if (closeBraceToken != null)
            {
                switch (closeBraceToken.Kind)
                {
                    case SyntaxKind.CloseBraceToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(closeBraceToken));
                }
            }
#endif

            int hash;
            var cached = MoonScriptSyntaxNodeCache.TryGetNode((int)SyntaxKind.DestructuringList, openBraceToken, fields.Node, closeBraceToken, this.context, out hash);
            if (cached != null) return (DestructuringTableSyntax)cached;

            var result = new DestructuringTableSyntax(SyntaxKind.DestructuringList, openBraceToken, fields.Node, closeBraceToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public ForLineDecoratorSyntax ForLineDecorator(SyntaxToken forKeyword, IdentifierNameSyntax name, SyntaxToken equalsToken, ExpressionSyntax initial, SyntaxToken firstCommaToken, ExpressionSyntax limit, SyntaxToken secondCommaToken, ExpressionSyntax step)
        {
#if DEBUG
            if (forKeyword == null) throw new ArgumentNullException(nameof(forKeyword));
            if (forKeyword.Kind != SyntaxKind.ForKeyword) throw new ArgumentException(nameof(forKeyword));
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (equalsToken == null) throw new ArgumentNullException(nameof(equalsToken));
            if (equalsToken.Kind != SyntaxKind.EqualsToken) throw new ArgumentException(nameof(equalsToken));
            if (initial == null) throw new ArgumentNullException(nameof(initial));
            if (firstCommaToken == null) throw new ArgumentNullException(nameof(firstCommaToken));
            if (firstCommaToken.Kind != SyntaxKind.CommaToken) throw new ArgumentException(nameof(firstCommaToken));
            if (limit == null) throw new ArgumentNullException(nameof(limit));
            if (secondCommaToken == null) throw new ArgumentNullException(nameof(secondCommaToken));
            if (secondCommaToken.Kind != SyntaxKind.CommaToken) throw new ArgumentException(nameof(secondCommaToken));
            if (step == null) throw new ArgumentNullException(nameof(step));
#endif

            return new ForLineDecoratorSyntax(SyntaxKind.ForLineDecorator, forKeyword, name, equalsToken, initial, firstCommaToken, limit, secondCommaToken, step, this.context);
        }

        public ForInLineDecoratorSyntax ForInLineDecorator(SyntaxToken forKeyword, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<IdentifierNameSyntax> names, SyntaxToken inKeyword, ExpressionSyntax iteration)
        {
#if DEBUG
            if (forKeyword == null) throw new ArgumentNullException(nameof(forKeyword));
            if (forKeyword.Kind != SyntaxKind.ForKeyword) throw new ArgumentException(nameof(forKeyword));
            if (inKeyword == null) throw new ArgumentNullException(nameof(inKeyword));
            if (inKeyword.Kind != SyntaxKind.InKeyword) throw new ArgumentException(nameof(inKeyword));
            if (iteration == null) throw new ArgumentNullException(nameof(iteration));
#endif

            return new ForInLineDecoratorSyntax(SyntaxKind.ForInLineDecorator, forKeyword, names.Node, inKeyword, iteration, this.context);
        }

        public IfLineDecoratorSyntax IfLineDecorator(SyntaxToken ifKeyword, ExpressionSyntax condition)
        {
#if DEBUG
            if (ifKeyword == null) throw new ArgumentNullException(nameof(ifKeyword));
            if (ifKeyword.Kind != SyntaxKind.IfKeyword) throw new ArgumentException(nameof(ifKeyword));
            if (condition == null) throw new ArgumentNullException(nameof(condition));
#endif

            int hash;
            var cached = MoonScriptSyntaxNodeCache.TryGetNode((int)SyntaxKind.IfLineDecorator, ifKeyword, condition, this.context, out hash);
            if (cached != null) return (IfLineDecoratorSyntax)cached;

            var result = new IfLineDecoratorSyntax(SyntaxKind.IfLineDecorator, ifKeyword, condition, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public UnlessLineDecoratorSyntax UnlessLineDecorator(SyntaxToken unlessKeyword, ExpressionSyntax condition)
        {
#if DEBUG
            if (unlessKeyword == null) throw new ArgumentNullException(nameof(unlessKeyword));
            if (unlessKeyword.Kind != SyntaxKind.UnlessKeyword) throw new ArgumentException(nameof(unlessKeyword));
            if (condition == null) throw new ArgumentNullException(nameof(condition));
#endif

            int hash;
            var cached = MoonScriptSyntaxNodeCache.TryGetNode((int)SyntaxKind.UnlessLineDecorator, unlessKeyword, condition, this.context, out hash);
            if (cached != null) return (UnlessLineDecoratorSyntax)cached;

            var result = new UnlessLineDecoratorSyntax(SyntaxKind.UnlessLineDecorator, unlessKeyword, condition, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public WhileLineDecoratorSyntax WhileLineDecorator(SyntaxToken whileKeyword, ExpressionSyntax condition)
        {
#if DEBUG
            if (whileKeyword == null) throw new ArgumentNullException(nameof(whileKeyword));
            if (whileKeyword.Kind != SyntaxKind.WhileKeyword) throw new ArgumentException(nameof(whileKeyword));
            if (condition == null) throw new ArgumentNullException(nameof(condition));
#endif

            int hash;
            var cached = MoonScriptSyntaxNodeCache.TryGetNode((int)SyntaxKind.WhileLineDecorator, whileKeyword, condition, this.context, out hash);
            if (cached != null) return (WhileLineDecoratorSyntax)cached;

            var result = new WhileLineDecoratorSyntax(SyntaxKind.WhileLineDecorator, whileKeyword, condition, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public ChunkSyntax Chunk(BlockSyntax block, SyntaxToken endOfFileToken)
        {
#if DEBUG
            if (block == null) throw new ArgumentNullException(nameof(block));
            if (endOfFileToken == null) throw new ArgumentNullException(nameof(endOfFileToken));
            if (endOfFileToken.Kind != SyntaxKind.EndOfFileToken) throw new ArgumentException(nameof(endOfFileToken));
#endif

            int hash;
            var cached = MoonScriptSyntaxNodeCache.TryGetNode((int)SyntaxKind.Chunk, block, endOfFileToken, this.context, out hash);
            if (cached != null) return (ChunkSyntax)cached;

            var result = new ChunkSyntax(SyntaxKind.Chunk, block, endOfFileToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public BlockSyntax Block(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<StatementSyntax> statements)
        {
#if DEBUG
#endif

            int hash;
            var cached = MoonScriptSyntaxNodeCache.TryGetNode((int)SyntaxKind.Block, statements.Node, this.context, out hash);
            if (cached != null) return (BlockSyntax)cached;

            var result = new BlockSyntax(SyntaxKind.Block, statements.Node, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public SkippedTokensTriviaSyntax SkippedTokensTrivia(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> tokens)
        {
#if DEBUG
#endif

            return new SkippedTokensTriviaSyntax(SyntaxKind.SkippedTokensTrivia, tokens.Node, this.context);
        }

        public ExpressionListSyntax ExpressionList(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> expressions)
        {
#if DEBUG
#endif

            int hash;
            var cached = MoonScriptSyntaxNodeCache.TryGetNode((int)SyntaxKind.ExpressionList, expressions.Node, this.context, out hash);
            if (cached != null) return (ExpressionListSyntax)cached;

            var result = new ExpressionListSyntax(SyntaxKind.ExpressionList, expressions.Node, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public ParameterListSyntax ParameterList(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ParameterSyntax> parameters, UsingClauseSyntax? @using, SyntaxToken closeParenToken)
        {
#if DEBUG
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
#endif

            return new ParameterListSyntax(SyntaxKind.ParameterList, openParenToken, parameters.Node, @using, closeParenToken, this.context);
        }

        public ParameterSyntax Parameter(SyntaxToken identifier, SyntaxToken equalsToken, ExpressionSyntax defaultValue)
        {
#if DEBUG
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            switch (identifier.Kind)
            {
                case SyntaxKind.IdentifierToken:
                case SyntaxKind.DotDotDotToken: break;
                default: throw new ArgumentException(nameof(identifier));
            }
            if (equalsToken == null) throw new ArgumentNullException(nameof(equalsToken));
            if (equalsToken.Kind != SyntaxKind.EqualsToken) throw new ArgumentException(nameof(equalsToken));
            if (defaultValue == null) throw new ArgumentNullException(nameof(defaultValue));
#endif

            int hash;
            var cached = MoonScriptSyntaxNodeCache.TryGetNode((int)SyntaxKind.Parameter, identifier, equalsToken, defaultValue, this.context, out hash);
            if (cached != null) return (ParameterSyntax)cached;

            var result = new ParameterSyntax(SyntaxKind.Parameter, identifier, equalsToken, defaultValue, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public ArgumentListSyntax ArgumentList(SyntaxToken? exclamationToken, SyntaxToken? openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken? closeParenToken)
        {
#if DEBUG
            if (exclamationToken != null)
            {
                switch (exclamationToken.Kind)
                {
                    case SyntaxKind.ExclamationToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(exclamationToken));
                }
            }
            if (openParenToken != null)
            {
                switch (openParenToken.Kind)
                {
                    case SyntaxKind.OpenParenToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(openParenToken));
                }
            }
            if (closeParenToken != null)
            {
                switch (closeParenToken.Kind)
                {
                    case SyntaxKind.CloseParenToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(closeParenToken));
                }
            }
#endif

            return new ArgumentListSyntax(SyntaxKind.ArgumentList, exclamationToken, openParenToken, arguments.Node, closeParenToken, this.context);
        }

        public ArgumentSyntax Argument(ExpressionSyntax expression)
        {
#if DEBUG
            if (expression == null) throw new ArgumentNullException(nameof(expression));
#endif

            int hash;
            var cached = MoonScriptSyntaxNodeCache.TryGetNode((int)SyntaxKind.Argument, expression, this.context, out hash);
            if (cached != null) return (ArgumentSyntax)cached;

            var result = new ArgumentSyntax(SyntaxKind.Argument, expression, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public NameColonSyntax NameColon(IdentifierNameSyntax name, SyntaxToken colonToken)
        {
#if DEBUG
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (colonToken == null) throw new ArgumentNullException(nameof(colonToken));
            if (colonToken.Kind != SyntaxKind.ColonToken) throw new ArgumentException(nameof(colonToken));
#endif

            int hash;
            var cached = MoonScriptSyntaxNodeCache.TryGetNode((int)SyntaxKind.NameColon, name, colonToken, this.context, out hash);
            if (cached != null) return (NameColonSyntax)cached;

            var result = new NameColonSyntax(SyntaxKind.NameColon, name, colonToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public ColonNameSyntax ColonName(SyntaxToken colonToken, IdentifierNameSyntax name)
        {
#if DEBUG
            if (colonToken == null) throw new ArgumentNullException(nameof(colonToken));
            if (colonToken.Kind != SyntaxKind.ColonToken) throw new ArgumentException(nameof(colonToken));
            if (name == null) throw new ArgumentNullException(nameof(name));
#endif

            int hash;
            var cached = MoonScriptSyntaxNodeCache.TryGetNode((int)SyntaxKind.ColonName, colonToken, name, this.context, out hash);
            if (cached != null) return (ColonNameSyntax)cached;

            var result = new ColonNameSyntax(SyntaxKind.ColonName, colonToken, name, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public BackSlashNameSyntax BackSlashName(SyntaxToken backSlashToken, IdentifierNameSyntax name)
        {
#if DEBUG
            if (backSlashToken == null) throw new ArgumentNullException(nameof(backSlashToken));
            if (backSlashToken.Kind != SyntaxKind.BackSlashToken) throw new ArgumentException(nameof(backSlashToken));
            if (name == null) throw new ArgumentNullException(nameof(name));
#endif

            int hash;
            var cached = MoonScriptSyntaxNodeCache.TryGetNode((int)SyntaxKind.BackSlashName, backSlashToken, name, this.context, out hash);
            if (cached != null) return (BackSlashNameSyntax)cached;

            var result = new BackSlashNameSyntax(SyntaxKind.BackSlashName, backSlashToken, name, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public ImplicitSelfCallSyntax ImplicitSelfCall(ExpressionSyntax expression, BackSlashNameSyntax backSlashName)
        {
#if DEBUG
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (backSlashName == null) throw new ArgumentNullException(nameof(backSlashName));
#endif

            int hash;
            var cached = MoonScriptSyntaxNodeCache.TryGetNode((int)SyntaxKind.ImplicitSelfCall, expression, backSlashName, this.context, out hash);
            if (cached != null) return (ImplicitSelfCallSyntax)cached;

            var result = new ImplicitSelfCallSyntax(SyntaxKind.ImplicitSelfCall, expression, backSlashName, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public ImportNameSyntax ImportName(SyntaxToken? backSlashToken, IdentifierNameSyntax name)
        {
#if DEBUG
            if (backSlashToken != null)
            {
                switch (backSlashToken.Kind)
                {
                    case SyntaxKind.BackSlashToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(backSlashToken));
                }
            }
            if (name == null) throw new ArgumentNullException(nameof(name));
#endif

            int hash;
            var cached = MoonScriptSyntaxNodeCache.TryGetNode((int)SyntaxKind.ImportName, backSlashToken, name, this.context, out hash);
            if (cached != null) return (ImportNameSyntax)cached;

            var result = new ImportNameSyntax(SyntaxKind.ImportName, backSlashToken, name, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }
    }

    internal static partial class SyntaxFactory
    {

        public static IdentifierNameSyntax IdentifierName(SyntaxToken identifier)
        {
#if DEBUG
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            switch (identifier.Kind)
            {
                case SyntaxKind.IdentifierToken:
                case SyntaxKind.GlobalEnvironmentKeyword:
                case SyntaxKind.EnvironmentKeyword: break;
                default: throw new ArgumentException(nameof(identifier));
            }
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.IdentifierName, identifier, out hash);
            if (cached != null) return (IdentifierNameSyntax)cached;

            var result = new IdentifierNameSyntax(SyntaxKind.IdentifierName, identifier);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static LiteralExpressionSyntax LiteralExpression(SyntaxKind kind, SyntaxToken token)
        {
            switch (kind)
            {
                case SyntaxKind.NilLiteralExpression:
                case SyntaxKind.FalseLiteralExpression:
                case SyntaxKind.TrueLiteralExpression:
                case SyntaxKind.NumericLiteralExpression:
                case SyntaxKind.StringLiteralExpression:
                case SyntaxKind.VariousArgumentsExpression: break;
                default: throw new ArgumentException(nameof(kind));
            }
#if DEBUG
            if (token == null) throw new ArgumentNullException(nameof(token));
            switch (token.Kind)
            {
                case SyntaxKind.NilKeyword:
                case SyntaxKind.FalseKeyword:
                case SyntaxKind.TrueKeyword:
                case SyntaxKind.NumericLiteralToken:
                case SyntaxKind.StringLiteralToken:
                case SyntaxKind.MultiLineRawStringLiteralToken:
                case SyntaxKind.DotDotDotToken: break;
                default: throw new ArgumentException(nameof(token));
            }
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)kind, token, out hash);
            if (cached != null) return (LiteralExpressionSyntax)cached;

            var result = new LiteralExpressionSyntax(kind, token);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static SelfExpressionSyntax SelfExpression(SyntaxToken token)
        {
#if DEBUG
            if (token == null) throw new ArgumentNullException(nameof(token));
            if (token.Kind != SyntaxKind.CommercialAtToken) throw new ArgumentException(nameof(token));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.SelfExpression, token, out hash);
            if (cached != null) return (SelfExpressionSyntax)cached;

            var result = new SelfExpressionSyntax(SyntaxKind.SelfExpression, token);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static SuperExpressionSyntax SuperExpression(SyntaxToken token)
        {
#if DEBUG
            if (token == null) throw new ArgumentNullException(nameof(token));
            if (token.Kind != SyntaxKind.SuperKeyword) throw new ArgumentException(nameof(token));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.SuperExpression, token, out hash);
            if (cached != null) return (SuperExpressionSyntax)cached;

            var result = new SuperExpressionSyntax(SyntaxKind.SuperExpression, token);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static TypeExpressionSyntax TypeExpression(SyntaxToken token)
        {
#if DEBUG
            if (token == null) throw new ArgumentNullException(nameof(token));
            if (token.Kind != SyntaxKind.CommercialAtCommercialAtToken) throw new ArgumentException(nameof(token));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.TypeExpression, token, out hash);
            if (cached != null) return (TypeExpressionSyntax)cached;

            var result = new TypeExpressionSyntax(SyntaxKind.TypeExpression, token);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static ParenthesizedExpressionSyntax ParenthesizedExpression(SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
        {
#if DEBUG
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ParenthesizedExpression, openParenToken, expression, closeParenToken, out hash);
            if (cached != null) return (ParenthesizedExpressionSyntax)cached;

            var result = new ParenthesizedExpressionSyntax(SyntaxKind.ParenthesizedExpression, openParenToken, expression, closeParenToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static ClassExpressionSyntax ClassExpression(SyntaxToken classKeyword, IdentifierNameSyntax name, SyntaxToken extendsKeyword, IdentifierNameSyntax baseName, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<StatementSyntax> statements)
        {
#if DEBUG
            if (classKeyword == null) throw new ArgumentNullException(nameof(classKeyword));
            if (classKeyword.Kind != SyntaxKind.ClassKeyword) throw new ArgumentException(nameof(classKeyword));
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (extendsKeyword == null) throw new ArgumentNullException(nameof(extendsKeyword));
            if (extendsKeyword.Kind != SyntaxKind.ExtendsKeyword) throw new ArgumentException(nameof(extendsKeyword));
            if (baseName == null) throw new ArgumentNullException(nameof(baseName));
#endif

            return new ClassExpressionSyntax(SyntaxKind.ClassExpression, classKeyword, name, extendsKeyword, baseName, statements.Node);
        }

        public static AnomymousClassExpressionSyntax AnomymousClassExpression(SyntaxToken classKeyword, SyntaxToken extendsKeyword, IdentifierNameSyntax baseName, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<StatementSyntax> statements)
        {
#if DEBUG
            if (classKeyword == null) throw new ArgumentNullException(nameof(classKeyword));
            if (classKeyword.Kind != SyntaxKind.ClassKeyword) throw new ArgumentException(nameof(classKeyword));
            if (extendsKeyword == null) throw new ArgumentNullException(nameof(extendsKeyword));
            if (extendsKeyword.Kind != SyntaxKind.ExtendsKeyword) throw new ArgumentException(nameof(extendsKeyword));
            if (baseName == null) throw new ArgumentNullException(nameof(baseName));
#endif

            return new AnomymousClassExpressionSyntax(SyntaxKind.AnomymousClassExpression, classKeyword, extendsKeyword, baseName, statements.Node);
        }

        public static DoExpressionSyntax DoExpression(SyntaxToken doKeyword, BlockSyntax block)
        {
#if DEBUG
            if (doKeyword == null) throw new ArgumentNullException(nameof(doKeyword));
            if (doKeyword.Kind != SyntaxKind.DoKeyword) throw new ArgumentException(nameof(doKeyword));
            if (block == null) throw new ArgumentNullException(nameof(block));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.DoExpression, doKeyword, block, out hash);
            if (cached != null) return (DoExpressionSyntax)cached;

            var result = new DoExpressionSyntax(SyntaxKind.DoExpression, doKeyword, block);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static ForExpressionSyntax ForExpression(SyntaxToken forKeyword, IdentifierNameSyntax name, SyntaxToken equalsToken, ExpressionSyntax initial, SyntaxToken firstCommaToken, ExpressionSyntax limit, SyntaxToken secondCommaToken, ExpressionSyntax step, SyntaxToken? doKeyword, BlockSyntax block)
        {
#if DEBUG
            if (forKeyword == null) throw new ArgumentNullException(nameof(forKeyword));
            if (forKeyword.Kind != SyntaxKind.ForKeyword) throw new ArgumentException(nameof(forKeyword));
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (equalsToken == null) throw new ArgumentNullException(nameof(equalsToken));
            if (equalsToken.Kind != SyntaxKind.EqualsToken) throw new ArgumentException(nameof(equalsToken));
            if (initial == null) throw new ArgumentNullException(nameof(initial));
            if (firstCommaToken == null) throw new ArgumentNullException(nameof(firstCommaToken));
            if (firstCommaToken.Kind != SyntaxKind.CommaToken) throw new ArgumentException(nameof(firstCommaToken));
            if (limit == null) throw new ArgumentNullException(nameof(limit));
            if (secondCommaToken == null) throw new ArgumentNullException(nameof(secondCommaToken));
            if (secondCommaToken.Kind != SyntaxKind.CommaToken) throw new ArgumentException(nameof(secondCommaToken));
            if (step == null) throw new ArgumentNullException(nameof(step));
            if (doKeyword != null)
            {
                switch (doKeyword.Kind)
                {
                    case SyntaxKind.DoKeyword:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(doKeyword));
                }
            }
            if (block == null) throw new ArgumentNullException(nameof(block));
#endif

            return new ForExpressionSyntax(SyntaxKind.ForExpression, forKeyword, name, equalsToken, initial, firstCommaToken, limit, secondCommaToken, step, doKeyword, block);
        }

        public static ForInExpressionSyntax ForInExpression(SyntaxToken forKeyword, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<IdentifierNameSyntax> names, SyntaxToken inKeyword, ExpressionSyntax iteration, SyntaxToken? doKeyword, BlockSyntax block)
        {
#if DEBUG
            if (forKeyword == null) throw new ArgumentNullException(nameof(forKeyword));
            if (forKeyword.Kind != SyntaxKind.ForKeyword) throw new ArgumentException(nameof(forKeyword));
            if (inKeyword == null) throw new ArgumentNullException(nameof(inKeyword));
            if (inKeyword.Kind != SyntaxKind.InKeyword) throw new ArgumentException(nameof(inKeyword));
            if (iteration == null) throw new ArgumentNullException(nameof(iteration));
            if (doKeyword != null)
            {
                switch (doKeyword.Kind)
                {
                    case SyntaxKind.DoKeyword:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(doKeyword));
                }
            }
            if (block == null) throw new ArgumentNullException(nameof(block));
#endif

            return new ForInExpressionSyntax(SyntaxKind.ForInExpression, forKeyword, names.Node, inKeyword, iteration, doKeyword, block);
        }

        public static IfExpressionSyntax IfExpression(SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken? thenKeyword, BlockSyntax block, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ElseIfClauseSyntax> elseIfs, ElseClauseSyntax? @else)
        {
#if DEBUG
            if (ifKeyword == null) throw new ArgumentNullException(nameof(ifKeyword));
            if (ifKeyword.Kind != SyntaxKind.IfKeyword) throw new ArgumentException(nameof(ifKeyword));
            if (condition == null) throw new ArgumentNullException(nameof(condition));
            if (thenKeyword != null)
            {
                switch (thenKeyword.Kind)
                {
                    case SyntaxKind.ThenKeyword:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(thenKeyword));
                }
            }
            if (block == null) throw new ArgumentNullException(nameof(block));
#endif

            return new IfExpressionSyntax(SyntaxKind.IfExpression, ifKeyword, condition, thenKeyword, block, elseIfs.Node, @else);
        }

        public static ElseIfClauseSyntax ElseIfClause(SyntaxToken elseIfKeyword, ExpressionSyntax condition, SyntaxToken thenKeyword, BlockSyntax block)
        {
#if DEBUG
            if (elseIfKeyword == null) throw new ArgumentNullException(nameof(elseIfKeyword));
            if (elseIfKeyword.Kind != SyntaxKind.ElseIfKeyword) throw new ArgumentException(nameof(elseIfKeyword));
            if (condition == null) throw new ArgumentNullException(nameof(condition));
            if (thenKeyword == null) throw new ArgumentNullException(nameof(thenKeyword));
            if (thenKeyword.Kind != SyntaxKind.ThenKeyword) throw new ArgumentException(nameof(thenKeyword));
            if (block == null) throw new ArgumentNullException(nameof(block));
#endif

            return new ElseIfClauseSyntax(SyntaxKind.ElseIfClause, elseIfKeyword, condition, thenKeyword, block);
        }

        public static ElseClauseSyntax ElseClause(SyntaxToken elseKeyword, BlockSyntax block)
        {
#if DEBUG
            if (elseKeyword == null) throw new ArgumentNullException(nameof(elseKeyword));
            if (elseKeyword.Kind != SyntaxKind.ElseKeyword) throw new ArgumentException(nameof(elseKeyword));
            if (block == null) throw new ArgumentNullException(nameof(block));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ElseClause, elseKeyword, block, out hash);
            if (cached != null) return (ElseClauseSyntax)cached;

            var result = new ElseClauseSyntax(SyntaxKind.ElseClause, elseKeyword, block);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static SwitchExpressionSyntax SwitchExpression(ExpressionSyntax expression, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<WhenClauseSyntax> whens, ElseClauseSyntax @else)
        {
#if DEBUG
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (@else == null) throw new ArgumentNullException(nameof(@else));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.SwitchExpression, expression, whens.Node, @else, out hash);
            if (cached != null) return (SwitchExpressionSyntax)cached;

            var result = new SwitchExpressionSyntax(SyntaxKind.SwitchExpression, expression, whens.Node, @else);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static WhenClauseSyntax WhenClause(SyntaxToken whenKeyword, ExpressionListSyntax values, SyntaxToken? thenKeyword, BlockSyntax block)
        {
#if DEBUG
            if (whenKeyword == null) throw new ArgumentNullException(nameof(whenKeyword));
            if (whenKeyword.Kind != SyntaxKind.WhenKeyword) throw new ArgumentException(nameof(whenKeyword));
            if (values == null) throw new ArgumentNullException(nameof(values));
            if (thenKeyword != null)
            {
                switch (thenKeyword.Kind)
                {
                    case SyntaxKind.ThenKeyword:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(thenKeyword));
                }
            }
            if (block == null) throw new ArgumentNullException(nameof(block));
#endif

            return new WhenClauseSyntax(SyntaxKind.WhenClause, whenKeyword, values, thenKeyword, block);
        }

        public static UnlessExpressionSyntax UnlessExpression(SyntaxToken unlessKeyword, ExpressionSyntax condition, SyntaxToken? thenKeyword, BlockSyntax block)
        {
#if DEBUG
            if (unlessKeyword == null) throw new ArgumentNullException(nameof(unlessKeyword));
            if (unlessKeyword.Kind != SyntaxKind.UnlessKeyword) throw new ArgumentException(nameof(unlessKeyword));
            if (condition == null) throw new ArgumentNullException(nameof(condition));
            if (thenKeyword != null)
            {
                switch (thenKeyword.Kind)
                {
                    case SyntaxKind.ThenKeyword:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(thenKeyword));
                }
            }
            if (block == null) throw new ArgumentNullException(nameof(block));
#endif

            return new UnlessExpressionSyntax(SyntaxKind.UnlessExpression, unlessKeyword, condition, thenKeyword, block);
        }

        public static WhileExpressionSyntax WhileExpression(SyntaxToken whileKeyword, ExpressionSyntax condition, SyntaxToken? doKeyword, BlockSyntax block)
        {
#if DEBUG
            if (whileKeyword == null) throw new ArgumentNullException(nameof(whileKeyword));
            if (whileKeyword.Kind != SyntaxKind.WhileKeyword) throw new ArgumentException(nameof(whileKeyword));
            if (condition == null) throw new ArgumentNullException(nameof(condition));
            if (doKeyword != null)
            {
                switch (doKeyword.Kind)
                {
                    case SyntaxKind.DoKeyword:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(doKeyword));
                }
            }
            if (block == null) throw new ArgumentNullException(nameof(block));
#endif

            return new WhileExpressionSyntax(SyntaxKind.WhileExpression, whileKeyword, condition, doKeyword, block);
        }

        public static WithExpressionSyntax WithExpression(SyntaxToken withKeyword, ExpressionSyntax expression, BlockSyntax block)
        {
#if DEBUG
            if (withKeyword == null) throw new ArgumentNullException(nameof(withKeyword));
            if (withKeyword.Kind != SyntaxKind.WithKeyword) throw new ArgumentException(nameof(withKeyword));
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (block == null) throw new ArgumentNullException(nameof(block));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.WithExpression, withKeyword, expression, block, out hash);
            if (cached != null) return (WithExpressionSyntax)cached;

            var result = new WithExpressionSyntax(SyntaxKind.WithExpression, withKeyword, expression, block);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static ListComprehensionExpressionSyntax ListComprehensionExpression(SyntaxToken openBracketToken, ExpressionSyntax expression, BaseComprehensionClauseSyntax firstClause, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<BaseComprehensionClauseSyntax> restClauses, SyntaxToken closeBracketToken)
        {
#if DEBUG
            if (openBracketToken == null) throw new ArgumentNullException(nameof(openBracketToken));
            if (openBracketToken.Kind != SyntaxKind.OpenBracketToken) throw new ArgumentException(nameof(openBracketToken));
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (firstClause == null) throw new ArgumentNullException(nameof(firstClause));
            if (closeBracketToken == null) throw new ArgumentNullException(nameof(closeBracketToken));
            if (closeBracketToken.Kind != SyntaxKind.CloseBracketToken) throw new ArgumentException(nameof(closeBracketToken));
#endif

            return new ListComprehensionExpressionSyntax(SyntaxKind.ListComprehensionExpression, openBracketToken, expression, firstClause, restClauses.Node, closeBracketToken);
        }

        public static TableComprehensionExpressionSyntax TableComprehensionExpression(SyntaxToken openBraceToken, ExpressionSyntax expression, BaseComprehensionClauseSyntax firstClause, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<BaseComprehensionClauseSyntax> restClauses, SyntaxToken closeBraceToken)
        {
#if DEBUG
            if (openBraceToken == null) throw new ArgumentNullException(nameof(openBraceToken));
            if (openBraceToken.Kind != SyntaxKind.OpenBraceToken) throw new ArgumentException(nameof(openBraceToken));
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (firstClause == null) throw new ArgumentNullException(nameof(firstClause));
            if (closeBraceToken == null) throw new ArgumentNullException(nameof(closeBraceToken));
            if (closeBraceToken.Kind != SyntaxKind.CloseBraceToken) throw new ArgumentException(nameof(closeBraceToken));
#endif

            return new TableComprehensionExpressionSyntax(SyntaxKind.TableComprehensionExpression, openBraceToken, expression, firstClause, restClauses.Node, closeBraceToken);
        }

        public static ForComprehensionClauseSyntax ForComprehensionClause(SyntaxToken forKeyword, IdentifierNameSyntax name, SyntaxToken equalsToken, ExpressionSyntax initial, SyntaxToken firstCommaToken, ExpressionSyntax limit, SyntaxToken secondCommaToken, ExpressionSyntax step)
        {
#if DEBUG
            if (forKeyword == null) throw new ArgumentNullException(nameof(forKeyword));
            if (forKeyword.Kind != SyntaxKind.ForKeyword) throw new ArgumentException(nameof(forKeyword));
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (equalsToken == null) throw new ArgumentNullException(nameof(equalsToken));
            if (equalsToken.Kind != SyntaxKind.EqualsToken) throw new ArgumentException(nameof(equalsToken));
            if (initial == null) throw new ArgumentNullException(nameof(initial));
            if (firstCommaToken == null) throw new ArgumentNullException(nameof(firstCommaToken));
            if (firstCommaToken.Kind != SyntaxKind.CommaToken) throw new ArgumentException(nameof(firstCommaToken));
            if (limit == null) throw new ArgumentNullException(nameof(limit));
            if (secondCommaToken == null) throw new ArgumentNullException(nameof(secondCommaToken));
            if (secondCommaToken.Kind != SyntaxKind.CommaToken) throw new ArgumentException(nameof(secondCommaToken));
            if (step == null) throw new ArgumentNullException(nameof(step));
#endif

            return new ForComprehensionClauseSyntax(SyntaxKind.ForComprehensionClause, forKeyword, name, equalsToken, initial, firstCommaToken, limit, secondCommaToken, step);
        }

        public static ForInComprehensionClauseSyntax ForInComprehensionClause(SyntaxToken forKeyword, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<IdentifierNameSyntax> names, SyntaxToken inKeyword, ExpressionSyntax iteration)
        {
#if DEBUG
            if (forKeyword == null) throw new ArgumentNullException(nameof(forKeyword));
            if (forKeyword.Kind != SyntaxKind.ForKeyword) throw new ArgumentException(nameof(forKeyword));
            if (inKeyword == null) throw new ArgumentNullException(nameof(inKeyword));
            if (inKeyword.Kind != SyntaxKind.InKeyword) throw new ArgumentException(nameof(inKeyword));
            if (iteration == null) throw new ArgumentNullException(nameof(iteration));
#endif

            return new ForInComprehensionClauseSyntax(SyntaxKind.ForInComprehensionClause, forKeyword, names.Node, inKeyword, iteration);
        }

        public static WhenComprehensionClauseSyntax WhenComprehensionClause(SyntaxToken whenKeyword, ExpressionSyntax condition)
        {
#if DEBUG
            if (whenKeyword == null) throw new ArgumentNullException(nameof(whenKeyword));
            if (whenKeyword.Kind != SyntaxKind.WhenKeyword) throw new ArgumentException(nameof(whenKeyword));
            if (condition == null) throw new ArgumentNullException(nameof(condition));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.WhenComprehensionClause, whenKeyword, condition, out hash);
            if (cached != null) return (WhenComprehensionClauseSyntax)cached;

            var result = new WhenComprehensionClauseSyntax(SyntaxKind.WhenComprehensionClause, whenKeyword, condition);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static NumericallyIterateExpressionSyntax NumericallyIterateExpression(SyntaxToken asteriskToken, ExpressionSyntax expression)
        {
#if DEBUG
            if (asteriskToken == null) throw new ArgumentNullException(nameof(asteriskToken));
            if (asteriskToken.Kind != SyntaxKind.AsteriskToken) throw new ArgumentException(nameof(asteriskToken));
            if (expression == null) throw new ArgumentNullException(nameof(expression));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.NumericallyIterateExpression, asteriskToken, expression, out hash);
            if (cached != null) return (NumericallyIterateExpressionSyntax)cached;

            var result = new NumericallyIterateExpressionSyntax(SyntaxKind.NumericallyIterateExpression, asteriskToken, expression);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static SlicingExpressionSyntax SlicingExpression(ExpressionSyntax numericallyIterateExpression, SyntaxToken openBracketToken, ExpressionSyntax? initial, SyntaxToken firstCommaToken, ExpressionSyntax? limit, SyntaxToken secondCommaToken, ExpressionSyntax step, SyntaxToken closeBracketToken)
        {
#if DEBUG
            if (numericallyIterateExpression == null) throw new ArgumentNullException(nameof(numericallyIterateExpression));
            if (openBracketToken == null) throw new ArgumentNullException(nameof(openBracketToken));
            if (openBracketToken.Kind != SyntaxKind.OpenBracketToken) throw new ArgumentException(nameof(openBracketToken));
            if (firstCommaToken == null) throw new ArgumentNullException(nameof(firstCommaToken));
            if (firstCommaToken.Kind != SyntaxKind.CommaToken) throw new ArgumentException(nameof(firstCommaToken));
            if (secondCommaToken == null) throw new ArgumentNullException(nameof(secondCommaToken));
            if (secondCommaToken.Kind != SyntaxKind.CommaToken) throw new ArgumentException(nameof(secondCommaToken));
            if (step == null) throw new ArgumentNullException(nameof(step));
            if (closeBracketToken == null) throw new ArgumentNullException(nameof(closeBracketToken));
            if (closeBracketToken.Kind != SyntaxKind.CloseBracketToken) throw new ArgumentException(nameof(closeBracketToken));
#endif

            return new SlicingExpressionSyntax(SyntaxKind.SlicingExpression, numericallyIterateExpression, openBracketToken, initial, firstCommaToken, limit, secondCommaToken, step, closeBracketToken);
        }

        public static InvocationExpressionSyntax InvocationExpression(ExpressionSyntax? expression, ImplicitSelfCallSyntax? selfCall, ArgumentListSyntax argumentList)
        {
#if DEBUG
            if (argumentList == null) throw new ArgumentNullException(nameof(argumentList));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.InvocationExpression, expression, selfCall, argumentList, out hash);
            if (cached != null) return (InvocationExpressionSyntax)cached;

            var result = new InvocationExpressionSyntax(SyntaxKind.InvocationExpression, expression, selfCall, argumentList);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static LambdaExpressionSyntax LambdaExpression(ParameterListSyntax? parameters, SyntaxToken arrow, BlockSyntax block)
        {
#if DEBUG
            if (arrow == null) throw new ArgumentNullException(nameof(arrow));
            switch (arrow.Kind)
            {
                case SyntaxKind.MinusGreaterThanToken:
                case SyntaxKind.EqualsGreaterThanToken: break;
                default: throw new ArgumentException(nameof(arrow));
            }
            if (block == null) throw new ArgumentNullException(nameof(block));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.LambdaExpression, parameters, arrow, block, out hash);
            if (cached != null) return (LambdaExpressionSyntax)cached;

            var result = new LambdaExpressionSyntax(SyntaxKind.LambdaExpression, parameters, arrow, block);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static BinaryExpressionSyntax BinaryExpression(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)
        {
            switch (kind)
            {
                case SyntaxKind.AdditionExpression:
                case SyntaxKind.SubtractionExpression:
                case SyntaxKind.MultiplicationExpression:
                case SyntaxKind.DivisionExpression:
                case SyntaxKind.FloorDivisionExpression:
                case SyntaxKind.ExponentiationExpression:
                case SyntaxKind.ModuloExpression:
                case SyntaxKind.BitwiseAndExpression:
                case SyntaxKind.BitwiseExclusiveOrExpression:
                case SyntaxKind.BitwiseOrExpression:
                case SyntaxKind.BitwiseLeftShiftExpression:
                case SyntaxKind.BitwiseRightShiftExpression:
                case SyntaxKind.ConcatenationExpression:
                case SyntaxKind.LessThanExpression:
                case SyntaxKind.LessThanOrEqualExpression:
                case SyntaxKind.GreaterThanExpression:
                case SyntaxKind.GreaterThanOrEqualExpression:
                case SyntaxKind.EqualExpression:
                case SyntaxKind.NotEqualExpression:
                case SyntaxKind.AndExpression:
                case SyntaxKind.OrExpression: break;
                default: throw new ArgumentException(nameof(kind));
            }
#if DEBUG
            if (left == null) throw new ArgumentNullException(nameof(left));
            if (operatorToken == null) throw new ArgumentNullException(nameof(operatorToken));
            switch (operatorToken.Kind)
            {
                case SyntaxKind.PlusToken:
                case SyntaxKind.MinusToken:
                case SyntaxKind.AsteriskToken:
                case SyntaxKind.SlashToken:
                case SyntaxKind.SlashSlashToken:
                case SyntaxKind.CaretToken:
                case SyntaxKind.PersentToken:
                case SyntaxKind.AmpersandToken:
                case SyntaxKind.TildeToken:
                case SyntaxKind.BarToken:
                case SyntaxKind.LessThanLessThanToken:
                case SyntaxKind.GreaterThanGreaterThanToken:
                case SyntaxKind.DotDotToken:
                case SyntaxKind.LessThanToken:
                case SyntaxKind.LessThanEqualsToken:
                case SyntaxKind.GreaterThanToken:
                case SyntaxKind.GreaterThanEqualsToken:
                case SyntaxKind.EqualsEqualsToken:
                case SyntaxKind.TildeEqualsToken:
                case SyntaxKind.AndKeyword:
                case SyntaxKind.OrKeyword: break;
                default: throw new ArgumentException(nameof(operatorToken));
            }
            if (right == null) throw new ArgumentNullException(nameof(right));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)kind, left, operatorToken, right, out hash);
            if (cached != null) return (BinaryExpressionSyntax)cached;

            var result = new BinaryExpressionSyntax(kind, left, operatorToken, right);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static UnaryExpressionSyntax UnaryExpression(SyntaxKind kind, SyntaxToken operatorToken, ExpressionSyntax operand)
        {
            switch (kind)
            {
                case SyntaxKind.UnaryMinusExpression:
                case SyntaxKind.LogicalNotExpression:
                case SyntaxKind.LengthExpression:
                case SyntaxKind.BitwiseNotExpression: break;
                default: throw new ArgumentException(nameof(kind));
            }
#if DEBUG
            if (operatorToken == null) throw new ArgumentNullException(nameof(operatorToken));
            switch (operatorToken.Kind)
            {
                case SyntaxKind.MinusToken:
                case SyntaxKind.NotKeyword:
                case SyntaxKind.HashToken:
                case SyntaxKind.TildeToken: break;
                default: throw new ArgumentException(nameof(operatorToken));
            }
            if (operand == null) throw new ArgumentNullException(nameof(operand));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)kind, operatorToken, operand, out hash);
            if (cached != null) return (UnaryExpressionSyntax)cached;

            var result = new UnaryExpressionSyntax(kind, operatorToken, operand);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static SimpleAssignmentExpressionSyntax SimpleAssignmentExpression(ExpressionListSyntax left, SyntaxToken equalsToken, ExpressionListSyntax right)
        {
#if DEBUG
            if (left == null) throw new ArgumentNullException(nameof(left));
            if (equalsToken == null) throw new ArgumentNullException(nameof(equalsToken));
            if (equalsToken.Kind != SyntaxKind.EqualsToken) throw new ArgumentException(nameof(equalsToken));
            if (right == null) throw new ArgumentNullException(nameof(right));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.SimpleAssignmentExpression, left, equalsToken, right, out hash);
            if (cached != null) return (SimpleAssignmentExpressionSyntax)cached;

            var result = new SimpleAssignmentExpressionSyntax(SyntaxKind.SimpleAssignmentExpression, left, equalsToken, right);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static UpdateAssignmentExpressionSyntax UpdateAssignmentExpression(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionListSyntax right)
        {
            switch (kind)
            {
                case SyntaxKind.AdditionAssignmentExpression:
                case SyntaxKind.SubtractionAssignmentExpression:
                case SyntaxKind.MultiplicationAssignmentExpression:
                case SyntaxKind.DivisionAssignmentExpression:
                case SyntaxKind.FloorDivisionAssignmentExpression:
                case SyntaxKind.ExponentiationAssignmentExpression:
                case SyntaxKind.ModuloAssignmentExpression:
                case SyntaxKind.BitwiseAndAssignmentExpression:
                case SyntaxKind.BitwiseExclusiveOrAssignmentExpression:
                case SyntaxKind.BitwiseOrAssignmentExpression:
                case SyntaxKind.BitwiseLeftShiftAssignmentExpression:
                case SyntaxKind.BitwiseRightShiftAssignmentExpression:
                case SyntaxKind.ConcatenationAssignmentExpression:
                case SyntaxKind.AndAssignmentExpression:
                case SyntaxKind.OrAssignmentExpression: break;
                default: throw new ArgumentException(nameof(kind));
            }
#if DEBUG
            if (left == null) throw new ArgumentNullException(nameof(left));
            if (operatorToken == null) throw new ArgumentNullException(nameof(operatorToken));
            switch (operatorToken.Kind)
            {
                case SyntaxKind.PlusEqualsToken:
                case SyntaxKind.MinusEqualsToken:
                case SyntaxKind.AsteriskEqualsToken:
                case SyntaxKind.SlashEqualsToken:
                case SyntaxKind.SlashSlashEqualsToken:
                case SyntaxKind.CaretEqualsToken:
                case SyntaxKind.PersentEqualsToken:
                case SyntaxKind.AmpersandEqualsToken:
                case SyntaxKind.BarEqualsToken:
                case SyntaxKind.LessThanLessThanEqualsToken:
                case SyntaxKind.GreaterThanGreaterThanEqualsToken:
                case SyntaxKind.DotDotEqualsToken:
                case SyntaxKind.AndEqualsToken:
                case SyntaxKind.OrEqualsToken: break;
                default: throw new ArgumentException(nameof(operatorToken));
            }
            if (right == null) throw new ArgumentNullException(nameof(right));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)kind, left, operatorToken, right, out hash);
            if (cached != null) return (UpdateAssignmentExpressionSyntax)cached;

            var result = new UpdateAssignmentExpressionSyntax(kind, left, operatorToken, right);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static ExpressionStatementSyntax ExpressionStatement(ExpressionSyntax expression, LineDecoratorSyntax? lineDecorator)
        {
#if DEBUG
            if (expression == null) throw new ArgumentNullException(nameof(expression));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ExpressionStatement, expression, lineDecorator, out hash);
            if (cached != null) return (ExpressionStatementSyntax)cached;

            var result = new ExpressionStatementSyntax(SyntaxKind.ExpressionStatement, expression, lineDecorator);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static BreakStatementSyntax BreakStatement(SyntaxToken breakKeyword, ConditionalLineDecoratorSyntax? lineDecorator)
        {
#if DEBUG
            if (breakKeyword == null) throw new ArgumentNullException(nameof(breakKeyword));
            if (breakKeyword.Kind != SyntaxKind.BreakKeyword) throw new ArgumentException(nameof(breakKeyword));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.BreakStatement, breakKeyword, lineDecorator, out hash);
            if (cached != null) return (BreakStatementSyntax)cached;

            var result = new BreakStatementSyntax(SyntaxKind.BreakStatement, breakKeyword, lineDecorator);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static ClassStatementSyntax ClassStatement(SyntaxToken classKeyword, IdentifierNameSyntax name, SyntaxToken extendsKeyword, IdentifierNameSyntax baseName, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<StatementSyntax> statements)
        {
#if DEBUG
            if (classKeyword == null) throw new ArgumentNullException(nameof(classKeyword));
            if (classKeyword.Kind != SyntaxKind.ClassKeyword) throw new ArgumentException(nameof(classKeyword));
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (extendsKeyword == null) throw new ArgumentNullException(nameof(extendsKeyword));
            if (extendsKeyword.Kind != SyntaxKind.ExtendsKeyword) throw new ArgumentException(nameof(extendsKeyword));
            if (baseName == null) throw new ArgumentNullException(nameof(baseName));
#endif

            return new ClassStatementSyntax(SyntaxKind.ClassStatement, classKeyword, name, extendsKeyword, baseName, statements.Node);
        }

        public static MemberStatementSyntax MemberStatement(SyntaxToken? commercialAtToken, NameColonSyntax nameColon, ExpressionSyntax expression)
        {
#if DEBUG
            if (commercialAtToken != null)
            {
                switch (commercialAtToken.Kind)
                {
                    case SyntaxKind.CommercialAtToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(commercialAtToken));
                }
            }
            if (nameColon == null) throw new ArgumentNullException(nameof(nameColon));
            if (expression == null) throw new ArgumentNullException(nameof(expression));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.MemberStatement, commercialAtToken, nameColon, expression, out hash);
            if (cached != null) return (MemberStatementSyntax)cached;

            var result = new MemberStatementSyntax(SyntaxKind.MemberStatement, commercialAtToken, nameColon, expression);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static ContinueStatementSyntax ContinueStatement(SyntaxToken breakKeyword, ConditionalLineDecoratorSyntax? lineDecorator)
        {
#if DEBUG
            if (breakKeyword == null) throw new ArgumentNullException(nameof(breakKeyword));
            if (breakKeyword.Kind != SyntaxKind.BreakKeyword) throw new ArgumentException(nameof(breakKeyword));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ContinueStatement, breakKeyword, lineDecorator, out hash);
            if (cached != null) return (ContinueStatementSyntax)cached;

            var result = new ContinueStatementSyntax(SyntaxKind.ContinueStatement, breakKeyword, lineDecorator);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static DoStatementSyntax DoStatement(SyntaxToken doKeyword, BlockSyntax block)
        {
#if DEBUG
            if (doKeyword == null) throw new ArgumentNullException(nameof(doKeyword));
            if (doKeyword.Kind != SyntaxKind.DoKeyword) throw new ArgumentException(nameof(doKeyword));
            if (block == null) throw new ArgumentNullException(nameof(block));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.DoStatement, doKeyword, block, out hash);
            if (cached != null) return (DoStatementSyntax)cached;

            var result = new DoStatementSyntax(SyntaxKind.DoStatement, doKeyword, block);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static ExportStatementSyntax ExportStatement(SyntaxToken exportKeyword, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<IdentifierNameSyntax> names, SimpleAssignmentExpressionSyntax? simpleAssignmentExpression, SyntaxToken? asteriskToken, SyntaxToken? caretToken)
        {
#if DEBUG
            if (exportKeyword == null) throw new ArgumentNullException(nameof(exportKeyword));
            if (exportKeyword.Kind != SyntaxKind.ExportKeyword) throw new ArgumentException(nameof(exportKeyword));
            if (asteriskToken != null)
            {
                switch (asteriskToken.Kind)
                {
                    case SyntaxKind.AsteriskToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(asteriskToken));
                }
            }
            if (caretToken != null)
            {
                switch (caretToken.Kind)
                {
                    case SyntaxKind.CaretToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(caretToken));
                }
            }
#endif

            return new ExportStatementSyntax(SyntaxKind.ExportStatement, exportKeyword, names.Node, simpleAssignmentExpression, asteriskToken, caretToken);
        }

        public static ForStatementSyntax ForStatement(SyntaxToken forKeyword, IdentifierNameSyntax name, SyntaxToken equalsToken, ExpressionSyntax initial, SyntaxToken firstCommaToken, ExpressionSyntax limit, SyntaxToken secondCommaToken, ExpressionSyntax step, SyntaxToken? doKeyword, BlockSyntax block)
        {
#if DEBUG
            if (forKeyword == null) throw new ArgumentNullException(nameof(forKeyword));
            if (forKeyword.Kind != SyntaxKind.ForKeyword) throw new ArgumentException(nameof(forKeyword));
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (equalsToken == null) throw new ArgumentNullException(nameof(equalsToken));
            if (equalsToken.Kind != SyntaxKind.EqualsToken) throw new ArgumentException(nameof(equalsToken));
            if (initial == null) throw new ArgumentNullException(nameof(initial));
            if (firstCommaToken == null) throw new ArgumentNullException(nameof(firstCommaToken));
            if (firstCommaToken.Kind != SyntaxKind.CommaToken) throw new ArgumentException(nameof(firstCommaToken));
            if (limit == null) throw new ArgumentNullException(nameof(limit));
            if (secondCommaToken == null) throw new ArgumentNullException(nameof(secondCommaToken));
            if (secondCommaToken.Kind != SyntaxKind.CommaToken) throw new ArgumentException(nameof(secondCommaToken));
            if (step == null) throw new ArgumentNullException(nameof(step));
            if (doKeyword != null)
            {
                switch (doKeyword.Kind)
                {
                    case SyntaxKind.DoKeyword:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(doKeyword));
                }
            }
            if (block == null) throw new ArgumentNullException(nameof(block));
#endif

            return new ForStatementSyntax(SyntaxKind.ForStatement, forKeyword, name, equalsToken, initial, firstCommaToken, limit, secondCommaToken, step, doKeyword, block);
        }

        public static ForInStatementSyntax ForInStatement(SyntaxToken forKeyword, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<IdentifierNameSyntax> names, SyntaxToken inKeyword, ExpressionSyntax iteration, SyntaxToken? doKeyword, BlockSyntax block)
        {
#if DEBUG
            if (forKeyword == null) throw new ArgumentNullException(nameof(forKeyword));
            if (forKeyword.Kind != SyntaxKind.ForKeyword) throw new ArgumentException(nameof(forKeyword));
            if (inKeyword == null) throw new ArgumentNullException(nameof(inKeyword));
            if (inKeyword.Kind != SyntaxKind.InKeyword) throw new ArgumentException(nameof(inKeyword));
            if (iteration == null) throw new ArgumentNullException(nameof(iteration));
            if (doKeyword != null)
            {
                switch (doKeyword.Kind)
                {
                    case SyntaxKind.DoKeyword:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(doKeyword));
                }
            }
            if (block == null) throw new ArgumentNullException(nameof(block));
#endif

            return new ForInStatementSyntax(SyntaxKind.ForInStatement, forKeyword, names.Node, inKeyword, iteration, doKeyword, block);
        }

        public static IfStatementSyntax IfStatement(ExpressionSyntax condition, SyntaxToken? thenKeyword, BlockSyntax block, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ElseIfClauseSyntax> elseIfs, ElseClauseSyntax? @else)
        {
#if DEBUG
            if (condition == null) throw new ArgumentNullException(nameof(condition));
            if (thenKeyword != null)
            {
                switch (thenKeyword.Kind)
                {
                    case SyntaxKind.ThenKeyword:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(thenKeyword));
                }
            }
            if (block == null) throw new ArgumentNullException(nameof(block));
#endif

            return new IfStatementSyntax(SyntaxKind.IfStatement, condition, thenKeyword, block, elseIfs.Node, @else);
        }

        public static ImportStatementSytnax ImportStatementSytnax(SyntaxToken importKeyword, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ImportNameSyntax> names, SyntaxToken fromKeyword, IdentifierNameSyntax from)
        {
#if DEBUG
            if (importKeyword == null) throw new ArgumentNullException(nameof(importKeyword));
            if (importKeyword.Kind != SyntaxKind.ImportKeyword) throw new ArgumentException(nameof(importKeyword));
            if (fromKeyword == null) throw new ArgumentNullException(nameof(fromKeyword));
            if (fromKeyword.Kind != SyntaxKind.FromKeyword) throw new ArgumentException(nameof(fromKeyword));
            if (from == null) throw new ArgumentNullException(nameof(from));
#endif

            return new ImportStatementSytnax(SyntaxKind.ImportStatement, importKeyword, names.Node, fromKeyword, from);
        }

        public static LocalStatementSyntax LocalStatement(SyntaxToken localKeyword, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<IdentifierNameSyntax> names, SimpleAssignmentExpressionSyntax? simpleAssignmentExpression, SyntaxToken? asteriskToken)
        {
#if DEBUG
            if (localKeyword == null) throw new ArgumentNullException(nameof(localKeyword));
            if (localKeyword.Kind != SyntaxKind.LocalKeyword) throw new ArgumentException(nameof(localKeyword));
            if (asteriskToken != null)
            {
                switch (asteriskToken.Kind)
                {
                    case SyntaxKind.AsteriskToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(asteriskToken));
                }
            }
#endif

            return new LocalStatementSyntax(SyntaxKind.LocalStatement, localKeyword, names.Node, simpleAssignmentExpression, asteriskToken);
        }

        public static SwitchStatementSyntax SwitchStatement(ExpressionSyntax expression, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<WhenClauseSyntax> whens, ElseClauseSyntax @else)
        {
#if DEBUG
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (@else == null) throw new ArgumentNullException(nameof(@else));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.SwitchStatement, expression, whens.Node, @else, out hash);
            if (cached != null) return (SwitchStatementSyntax)cached;

            var result = new SwitchStatementSyntax(SyntaxKind.SwitchStatement, expression, whens.Node, @else);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static UnlessStatementSyntax UnlessStatement(SyntaxToken unlessKeyword, ExpressionSyntax condition, SyntaxToken? thenKeyword, BlockSyntax block)
        {
#if DEBUG
            if (unlessKeyword == null) throw new ArgumentNullException(nameof(unlessKeyword));
            if (unlessKeyword.Kind != SyntaxKind.UnlessKeyword) throw new ArgumentException(nameof(unlessKeyword));
            if (condition == null) throw new ArgumentNullException(nameof(condition));
            if (thenKeyword != null)
            {
                switch (thenKeyword.Kind)
                {
                    case SyntaxKind.ThenKeyword:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(thenKeyword));
                }
            }
            if (block == null) throw new ArgumentNullException(nameof(block));
#endif

            return new UnlessStatementSyntax(SyntaxKind.UnlessStatement, unlessKeyword, condition, thenKeyword, block);
        }

        public static UsingClauseSyntax UsingClause(SyntaxToken usingKeyword, SyntaxToken? nilKeyword, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<IdentifierNameSyntax> names)
        {
#if DEBUG
            if (usingKeyword == null) throw new ArgumentNullException(nameof(usingKeyword));
            if (usingKeyword.Kind != SyntaxKind.UsingKeyword) throw new ArgumentException(nameof(usingKeyword));
            if (nilKeyword != null)
            {
                switch (nilKeyword.Kind)
                {
                    case SyntaxKind.NilKeyword:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(nilKeyword));
                }
            }
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.UsingClause, usingKeyword, nilKeyword, names.Node, out hash);
            if (cached != null) return (UsingClauseSyntax)cached;

            var result = new UsingClauseSyntax(SyntaxKind.UsingClause, usingKeyword, nilKeyword, names.Node);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static WhileStatementSyntax WhileStatement(SyntaxToken whileKeyword, ExpressionSyntax condition, SyntaxToken? doKeyword, BlockSyntax block)
        {
#if DEBUG
            if (whileKeyword == null) throw new ArgumentNullException(nameof(whileKeyword));
            if (whileKeyword.Kind != SyntaxKind.WhileKeyword) throw new ArgumentException(nameof(whileKeyword));
            if (condition == null) throw new ArgumentNullException(nameof(condition));
            if (doKeyword != null)
            {
                switch (doKeyword.Kind)
                {
                    case SyntaxKind.DoKeyword:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(doKeyword));
                }
            }
            if (block == null) throw new ArgumentNullException(nameof(block));
#endif

            return new WhileStatementSyntax(SyntaxKind.WhileStatement, whileKeyword, condition, doKeyword, block);
        }

        public static WithStatementSyntax WithStatement(SyntaxToken withKeyword, ExpressionSyntax expression, BlockSyntax block)
        {
#if DEBUG
            if (withKeyword == null) throw new ArgumentNullException(nameof(withKeyword));
            if (withKeyword.Kind != SyntaxKind.WithKeyword) throw new ArgumentException(nameof(withKeyword));
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (block == null) throw new ArgumentNullException(nameof(block));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.WithStatement, withKeyword, expression, block, out hash);
            if (cached != null) return (WithStatementSyntax)cached;

            var result = new WithStatementSyntax(SyntaxKind.WithStatement, withKeyword, expression, block);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static DestructuringAssignmentStatementSyntax DestructuringAssignmentStatement(DestructuringUnitSyntax unit, SyntaxToken equalsToken, ExpressionSyntax expression)
        {
#if DEBUG
            if (unit == null) throw new ArgumentNullException(nameof(unit));
            if (equalsToken == null) throw new ArgumentNullException(nameof(equalsToken));
            if (equalsToken.Kind != SyntaxKind.EqualsToken) throw new ArgumentException(nameof(equalsToken));
            if (expression == null) throw new ArgumentNullException(nameof(expression));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.DestructuringAssignmentStatement, unit, equalsToken, expression, out hash);
            if (cached != null) return (DestructuringAssignmentStatementSyntax)cached;

            var result = new DestructuringAssignmentStatementSyntax(SyntaxKind.DestructuringAssignmentStatement, unit, equalsToken, expression);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static DestructuringIdentifierNameSyntax DestructuringIdentifierName(IdentifierNameSyntax name)
        {
#if DEBUG
            if (name == null) throw new ArgumentNullException(nameof(name));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.DestructuringIdentifierName, name, out hash);
            if (cached != null) return (DestructuringIdentifierNameSyntax)cached;

            var result = new DestructuringIdentifierNameSyntax(SyntaxKind.DestructuringIdentifierName, name);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static DestructuringListSyntax DestructuringList(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<DestructuringUnitSyntax> units)
        {
#if DEBUG
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.DestructuringList, units.Node, out hash);
            if (cached != null) return (DestructuringListSyntax)cached;

            var result = new DestructuringListSyntax(SyntaxKind.DestructuringList, units.Node);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static DestructuringFieldSyntax DestructuringField(DestructuringUnitSyntax? unit, NameColonSyntax? nameColon, DestructuringUnitSyntax? namedUnit, ColonNameSyntax? colonName)
        {
#if DEBUG
#endif

            return new DestructuringFieldSyntax(SyntaxKind.DestructuringField, unit, nameColon, namedUnit, colonName);
        }

        public static DestructuringTableSyntax DestructuringTable(SyntaxToken? openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<DestructuringFieldSyntax> fields, SyntaxToken? closeBraceToken)
        {
#if DEBUG
            if (openBraceToken != null)
            {
                switch (openBraceToken.Kind)
                {
                    case SyntaxKind.OpenBraceToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(openBraceToken));
                }
            }
            if (closeBraceToken != null)
            {
                switch (closeBraceToken.Kind)
                {
                    case SyntaxKind.CloseBraceToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(closeBraceToken));
                }
            }
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.DestructuringList, openBraceToken, fields.Node, closeBraceToken, out hash);
            if (cached != null) return (DestructuringTableSyntax)cached;

            var result = new DestructuringTableSyntax(SyntaxKind.DestructuringList, openBraceToken, fields.Node, closeBraceToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static ForLineDecoratorSyntax ForLineDecorator(SyntaxToken forKeyword, IdentifierNameSyntax name, SyntaxToken equalsToken, ExpressionSyntax initial, SyntaxToken firstCommaToken, ExpressionSyntax limit, SyntaxToken secondCommaToken, ExpressionSyntax step)
        {
#if DEBUG
            if (forKeyword == null) throw new ArgumentNullException(nameof(forKeyword));
            if (forKeyword.Kind != SyntaxKind.ForKeyword) throw new ArgumentException(nameof(forKeyword));
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (equalsToken == null) throw new ArgumentNullException(nameof(equalsToken));
            if (equalsToken.Kind != SyntaxKind.EqualsToken) throw new ArgumentException(nameof(equalsToken));
            if (initial == null) throw new ArgumentNullException(nameof(initial));
            if (firstCommaToken == null) throw new ArgumentNullException(nameof(firstCommaToken));
            if (firstCommaToken.Kind != SyntaxKind.CommaToken) throw new ArgumentException(nameof(firstCommaToken));
            if (limit == null) throw new ArgumentNullException(nameof(limit));
            if (secondCommaToken == null) throw new ArgumentNullException(nameof(secondCommaToken));
            if (secondCommaToken.Kind != SyntaxKind.CommaToken) throw new ArgumentException(nameof(secondCommaToken));
            if (step == null) throw new ArgumentNullException(nameof(step));
#endif

            return new ForLineDecoratorSyntax(SyntaxKind.ForLineDecorator, forKeyword, name, equalsToken, initial, firstCommaToken, limit, secondCommaToken, step);
        }

        public static ForInLineDecoratorSyntax ForInLineDecorator(SyntaxToken forKeyword, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<IdentifierNameSyntax> names, SyntaxToken inKeyword, ExpressionSyntax iteration)
        {
#if DEBUG
            if (forKeyword == null) throw new ArgumentNullException(nameof(forKeyword));
            if (forKeyword.Kind != SyntaxKind.ForKeyword) throw new ArgumentException(nameof(forKeyword));
            if (inKeyword == null) throw new ArgumentNullException(nameof(inKeyword));
            if (inKeyword.Kind != SyntaxKind.InKeyword) throw new ArgumentException(nameof(inKeyword));
            if (iteration == null) throw new ArgumentNullException(nameof(iteration));
#endif

            return new ForInLineDecoratorSyntax(SyntaxKind.ForInLineDecorator, forKeyword, names.Node, inKeyword, iteration);
        }

        public static IfLineDecoratorSyntax IfLineDecorator(SyntaxToken ifKeyword, ExpressionSyntax condition)
        {
#if DEBUG
            if (ifKeyword == null) throw new ArgumentNullException(nameof(ifKeyword));
            if (ifKeyword.Kind != SyntaxKind.IfKeyword) throw new ArgumentException(nameof(ifKeyword));
            if (condition == null) throw new ArgumentNullException(nameof(condition));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.IfLineDecorator, ifKeyword, condition, out hash);
            if (cached != null) return (IfLineDecoratorSyntax)cached;

            var result = new IfLineDecoratorSyntax(SyntaxKind.IfLineDecorator, ifKeyword, condition);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static UnlessLineDecoratorSyntax UnlessLineDecorator(SyntaxToken unlessKeyword, ExpressionSyntax condition)
        {
#if DEBUG
            if (unlessKeyword == null) throw new ArgumentNullException(nameof(unlessKeyword));
            if (unlessKeyword.Kind != SyntaxKind.UnlessKeyword) throw new ArgumentException(nameof(unlessKeyword));
            if (condition == null) throw new ArgumentNullException(nameof(condition));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.UnlessLineDecorator, unlessKeyword, condition, out hash);
            if (cached != null) return (UnlessLineDecoratorSyntax)cached;

            var result = new UnlessLineDecoratorSyntax(SyntaxKind.UnlessLineDecorator, unlessKeyword, condition);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static WhileLineDecoratorSyntax WhileLineDecorator(SyntaxToken whileKeyword, ExpressionSyntax condition)
        {
#if DEBUG
            if (whileKeyword == null) throw new ArgumentNullException(nameof(whileKeyword));
            if (whileKeyword.Kind != SyntaxKind.WhileKeyword) throw new ArgumentException(nameof(whileKeyword));
            if (condition == null) throw new ArgumentNullException(nameof(condition));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.WhileLineDecorator, whileKeyword, condition, out hash);
            if (cached != null) return (WhileLineDecoratorSyntax)cached;

            var result = new WhileLineDecoratorSyntax(SyntaxKind.WhileLineDecorator, whileKeyword, condition);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static ChunkSyntax Chunk(BlockSyntax block, SyntaxToken endOfFileToken)
        {
#if DEBUG
            if (block == null) throw new ArgumentNullException(nameof(block));
            if (endOfFileToken == null) throw new ArgumentNullException(nameof(endOfFileToken));
            if (endOfFileToken.Kind != SyntaxKind.EndOfFileToken) throw new ArgumentException(nameof(endOfFileToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.Chunk, block, endOfFileToken, out hash);
            if (cached != null) return (ChunkSyntax)cached;

            var result = new ChunkSyntax(SyntaxKind.Chunk, block, endOfFileToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static BlockSyntax Block(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<StatementSyntax> statements)
        {
#if DEBUG
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.Block, statements.Node, out hash);
            if (cached != null) return (BlockSyntax)cached;

            var result = new BlockSyntax(SyntaxKind.Block, statements.Node);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static SkippedTokensTriviaSyntax SkippedTokensTrivia(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> tokens)
        {
#if DEBUG
#endif

            return new SkippedTokensTriviaSyntax(SyntaxKind.SkippedTokensTrivia, tokens.Node);
        }

        public static ExpressionListSyntax ExpressionList(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> expressions)
        {
#if DEBUG
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ExpressionList, expressions.Node, out hash);
            if (cached != null) return (ExpressionListSyntax)cached;

            var result = new ExpressionListSyntax(SyntaxKind.ExpressionList, expressions.Node);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static ParameterListSyntax ParameterList(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ParameterSyntax> parameters, UsingClauseSyntax? @using, SyntaxToken closeParenToken)
        {
#if DEBUG
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
#endif

            return new ParameterListSyntax(SyntaxKind.ParameterList, openParenToken, parameters.Node, @using, closeParenToken);
        }

        public static ParameterSyntax Parameter(SyntaxToken identifier, SyntaxToken equalsToken, ExpressionSyntax defaultValue)
        {
#if DEBUG
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            switch (identifier.Kind)
            {
                case SyntaxKind.IdentifierToken:
                case SyntaxKind.DotDotDotToken: break;
                default: throw new ArgumentException(nameof(identifier));
            }
            if (equalsToken == null) throw new ArgumentNullException(nameof(equalsToken));
            if (equalsToken.Kind != SyntaxKind.EqualsToken) throw new ArgumentException(nameof(equalsToken));
            if (defaultValue == null) throw new ArgumentNullException(nameof(defaultValue));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.Parameter, identifier, equalsToken, defaultValue, out hash);
            if (cached != null) return (ParameterSyntax)cached;

            var result = new ParameterSyntax(SyntaxKind.Parameter, identifier, equalsToken, defaultValue);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static ArgumentListSyntax ArgumentList(SyntaxToken? exclamationToken, SyntaxToken? openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken? closeParenToken)
        {
#if DEBUG
            if (exclamationToken != null)
            {
                switch (exclamationToken.Kind)
                {
                    case SyntaxKind.ExclamationToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(exclamationToken));
                }
            }
            if (openParenToken != null)
            {
                switch (openParenToken.Kind)
                {
                    case SyntaxKind.OpenParenToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(openParenToken));
                }
            }
            if (closeParenToken != null)
            {
                switch (closeParenToken.Kind)
                {
                    case SyntaxKind.CloseParenToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(closeParenToken));
                }
            }
#endif

            return new ArgumentListSyntax(SyntaxKind.ArgumentList, exclamationToken, openParenToken, arguments.Node, closeParenToken);
        }

        public static ArgumentSyntax Argument(ExpressionSyntax expression)
        {
#if DEBUG
            if (expression == null) throw new ArgumentNullException(nameof(expression));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.Argument, expression, out hash);
            if (cached != null) return (ArgumentSyntax)cached;

            var result = new ArgumentSyntax(SyntaxKind.Argument, expression);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static NameColonSyntax NameColon(IdentifierNameSyntax name, SyntaxToken colonToken)
        {
#if DEBUG
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (colonToken == null) throw new ArgumentNullException(nameof(colonToken));
            if (colonToken.Kind != SyntaxKind.ColonToken) throw new ArgumentException(nameof(colonToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.NameColon, name, colonToken, out hash);
            if (cached != null) return (NameColonSyntax)cached;

            var result = new NameColonSyntax(SyntaxKind.NameColon, name, colonToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static ColonNameSyntax ColonName(SyntaxToken colonToken, IdentifierNameSyntax name)
        {
#if DEBUG
            if (colonToken == null) throw new ArgumentNullException(nameof(colonToken));
            if (colonToken.Kind != SyntaxKind.ColonToken) throw new ArgumentException(nameof(colonToken));
            if (name == null) throw new ArgumentNullException(nameof(name));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ColonName, colonToken, name, out hash);
            if (cached != null) return (ColonNameSyntax)cached;

            var result = new ColonNameSyntax(SyntaxKind.ColonName, colonToken, name);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static BackSlashNameSyntax BackSlashName(SyntaxToken backSlashToken, IdentifierNameSyntax name)
        {
#if DEBUG
            if (backSlashToken == null) throw new ArgumentNullException(nameof(backSlashToken));
            if (backSlashToken.Kind != SyntaxKind.BackSlashToken) throw new ArgumentException(nameof(backSlashToken));
            if (name == null) throw new ArgumentNullException(nameof(name));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.BackSlashName, backSlashToken, name, out hash);
            if (cached != null) return (BackSlashNameSyntax)cached;

            var result = new BackSlashNameSyntax(SyntaxKind.BackSlashName, backSlashToken, name);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static ImplicitSelfCallSyntax ImplicitSelfCall(ExpressionSyntax expression, BackSlashNameSyntax backSlashName)
        {
#if DEBUG
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (backSlashName == null) throw new ArgumentNullException(nameof(backSlashName));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ImplicitSelfCall, expression, backSlashName, out hash);
            if (cached != null) return (ImplicitSelfCallSyntax)cached;

            var result = new ImplicitSelfCallSyntax(SyntaxKind.ImplicitSelfCall, expression, backSlashName);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static ImportNameSyntax ImportName(SyntaxToken? backSlashToken, IdentifierNameSyntax name)
        {
#if DEBUG
            if (backSlashToken != null)
            {
                switch (backSlashToken.Kind)
                {
                    case SyntaxKind.BackSlashToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(backSlashToken));
                }
            }
            if (name == null) throw new ArgumentNullException(nameof(name));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ImportName, backSlashToken, name, out hash);
            if (cached != null) return (ImportNameSyntax)cached;

            var result = new ImportNameSyntax(SyntaxKind.ImportName, backSlashToken, name);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        internal static IEnumerable<Type> GetNodeTypes()
            => new Type[]
            {
                typeof(IdentifierNameSyntax),
                typeof(LiteralExpressionSyntax),
                typeof(SelfExpressionSyntax),
                typeof(SuperExpressionSyntax),
                typeof(TypeExpressionSyntax),
                typeof(ParenthesizedExpressionSyntax),
                typeof(ClassExpressionSyntax),
                typeof(AnomymousClassExpressionSyntax),
                typeof(DoExpressionSyntax),
                typeof(ForExpressionSyntax),
                typeof(ForInExpressionSyntax),
                typeof(IfExpressionSyntax),
                typeof(ElseIfClauseSyntax),
                typeof(ElseClauseSyntax),
                typeof(SwitchExpressionSyntax),
                typeof(WhenClauseSyntax),
                typeof(UnlessExpressionSyntax),
                typeof(WhileExpressionSyntax),
                typeof(WithExpressionSyntax),
                typeof(ListComprehensionExpressionSyntax),
                typeof(TableComprehensionExpressionSyntax),
                typeof(ForComprehensionClauseSyntax),
                typeof(ForInComprehensionClauseSyntax),
                typeof(WhenComprehensionClauseSyntax),
                typeof(NumericallyIterateExpressionSyntax),
                typeof(SlicingExpressionSyntax),
                typeof(InvocationExpressionSyntax),
                typeof(LambdaExpressionSyntax),
                typeof(BinaryExpressionSyntax),
                typeof(UnaryExpressionSyntax),
                typeof(SimpleAssignmentExpressionSyntax),
                typeof(UpdateAssignmentExpressionSyntax),
                typeof(ExpressionStatementSyntax),
                typeof(BreakStatementSyntax),
                typeof(ClassStatementSyntax),
                typeof(MemberStatementSyntax),
                typeof(ContinueStatementSyntax),
                typeof(DoStatementSyntax),
                typeof(ExportStatementSyntax),
                typeof(ForStatementSyntax),
                typeof(ForInStatementSyntax),
                typeof(IfStatementSyntax),
                typeof(ImportStatementSytnax),
                typeof(LocalStatementSyntax),
                typeof(SwitchStatementSyntax),
                typeof(UnlessStatementSyntax),
                typeof(UsingClauseSyntax),
                typeof(WhileStatementSyntax),
                typeof(WithStatementSyntax),
                typeof(DestructuringAssignmentStatementSyntax),
                typeof(DestructuringIdentifierNameSyntax),
                typeof(DestructuringListSyntax),
                typeof(DestructuringFieldSyntax),
                typeof(DestructuringTableSyntax),
                typeof(ForLineDecoratorSyntax),
                typeof(ForInLineDecoratorSyntax),
                typeof(IfLineDecoratorSyntax),
                typeof(UnlessLineDecoratorSyntax),
                typeof(WhileLineDecoratorSyntax),
                typeof(ChunkSyntax),
                typeof(BlockSyntax),
                typeof(SkippedTokensTriviaSyntax),
                typeof(ExpressionListSyntax),
                typeof(ParameterListSyntax),
                typeof(ParameterSyntax),
                typeof(ArgumentListSyntax),
                typeof(ArgumentSyntax),
                typeof(NameColonSyntax),
                typeof(ColonNameSyntax),
                typeof(BackSlashNameSyntax),
                typeof(ImplicitSelfCallSyntax),
                typeof(ImportNameSyntax),
            };
    }
}
