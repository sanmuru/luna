// <auto-generated />

#nullable enable

using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Syntax.InternalSyntax;
using SamLu.CodeAnalysis.MoonScript;
using Roslyn.Utilities;

namespace SamLu.CodeAnalysis.MoonScript.Syntax.InternalSyntax
{


    /// <summary>提供表示名称语法节点继承用的父类，此类必须被继承。</summary>
    internal abstract partial class NameSyntax : MoonScriptSyntaxNode
    {
        internal NameSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal NameSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected NameSyntax(ObjectReader reader)
          : base(reader)
        {
        }
    }

    /// <summary>提供表示简单名称语法节点继承用的父类，此类必须被继承。</summary>
    internal abstract partial class SimpleNameSyntax : NameSyntax
    {
        internal SimpleNameSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal SimpleNameSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected SimpleNameSyntax(ObjectReader reader)
          : base(reader)
        {
        }

        /// <summary>表示简单名称的语法标志。</summary>
        public abstract SyntaxToken Identifier { get; }
    }

    /// <summary>Class which represents the syntax node for identifier name.</summary>
    internal sealed partial class IdentifierNameSyntax : SimpleNameSyntax
    {
        internal readonly SyntaxToken identifier;

        internal IdentifierNameSyntax(SyntaxKind kind, SyntaxToken identifier, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
        }

        internal IdentifierNameSyntax(SyntaxKind kind, SyntaxToken identifier, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
        }

        internal IdentifierNameSyntax(SyntaxKind kind, SyntaxToken identifier)
          : base(kind)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
        }

        /// <summary>SyntaxToken representing the keyword for the kind of the identifier name.</summary>
        public override SyntaxToken Identifier => this.identifier;

        internal override GreenNode? GetSlot(int index)
            => index == 0 ? this.identifier : null;

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.IdentifierNameSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitIdentifierName(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitIdentifierName(this);

        public IdentifierNameSyntax Update(SyntaxToken identifier)
        {
            if (identifier != this.Identifier)
            {
                var newNode = SyntaxFactory.IdentifierName(identifier);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new IdentifierNameSyntax(this.Kind, this.identifier, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new IdentifierNameSyntax(this.Kind, this.identifier, GetDiagnostics(), annotations);

        internal IdentifierNameSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 1;
            var identifier = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.identifier);
        }

        static IdentifierNameSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(IdentifierNameSyntax), r => new IdentifierNameSyntax(r));
        }
    }

    /// <summary>Provides the base class from which the classes that represent expression syntax nodes are derived. This is an abstract class.</summary>
    internal abstract partial class ExpressionSyntax : MoonScriptSyntaxNode
    {
        internal ExpressionSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal ExpressionSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected ExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
        }
    }

    /// <summary>Class which represents the syntax node for a literal expression.</summary>
    internal sealed partial class LiteralExpressionSyntax : ExpressionSyntax
    {
        internal readonly SyntaxToken token;

        internal LiteralExpressionSyntax(SyntaxKind kind, SyntaxToken token, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(token);
            this.token = token;
        }

        internal LiteralExpressionSyntax(SyntaxKind kind, SyntaxToken token, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(token);
            this.token = token;
        }

        internal LiteralExpressionSyntax(SyntaxKind kind, SyntaxToken token)
          : base(kind)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(token);
            this.token = token;
        }

        /// <summary>SyntaxToken representing the keyword corresponding to the kind of the literal expression.</summary>
        public SyntaxToken Token => this.token;

        internal override GreenNode? GetSlot(int index)
            => index == 0 ? this.token : null;

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.LiteralExpressionSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitLiteralExpression(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitLiteralExpression(this);

        public LiteralExpressionSyntax Update(SyntaxToken token)
        {
            if (token != this.Token)
            {
                var newNode = SyntaxFactory.LiteralExpression(this.Kind, token);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new LiteralExpressionSyntax(this.Kind, this.token, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new LiteralExpressionSyntax(this.Kind, this.token, GetDiagnostics(), annotations);

        internal LiteralExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 1;
            var token = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(token);
            this.token = token;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.token);
        }

        static LiteralExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(LiteralExpressionSyntax), r => new LiteralExpressionSyntax(r));
        }
    }

    internal abstract partial class BaseInstanceExpressionSyntax : ExpressionSyntax
    {
        internal BaseInstanceExpressionSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal BaseInstanceExpressionSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected BaseInstanceExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
        }

        public abstract SyntaxToken Token { get; }
    }

    internal sealed partial class SelfExpressionSyntax : BaseInstanceExpressionSyntax
    {
        internal readonly SyntaxToken token;

        internal SelfExpressionSyntax(SyntaxKind kind, SyntaxToken token, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(token);
            this.token = token;
        }

        internal SelfExpressionSyntax(SyntaxKind kind, SyntaxToken token, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(token);
            this.token = token;
        }

        internal SelfExpressionSyntax(SyntaxKind kind, SyntaxToken token)
          : base(kind)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(token);
            this.token = token;
        }

        public override SyntaxToken Token => this.token;

        internal override GreenNode? GetSlot(int index)
            => index == 0 ? this.token : null;

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.SelfExpressionSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitSelfExpression(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitSelfExpression(this);

        public SelfExpressionSyntax Update(SyntaxToken token)
        {
            if (token != this.Token)
            {
                var newNode = SyntaxFactory.SelfExpression(token);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new SelfExpressionSyntax(this.Kind, this.token, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new SelfExpressionSyntax(this.Kind, this.token, GetDiagnostics(), annotations);

        internal SelfExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 1;
            var token = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(token);
            this.token = token;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.token);
        }

        static SelfExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(SelfExpressionSyntax), r => new SelfExpressionSyntax(r));
        }
    }

    internal sealed partial class SuperExpressionSyntax : BaseInstanceExpressionSyntax
    {
        internal readonly SyntaxToken token;

        internal SuperExpressionSyntax(SyntaxKind kind, SyntaxToken token, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(token);
            this.token = token;
        }

        internal SuperExpressionSyntax(SyntaxKind kind, SyntaxToken token, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(token);
            this.token = token;
        }

        internal SuperExpressionSyntax(SyntaxKind kind, SyntaxToken token)
          : base(kind)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(token);
            this.token = token;
        }

        public override SyntaxToken Token => this.token;

        internal override GreenNode? GetSlot(int index)
            => index == 0 ? this.token : null;

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.SuperExpressionSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitSuperExpression(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitSuperExpression(this);

        public SuperExpressionSyntax Update(SyntaxToken token)
        {
            if (token != this.Token)
            {
                var newNode = SyntaxFactory.SuperExpression(token);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new SuperExpressionSyntax(this.Kind, this.token, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new SuperExpressionSyntax(this.Kind, this.token, GetDiagnostics(), annotations);

        internal SuperExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 1;
            var token = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(token);
            this.token = token;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.token);
        }

        static SuperExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(SuperExpressionSyntax), r => new SuperExpressionSyntax(r));
        }
    }

    internal sealed partial class TypeExpressionSyntax : BaseInstanceExpressionSyntax
    {
        internal readonly SyntaxToken token;

        internal TypeExpressionSyntax(SyntaxKind kind, SyntaxToken token, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(token);
            this.token = token;
        }

        internal TypeExpressionSyntax(SyntaxKind kind, SyntaxToken token, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(token);
            this.token = token;
        }

        internal TypeExpressionSyntax(SyntaxKind kind, SyntaxToken token)
          : base(kind)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(token);
            this.token = token;
        }

        public override SyntaxToken Token => this.token;

        internal override GreenNode? GetSlot(int index)
            => index == 0 ? this.token : null;

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.TypeExpressionSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitTypeExpression(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitTypeExpression(this);

        public TypeExpressionSyntax Update(SyntaxToken token)
        {
            if (token != this.Token)
            {
                var newNode = SyntaxFactory.TypeExpression(token);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new TypeExpressionSyntax(this.Kind, this.token, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new TypeExpressionSyntax(this.Kind, this.token, GetDiagnostics(), annotations);

        internal TypeExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 1;
            var token = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(token);
            this.token = token;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.token);
        }

        static TypeExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(TypeExpressionSyntax), r => new TypeExpressionSyntax(r));
        }
    }

    /// <summary>Class which represents the syntax node for parenthesized expression.</summary>
    internal sealed partial class ParenthesizedExpressionSyntax : ExpressionSyntax
    {
        internal readonly SyntaxToken openParenToken;
        internal readonly ExpressionSyntax expression;
        internal readonly SyntaxToken closeParenToken;

        internal ParenthesizedExpressionSyntax(SyntaxKind kind, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal ParenthesizedExpressionSyntax(SyntaxKind kind, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal ParenthesizedExpressionSyntax(SyntaxKind kind, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        /// <summary>SyntaxToken representing the open parenthesis.</summary>
        public SyntaxToken OpenParenToken => this.openParenToken;
        /// <summary>ExpressionSyntax node representing the expression enclosed within the parenthesis.</summary>
        public ExpressionSyntax Expression => this.expression;
        /// <summary>SyntaxToken representing the close parenthesis.</summary>
        public SyntaxToken CloseParenToken => this.closeParenToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.openParenToken,
                1 => this.expression,
                2 => this.closeParenToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.ParenthesizedExpressionSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitParenthesizedExpression(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitParenthesizedExpression(this);

        public ParenthesizedExpressionSyntax Update(SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
        {
            if (openParenToken != this.OpenParenToken || expression != this.Expression || closeParenToken != this.CloseParenToken)
            {
                var newNode = SyntaxFactory.ParenthesizedExpression(openParenToken, expression, closeParenToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ParenthesizedExpressionSyntax(this.Kind, this.openParenToken, this.expression, this.closeParenToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ParenthesizedExpressionSyntax(this.Kind, this.openParenToken, this.expression, this.closeParenToken, GetDiagnostics(), annotations);

        internal ParenthesizedExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var openParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            var expression = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(expression);
            this.expression = expression;
            var closeParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.openParenToken);
            writer.WriteValue(this.expression);
            writer.WriteValue(this.closeParenToken);
        }

        static ParenthesizedExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ParenthesizedExpressionSyntax), r => new ParenthesizedExpressionSyntax(r));
        }
    }

    internal sealed partial class ClassExpressionSyntax : ExpressionSyntax
    {
        internal readonly SyntaxToken classKeyword;
        internal readonly IdentifierNameSyntax name;
        internal readonly SyntaxToken extendsKeyword;
        internal readonly IdentifierNameSyntax baseName;

        internal ClassExpressionSyntax(SyntaxKind kind, SyntaxToken classKeyword, IdentifierNameSyntax name, SyntaxToken extendsKeyword, IdentifierNameSyntax baseName, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(classKeyword);
            this.classKeyword = classKeyword;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(extendsKeyword);
            this.extendsKeyword = extendsKeyword;
            this.AdjustFlagsAndWidth(baseName);
            this.baseName = baseName;
        }

        internal ClassExpressionSyntax(SyntaxKind kind, SyntaxToken classKeyword, IdentifierNameSyntax name, SyntaxToken extendsKeyword, IdentifierNameSyntax baseName, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(classKeyword);
            this.classKeyword = classKeyword;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(extendsKeyword);
            this.extendsKeyword = extendsKeyword;
            this.AdjustFlagsAndWidth(baseName);
            this.baseName = baseName;
        }

        internal ClassExpressionSyntax(SyntaxKind kind, SyntaxToken classKeyword, IdentifierNameSyntax name, SyntaxToken extendsKeyword, IdentifierNameSyntax baseName)
          : base(kind)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(classKeyword);
            this.classKeyword = classKeyword;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(extendsKeyword);
            this.extendsKeyword = extendsKeyword;
            this.AdjustFlagsAndWidth(baseName);
            this.baseName = baseName;
        }

        public SyntaxToken ClassKeyword => this.classKeyword;
        public IdentifierNameSyntax Name => this.name;
        public SyntaxToken ExtendsKeyword => this.extendsKeyword;
        public IdentifierNameSyntax BaseName => this.baseName;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.classKeyword,
                1 => this.name,
                2 => this.extendsKeyword,
                3 => this.baseName,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.ClassExpressionSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitClassExpression(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitClassExpression(this);

        public ClassExpressionSyntax Update(SyntaxToken classKeyword, IdentifierNameSyntax name, SyntaxToken extendsKeyword, IdentifierNameSyntax baseName)
        {
            if (classKeyword != this.ClassKeyword || name != this.Name || extendsKeyword != this.ExtendsKeyword || baseName != this.BaseName)
            {
                var newNode = SyntaxFactory.ClassExpression(classKeyword, name, extendsKeyword, baseName);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ClassExpressionSyntax(this.Kind, this.classKeyword, this.name, this.extendsKeyword, this.baseName, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ClassExpressionSyntax(this.Kind, this.classKeyword, this.name, this.extendsKeyword, this.baseName, GetDiagnostics(), annotations);

        internal ClassExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var classKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(classKeyword);
            this.classKeyword = classKeyword;
            var name = (IdentifierNameSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(name);
            this.name = name;
            var extendsKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(extendsKeyword);
            this.extendsKeyword = extendsKeyword;
            var baseName = (IdentifierNameSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(baseName);
            this.baseName = baseName;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.classKeyword);
            writer.WriteValue(this.name);
            writer.WriteValue(this.extendsKeyword);
            writer.WriteValue(this.baseName);
        }

        static ClassExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ClassExpressionSyntax), r => new ClassExpressionSyntax(r));
        }
    }

    internal sealed partial class AnomymousClassExpressionSyntax : ExpressionSyntax
    {
        internal readonly SyntaxToken classKeyword;
        internal readonly SyntaxToken extendsKeyword;
        internal readonly IdentifierNameSyntax baseName;

        internal AnomymousClassExpressionSyntax(SyntaxKind kind, SyntaxToken classKeyword, SyntaxToken extendsKeyword, IdentifierNameSyntax baseName, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(classKeyword);
            this.classKeyword = classKeyword;
            this.AdjustFlagsAndWidth(extendsKeyword);
            this.extendsKeyword = extendsKeyword;
            this.AdjustFlagsAndWidth(baseName);
            this.baseName = baseName;
        }

        internal AnomymousClassExpressionSyntax(SyntaxKind kind, SyntaxToken classKeyword, SyntaxToken extendsKeyword, IdentifierNameSyntax baseName, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(classKeyword);
            this.classKeyword = classKeyword;
            this.AdjustFlagsAndWidth(extendsKeyword);
            this.extendsKeyword = extendsKeyword;
            this.AdjustFlagsAndWidth(baseName);
            this.baseName = baseName;
        }

        internal AnomymousClassExpressionSyntax(SyntaxKind kind, SyntaxToken classKeyword, SyntaxToken extendsKeyword, IdentifierNameSyntax baseName)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(classKeyword);
            this.classKeyword = classKeyword;
            this.AdjustFlagsAndWidth(extendsKeyword);
            this.extendsKeyword = extendsKeyword;
            this.AdjustFlagsAndWidth(baseName);
            this.baseName = baseName;
        }

        public SyntaxToken ClassKeyword => this.classKeyword;
        public SyntaxToken ExtendsKeyword => this.extendsKeyword;
        public IdentifierNameSyntax BaseName => this.baseName;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.classKeyword,
                1 => this.extendsKeyword,
                2 => this.baseName,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.AnomymousClassExpressionSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitAnomymousClassExpression(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitAnomymousClassExpression(this);

        public AnomymousClassExpressionSyntax Update(SyntaxToken classKeyword, SyntaxToken extendsKeyword, IdentifierNameSyntax baseName)
        {
            if (classKeyword != this.ClassKeyword || extendsKeyword != this.ExtendsKeyword || baseName != this.BaseName)
            {
                var newNode = SyntaxFactory.AnomymousClassExpression(classKeyword, extendsKeyword, baseName);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new AnomymousClassExpressionSyntax(this.Kind, this.classKeyword, this.extendsKeyword, this.baseName, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new AnomymousClassExpressionSyntax(this.Kind, this.classKeyword, this.extendsKeyword, this.baseName, GetDiagnostics(), annotations);

        internal AnomymousClassExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var classKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(classKeyword);
            this.classKeyword = classKeyword;
            var extendsKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(extendsKeyword);
            this.extendsKeyword = extendsKeyword;
            var baseName = (IdentifierNameSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(baseName);
            this.baseName = baseName;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.classKeyword);
            writer.WriteValue(this.extendsKeyword);
            writer.WriteValue(this.baseName);
        }

        static AnomymousClassExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(AnomymousClassExpressionSyntax), r => new AnomymousClassExpressionSyntax(r));
        }
    }

    internal sealed partial class DoExpressionSyntax : ExpressionSyntax
    {
        internal readonly SyntaxToken doKeyword;
        internal readonly BlockSyntax block;

        internal DoExpressionSyntax(SyntaxKind kind, SyntaxToken doKeyword, BlockSyntax block, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(doKeyword);
            this.doKeyword = doKeyword;
            this.AdjustFlagsAndWidth(block);
            this.block = block;
        }

        internal DoExpressionSyntax(SyntaxKind kind, SyntaxToken doKeyword, BlockSyntax block, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(doKeyword);
            this.doKeyword = doKeyword;
            this.AdjustFlagsAndWidth(block);
            this.block = block;
        }

        internal DoExpressionSyntax(SyntaxKind kind, SyntaxToken doKeyword, BlockSyntax block)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(doKeyword);
            this.doKeyword = doKeyword;
            this.AdjustFlagsAndWidth(block);
            this.block = block;
        }

        public SyntaxToken DoKeyword => this.doKeyword;
        public BlockSyntax Block => this.block;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.doKeyword,
                1 => this.block,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.DoExpressionSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitDoExpression(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitDoExpression(this);

        public DoExpressionSyntax Update(SyntaxToken doKeyword, BlockSyntax block)
        {
            if (doKeyword != this.DoKeyword || block != this.Block)
            {
                var newNode = SyntaxFactory.DoExpression(doKeyword, block);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new DoExpressionSyntax(this.Kind, this.doKeyword, this.block, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new DoExpressionSyntax(this.Kind, this.doKeyword, this.block, GetDiagnostics(), annotations);

        internal DoExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var doKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(doKeyword);
            this.doKeyword = doKeyword;
            var block = (BlockSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(block);
            this.block = block;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.doKeyword);
            writer.WriteValue(this.block);
        }

        static DoExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(DoExpressionSyntax), r => new DoExpressionSyntax(r));
        }
    }

    internal sealed partial class ForExpressionSyntax : ExpressionSyntax
    {
        internal readonly SyntaxToken forKeyword;
        internal readonly IdentifierNameSyntax name;
        internal readonly SyntaxToken equalsToken;
        internal readonly ExpressionSyntax initial;
        internal readonly SyntaxToken firstCommaToken;
        internal readonly ExpressionSyntax limit;
        internal readonly SyntaxToken secondCommaToken;
        internal readonly ExpressionSyntax step;
        internal readonly BlockSyntax block;

        internal ForExpressionSyntax(SyntaxKind kind, SyntaxToken forKeyword, IdentifierNameSyntax name, SyntaxToken equalsToken, ExpressionSyntax initial, SyntaxToken firstCommaToken, ExpressionSyntax limit, SyntaxToken secondCommaToken, ExpressionSyntax step, BlockSyntax block, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 9;
            this.AdjustFlagsAndWidth(forKeyword);
            this.forKeyword = forKeyword;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            this.AdjustFlagsAndWidth(initial);
            this.initial = initial;
            this.AdjustFlagsAndWidth(firstCommaToken);
            this.firstCommaToken = firstCommaToken;
            this.AdjustFlagsAndWidth(limit);
            this.limit = limit;
            this.AdjustFlagsAndWidth(secondCommaToken);
            this.secondCommaToken = secondCommaToken;
            this.AdjustFlagsAndWidth(step);
            this.step = step;
            this.AdjustFlagsAndWidth(block);
            this.block = block;
        }

        internal ForExpressionSyntax(SyntaxKind kind, SyntaxToken forKeyword, IdentifierNameSyntax name, SyntaxToken equalsToken, ExpressionSyntax initial, SyntaxToken firstCommaToken, ExpressionSyntax limit, SyntaxToken secondCommaToken, ExpressionSyntax step, BlockSyntax block, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 9;
            this.AdjustFlagsAndWidth(forKeyword);
            this.forKeyword = forKeyword;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            this.AdjustFlagsAndWidth(initial);
            this.initial = initial;
            this.AdjustFlagsAndWidth(firstCommaToken);
            this.firstCommaToken = firstCommaToken;
            this.AdjustFlagsAndWidth(limit);
            this.limit = limit;
            this.AdjustFlagsAndWidth(secondCommaToken);
            this.secondCommaToken = secondCommaToken;
            this.AdjustFlagsAndWidth(step);
            this.step = step;
            this.AdjustFlagsAndWidth(block);
            this.block = block;
        }

        internal ForExpressionSyntax(SyntaxKind kind, SyntaxToken forKeyword, IdentifierNameSyntax name, SyntaxToken equalsToken, ExpressionSyntax initial, SyntaxToken firstCommaToken, ExpressionSyntax limit, SyntaxToken secondCommaToken, ExpressionSyntax step, BlockSyntax block)
          : base(kind)
        {
            this.SlotCount = 9;
            this.AdjustFlagsAndWidth(forKeyword);
            this.forKeyword = forKeyword;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            this.AdjustFlagsAndWidth(initial);
            this.initial = initial;
            this.AdjustFlagsAndWidth(firstCommaToken);
            this.firstCommaToken = firstCommaToken;
            this.AdjustFlagsAndWidth(limit);
            this.limit = limit;
            this.AdjustFlagsAndWidth(secondCommaToken);
            this.secondCommaToken = secondCommaToken;
            this.AdjustFlagsAndWidth(step);
            this.step = step;
            this.AdjustFlagsAndWidth(block);
            this.block = block;
        }

        public SyntaxToken ForKeyword => this.forKeyword;
        public IdentifierNameSyntax Name => this.name;
        public SyntaxToken EqualsToken => this.equalsToken;
        public ExpressionSyntax Initial => this.initial;
        public SyntaxToken FirstCommaToken => this.firstCommaToken;
        public ExpressionSyntax Limit => this.limit;
        public SyntaxToken SecondCommaToken => this.secondCommaToken;
        public ExpressionSyntax Step => this.step;
        public BlockSyntax Block => this.block;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.forKeyword,
                1 => this.name,
                2 => this.equalsToken,
                3 => this.initial,
                4 => this.firstCommaToken,
                5 => this.limit,
                6 => this.secondCommaToken,
                7 => this.step,
                8 => this.block,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.ForExpressionSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitForExpression(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitForExpression(this);

        public ForExpressionSyntax Update(SyntaxToken forKeyword, IdentifierNameSyntax name, SyntaxToken equalsToken, ExpressionSyntax initial, SyntaxToken firstCommaToken, ExpressionSyntax limit, SyntaxToken secondCommaToken, ExpressionSyntax step, BlockSyntax block)
        {
            if (forKeyword != this.ForKeyword || name != this.Name || equalsToken != this.EqualsToken || initial != this.Initial || firstCommaToken != this.FirstCommaToken || limit != this.Limit || secondCommaToken != this.SecondCommaToken || step != this.Step || block != this.Block)
            {
                var newNode = SyntaxFactory.ForExpression(forKeyword, name, equalsToken, initial, firstCommaToken, limit, secondCommaToken, step, block);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ForExpressionSyntax(this.Kind, this.forKeyword, this.name, this.equalsToken, this.initial, this.firstCommaToken, this.limit, this.secondCommaToken, this.step, this.block, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ForExpressionSyntax(this.Kind, this.forKeyword, this.name, this.equalsToken, this.initial, this.firstCommaToken, this.limit, this.secondCommaToken, this.step, this.block, GetDiagnostics(), annotations);

        internal ForExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 9;
            var forKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(forKeyword);
            this.forKeyword = forKeyword;
            var name = (IdentifierNameSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(name);
            this.name = name;
            var equalsToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            var initial = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(initial);
            this.initial = initial;
            var firstCommaToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(firstCommaToken);
            this.firstCommaToken = firstCommaToken;
            var limit = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(limit);
            this.limit = limit;
            var secondCommaToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(secondCommaToken);
            this.secondCommaToken = secondCommaToken;
            var step = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(step);
            this.step = step;
            var block = (BlockSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(block);
            this.block = block;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.forKeyword);
            writer.WriteValue(this.name);
            writer.WriteValue(this.equalsToken);
            writer.WriteValue(this.initial);
            writer.WriteValue(this.firstCommaToken);
            writer.WriteValue(this.limit);
            writer.WriteValue(this.secondCommaToken);
            writer.WriteValue(this.step);
            writer.WriteValue(this.block);
        }

        static ForExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ForExpressionSyntax), r => new ForExpressionSyntax(r));
        }
    }

    internal sealed partial class ForInExpressionSyntax : ExpressionSyntax
    {
        internal readonly SyntaxToken forKeyword;
        internal readonly GreenNode? names;
        internal readonly SyntaxToken inKeyword;
        internal readonly ExpressionSyntax iteration;
        internal readonly BlockSyntax block;

        internal ForInExpressionSyntax(SyntaxKind kind, SyntaxToken forKeyword, GreenNode? names, SyntaxToken inKeyword, ExpressionSyntax iteration, BlockSyntax block, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(forKeyword);
            this.forKeyword = forKeyword;
            if (names != null)
            {
                this.AdjustFlagsAndWidth(names);
                this.names = names;
            }
            this.AdjustFlagsAndWidth(inKeyword);
            this.inKeyword = inKeyword;
            this.AdjustFlagsAndWidth(iteration);
            this.iteration = iteration;
            this.AdjustFlagsAndWidth(block);
            this.block = block;
        }

        internal ForInExpressionSyntax(SyntaxKind kind, SyntaxToken forKeyword, GreenNode? names, SyntaxToken inKeyword, ExpressionSyntax iteration, BlockSyntax block, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(forKeyword);
            this.forKeyword = forKeyword;
            if (names != null)
            {
                this.AdjustFlagsAndWidth(names);
                this.names = names;
            }
            this.AdjustFlagsAndWidth(inKeyword);
            this.inKeyword = inKeyword;
            this.AdjustFlagsAndWidth(iteration);
            this.iteration = iteration;
            this.AdjustFlagsAndWidth(block);
            this.block = block;
        }

        internal ForInExpressionSyntax(SyntaxKind kind, SyntaxToken forKeyword, GreenNode? names, SyntaxToken inKeyword, ExpressionSyntax iteration, BlockSyntax block)
          : base(kind)
        {
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(forKeyword);
            this.forKeyword = forKeyword;
            if (names != null)
            {
                this.AdjustFlagsAndWidth(names);
                this.names = names;
            }
            this.AdjustFlagsAndWidth(inKeyword);
            this.inKeyword = inKeyword;
            this.AdjustFlagsAndWidth(iteration);
            this.iteration = iteration;
            this.AdjustFlagsAndWidth(block);
            this.block = block;
        }

        public SyntaxToken ForKeyword => this.forKeyword;
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ParameterSyntax> Names => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ParameterSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MoonScriptSyntaxNode>(this.names));
        public SyntaxToken InKeyword => this.inKeyword;
        public ExpressionSyntax Iteration => this.iteration;
        public BlockSyntax Block => this.block;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.forKeyword,
                1 => this.names,
                2 => this.inKeyword,
                3 => this.iteration,
                4 => this.block,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.ForInExpressionSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitForInExpression(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitForInExpression(this);

        public ForInExpressionSyntax Update(SyntaxToken forKeyword, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ParameterSyntax> names, SyntaxToken inKeyword, ExpressionSyntax iteration, BlockSyntax block)
        {
            if (forKeyword != this.ForKeyword || names != this.Names || inKeyword != this.InKeyword || iteration != this.Iteration || block != this.Block)
            {
                var newNode = SyntaxFactory.ForInExpression(forKeyword, names, inKeyword, iteration, block);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ForInExpressionSyntax(this.Kind, this.forKeyword, this.names, this.inKeyword, this.iteration, this.block, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ForInExpressionSyntax(this.Kind, this.forKeyword, this.names, this.inKeyword, this.iteration, this.block, GetDiagnostics(), annotations);

        internal ForInExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 5;
            var forKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(forKeyword);
            this.forKeyword = forKeyword;
            var names = (GreenNode?)reader.ReadValue();
            if (names != null)
            {
                AdjustFlagsAndWidth(names);
                this.names = names;
            }
            var inKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(inKeyword);
            this.inKeyword = inKeyword;
            var iteration = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(iteration);
            this.iteration = iteration;
            var block = (BlockSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(block);
            this.block = block;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.forKeyword);
            writer.WriteValue(this.names);
            writer.WriteValue(this.inKeyword);
            writer.WriteValue(this.iteration);
            writer.WriteValue(this.block);
        }

        static ForInExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ForInExpressionSyntax), r => new ForInExpressionSyntax(r));
        }
    }

    /// <summary>Provides the base class from which the classes that represent statement syntax nodes are derived. This is an abstract class.</summary>
    internal abstract partial class StatementSyntax : MoonScriptSyntaxNode
    {
        internal StatementSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal StatementSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected StatementSyntax(ObjectReader reader)
          : base(reader)
        {
        }
    }

    internal sealed partial class ChunkSyntax : MoonScriptSyntaxNode
    {
        internal readonly BlockSyntax block;
        internal readonly SyntaxToken endOfFileToken;

        internal ChunkSyntax(SyntaxKind kind, BlockSyntax block, SyntaxToken endOfFileToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(block);
            this.block = block;
            this.AdjustFlagsAndWidth(endOfFileToken);
            this.endOfFileToken = endOfFileToken;
        }

        internal ChunkSyntax(SyntaxKind kind, BlockSyntax block, SyntaxToken endOfFileToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(block);
            this.block = block;
            this.AdjustFlagsAndWidth(endOfFileToken);
            this.endOfFileToken = endOfFileToken;
        }

        internal ChunkSyntax(SyntaxKind kind, BlockSyntax block, SyntaxToken endOfFileToken)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(block);
            this.block = block;
            this.AdjustFlagsAndWidth(endOfFileToken);
            this.endOfFileToken = endOfFileToken;
        }

        public BlockSyntax Block => this.block;
        public SyntaxToken EndOfFileToken => this.endOfFileToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.block,
                1 => this.endOfFileToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.ChunkSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitChunk(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitChunk(this);

        public ChunkSyntax Update(BlockSyntax block, SyntaxToken endOfFileToken)
        {
            if (block != this.Block || endOfFileToken != this.EndOfFileToken)
            {
                var newNode = SyntaxFactory.Chunk(block, endOfFileToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ChunkSyntax(this.Kind, this.block, this.endOfFileToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ChunkSyntax(this.Kind, this.block, this.endOfFileToken, GetDiagnostics(), annotations);

        internal ChunkSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var block = (BlockSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(block);
            this.block = block;
            var endOfFileToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(endOfFileToken);
            this.endOfFileToken = endOfFileToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.block);
            writer.WriteValue(this.endOfFileToken);
        }

        static ChunkSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ChunkSyntax), r => new ChunkSyntax(r));
        }
    }

    internal sealed partial class BlockSyntax : MoonScriptSyntaxNode
    {
        internal readonly GreenNode? statements;

        internal BlockSyntax(SyntaxKind kind, GreenNode? statements, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 1;
            if (statements != null)
            {
                this.AdjustFlagsAndWidth(statements);
                this.statements = statements;
            }
        }

        internal BlockSyntax(SyntaxKind kind, GreenNode? statements, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 1;
            if (statements != null)
            {
                this.AdjustFlagsAndWidth(statements);
                this.statements = statements;
            }
        }

        internal BlockSyntax(SyntaxKind kind, GreenNode? statements)
          : base(kind)
        {
            this.SlotCount = 1;
            if (statements != null)
            {
                this.AdjustFlagsAndWidth(statements);
                this.statements = statements;
            }
        }

        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<StatementSyntax> Statements => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<StatementSyntax>(this.statements);

        internal override GreenNode? GetSlot(int index)
            => index == 0 ? this.statements : null;

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.BlockSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitBlock(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitBlock(this);

        public BlockSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<StatementSyntax> statements)
        {
            if (statements != this.Statements)
            {
                var newNode = SyntaxFactory.Block(statements);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new BlockSyntax(this.Kind, this.statements, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new BlockSyntax(this.Kind, this.statements, GetDiagnostics(), annotations);

        internal BlockSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 1;
            var statements = (GreenNode?)reader.ReadValue();
            if (statements != null)
            {
                AdjustFlagsAndWidth(statements);
                this.statements = statements;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.statements);
        }

        static BlockSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(BlockSyntax), r => new BlockSyntax(r));
        }
    }

    internal sealed partial class SkippedTokensTriviaSyntax : StructuredTriviaSyntax
    {
        internal readonly GreenNode? tokens;

        internal SkippedTokensTriviaSyntax(SyntaxKind kind, GreenNode? tokens, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 1;
            if (tokens != null)
            {
                this.AdjustFlagsAndWidth(tokens);
                this.tokens = tokens;
            }
        }

        internal SkippedTokensTriviaSyntax(SyntaxKind kind, GreenNode? tokens, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 1;
            if (tokens != null)
            {
                this.AdjustFlagsAndWidth(tokens);
                this.tokens = tokens;
            }
        }

        internal SkippedTokensTriviaSyntax(SyntaxKind kind, GreenNode? tokens)
          : base(kind)
        {
            this.SlotCount = 1;
            if (tokens != null)
            {
                this.AdjustFlagsAndWidth(tokens);
                this.tokens = tokens;
            }
        }

        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Tokens => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.tokens);

        internal override GreenNode? GetSlot(int index)
            => index == 0 ? this.tokens : null;

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.SkippedTokensTriviaSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitSkippedTokensTrivia(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitSkippedTokensTrivia(this);

        public SkippedTokensTriviaSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> tokens)
        {
            if (tokens != this.Tokens)
            {
                var newNode = SyntaxFactory.SkippedTokensTrivia(tokens);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new SkippedTokensTriviaSyntax(this.Kind, this.tokens, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new SkippedTokensTriviaSyntax(this.Kind, this.tokens, GetDiagnostics(), annotations);

        internal SkippedTokensTriviaSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 1;
            var tokens = (GreenNode?)reader.ReadValue();
            if (tokens != null)
            {
                AdjustFlagsAndWidth(tokens);
                this.tokens = tokens;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.tokens);
        }

        static SkippedTokensTriviaSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(SkippedTokensTriviaSyntax), r => new SkippedTokensTriviaSyntax(r));
        }
    }

    /// <summary>Class which represents the syntax node for the list of expressions.</summary>
    internal sealed partial class ExpressionListSyntax : MoonScriptSyntaxNode
    {
        internal readonly GreenNode? expressions;

        internal ExpressionListSyntax(SyntaxKind kind, GreenNode? expressions, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 1;
            if (expressions != null)
            {
                this.AdjustFlagsAndWidth(expressions);
                this.expressions = expressions;
            }
        }

        internal ExpressionListSyntax(SyntaxKind kind, GreenNode? expressions, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 1;
            if (expressions != null)
            {
                this.AdjustFlagsAndWidth(expressions);
                this.expressions = expressions;
            }
        }

        internal ExpressionListSyntax(SyntaxKind kind, GreenNode? expressions)
          : base(kind)
        {
            this.SlotCount = 1;
            if (expressions != null)
            {
                this.AdjustFlagsAndWidth(expressions);
                this.expressions = expressions;
            }
        }

        /// <summary>SeparatedSyntaxList of ExpressionSyntax nodes representing the list of expressions.</summary>
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> Expressions => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MoonScriptSyntaxNode>(this.expressions));

        internal override GreenNode? GetSlot(int index)
            => index == 0 ? this.expressions : null;

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.ExpressionListSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitExpressionList(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitExpressionList(this);

        public ExpressionListSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> expressions)
        {
            if (expressions != this.Expressions)
            {
                var newNode = SyntaxFactory.ExpressionList(expressions);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ExpressionListSyntax(this.Kind, this.expressions, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ExpressionListSyntax(this.Kind, this.expressions, GetDiagnostics(), annotations);

        internal ExpressionListSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 1;
            var expressions = (GreenNode?)reader.ReadValue();
            if (expressions != null)
            {
                AdjustFlagsAndWidth(expressions);
                this.expressions = expressions;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.expressions);
        }

        static ExpressionListSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ExpressionListSyntax), r => new ExpressionListSyntax(r));
        }
    }

    /// <summary>Parameter syntax.</summary>
    internal sealed partial class ParameterSyntax : MoonScriptSyntaxNode
    {
        internal readonly SyntaxToken identifier;

        internal ParameterSyntax(SyntaxKind kind, SyntaxToken identifier, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
        }

        internal ParameterSyntax(SyntaxKind kind, SyntaxToken identifier, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
        }

        internal ParameterSyntax(SyntaxKind kind, SyntaxToken identifier)
          : base(kind)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
        }

        /// <summary>Gets the identifier.</summary>
        public SyntaxToken Identifier => this.identifier;

        internal override GreenNode? GetSlot(int index)
            => index == 0 ? this.identifier : null;

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.ParameterSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitParameter(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitParameter(this);

        public ParameterSyntax Update(SyntaxToken identifier)
        {
            if (identifier != this.Identifier)
            {
                var newNode = SyntaxFactory.Parameter(identifier);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ParameterSyntax(this.Kind, this.identifier, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ParameterSyntax(this.Kind, this.identifier, GetDiagnostics(), annotations);

        internal ParameterSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 1;
            var identifier = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.identifier);
        }

        static ParameterSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ParameterSyntax), r => new ParameterSyntax(r));
        }
    }

    internal partial class MoonScriptSyntaxVisitor<TResult>
    {
        public virtual TResult VisitIdentifierName(IdentifierNameSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitLiteralExpression(LiteralExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitSelfExpression(SelfExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitSuperExpression(SuperExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitTypeExpression(TypeExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitParenthesizedExpression(ParenthesizedExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitClassExpression(ClassExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitAnomymousClassExpression(AnomymousClassExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitDoExpression(DoExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitForExpression(ForExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitForInExpression(ForInExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitChunk(ChunkSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitBlock(BlockSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitSkippedTokensTrivia(SkippedTokensTriviaSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitExpressionList(ExpressionListSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitParameter(ParameterSyntax node) => this.DefaultVisit(node);
    }

    internal partial class MoonScriptSyntaxVisitor
    {
        public virtual void VisitIdentifierName(IdentifierNameSyntax node) => this.DefaultVisit(node);
        public virtual void VisitLiteralExpression(LiteralExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitSelfExpression(SelfExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitSuperExpression(SuperExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitTypeExpression(TypeExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitParenthesizedExpression(ParenthesizedExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitClassExpression(ClassExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitAnomymousClassExpression(AnomymousClassExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitDoExpression(DoExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitForExpression(ForExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitForInExpression(ForInExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitChunk(ChunkSyntax node) => this.DefaultVisit(node);
        public virtual void VisitBlock(BlockSyntax node) => this.DefaultVisit(node);
        public virtual void VisitSkippedTokensTrivia(SkippedTokensTriviaSyntax node) => this.DefaultVisit(node);
        public virtual void VisitExpressionList(ExpressionListSyntax node) => this.DefaultVisit(node);
        public virtual void VisitParameter(ParameterSyntax node) => this.DefaultVisit(node);
    }

    internal partial class MoonScriptSyntaxRewriter : MoonScriptSyntaxVisitor<MoonScriptSyntaxNode>
    {
        public override MoonScriptSyntaxNode VisitIdentifierName(IdentifierNameSyntax node)
            => node.Update((SyntaxToken)Visit(node.Identifier));

        public override MoonScriptSyntaxNode VisitLiteralExpression(LiteralExpressionSyntax node)
            => node.Update((SyntaxToken)Visit(node.Token));

        public override MoonScriptSyntaxNode VisitSelfExpression(SelfExpressionSyntax node)
            => node.Update((SyntaxToken)Visit(node.Token));

        public override MoonScriptSyntaxNode VisitSuperExpression(SuperExpressionSyntax node)
            => node.Update((SyntaxToken)Visit(node.Token));

        public override MoonScriptSyntaxNode VisitTypeExpression(TypeExpressionSyntax node)
            => node.Update((SyntaxToken)Visit(node.Token));

        public override MoonScriptSyntaxNode VisitParenthesizedExpression(ParenthesizedExpressionSyntax node)
            => node.Update((SyntaxToken)Visit(node.OpenParenToken), (ExpressionSyntax)Visit(node.Expression), (SyntaxToken)Visit(node.CloseParenToken));

        public override MoonScriptSyntaxNode VisitClassExpression(ClassExpressionSyntax node)
            => node.Update((SyntaxToken)Visit(node.ClassKeyword), (IdentifierNameSyntax)Visit(node.Name), (SyntaxToken)Visit(node.ExtendsKeyword), (IdentifierNameSyntax)Visit(node.BaseName));

        public override MoonScriptSyntaxNode VisitAnomymousClassExpression(AnomymousClassExpressionSyntax node)
            => node.Update((SyntaxToken)Visit(node.ClassKeyword), (SyntaxToken)Visit(node.ExtendsKeyword), (IdentifierNameSyntax)Visit(node.BaseName));

        public override MoonScriptSyntaxNode VisitDoExpression(DoExpressionSyntax node)
            => node.Update((SyntaxToken)Visit(node.DoKeyword), (BlockSyntax)Visit(node.Block));

        public override MoonScriptSyntaxNode VisitForExpression(ForExpressionSyntax node)
            => node.Update((SyntaxToken)Visit(node.ForKeyword), (IdentifierNameSyntax)Visit(node.Name), (SyntaxToken)Visit(node.EqualsToken), (ExpressionSyntax)Visit(node.Initial), (SyntaxToken)Visit(node.FirstCommaToken), (ExpressionSyntax)Visit(node.Limit), (SyntaxToken)Visit(node.SecondCommaToken), (ExpressionSyntax)Visit(node.Step), (BlockSyntax)Visit(node.Block));

        public override MoonScriptSyntaxNode VisitForInExpression(ForInExpressionSyntax node)
            => node.Update((SyntaxToken)Visit(node.ForKeyword), VisitList(node.Names), (SyntaxToken)Visit(node.InKeyword), (ExpressionSyntax)Visit(node.Iteration), (BlockSyntax)Visit(node.Block));

        public override MoonScriptSyntaxNode VisitChunk(ChunkSyntax node)
            => node.Update((BlockSyntax)Visit(node.Block), (SyntaxToken)Visit(node.EndOfFileToken));

        public override MoonScriptSyntaxNode VisitBlock(BlockSyntax node)
            => node.Update(VisitList(node.Statements));

        public override MoonScriptSyntaxNode VisitSkippedTokensTrivia(SkippedTokensTriviaSyntax node)
            => node.Update(VisitList(node.Tokens));

        public override MoonScriptSyntaxNode VisitExpressionList(ExpressionListSyntax node)
            => node.Update(VisitList(node.Expressions));

        public override MoonScriptSyntaxNode VisitParameter(ParameterSyntax node)
            => node.Update((SyntaxToken)Visit(node.Identifier));
    }

    internal partial class ContextAwareSyntax
    {

        private SyntaxFactoryContext context;

        public ContextAwareSyntax(SyntaxFactoryContext context)
            => this.context = context;

        public IdentifierNameSyntax IdentifierName(SyntaxToken identifier)
        {
#if DEBUG
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            switch (identifier.Kind)
            {
                case SyntaxKind.IdentifierToken:
                case SyntaxKind.GlobalEnvironmentKeyword:
                case SyntaxKind.EnvironmentKeyword: break;
                default: throw new ArgumentException(nameof(identifier));
            }
#endif

            int hash;
            var cached = MoonScriptSyntaxNodeCache.TryGetNode((int)SyntaxKind.IdentifierName, identifier, this.context, out hash);
            if (cached != null) return (IdentifierNameSyntax)cached;

            var result = new IdentifierNameSyntax(SyntaxKind.IdentifierName, identifier, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public LiteralExpressionSyntax LiteralExpression(SyntaxKind kind, SyntaxToken token)
        {
            switch (kind)
            {
                case SyntaxKind.NilLiteralExpression:
                case SyntaxKind.FalseLiteralExpression:
                case SyntaxKind.TrueLiteralExpression:
                case SyntaxKind.NumericLiteralExpression:
                case SyntaxKind.StringLiteralExpression:
                case SyntaxKind.VariousArgumentsExpression: break;
                default: throw new ArgumentException(nameof(kind));
            }
#if DEBUG
            if (token == null) throw new ArgumentNullException(nameof(token));
            switch (token.Kind)
            {
                case SyntaxKind.NilKeyword:
                case SyntaxKind.FalseKeyword:
                case SyntaxKind.TrueKeyword:
                case SyntaxKind.NumericLiteralToken:
                case SyntaxKind.StringLiteralToken:
                case SyntaxKind.MultiLineRawStringLiteralToken:
                case SyntaxKind.DotDotDotToken: break;
                default: throw new ArgumentException(nameof(token));
            }
#endif

            int hash;
            var cached = MoonScriptSyntaxNodeCache.TryGetNode((int)kind, token, this.context, out hash);
            if (cached != null) return (LiteralExpressionSyntax)cached;

            var result = new LiteralExpressionSyntax(kind, token, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public SelfExpressionSyntax SelfExpression(SyntaxToken token)
        {
#if DEBUG
            if (token == null) throw new ArgumentNullException(nameof(token));
            if (token.Kind != SyntaxKind.CommercialAtToken) throw new ArgumentException(nameof(token));
#endif

            int hash;
            var cached = MoonScriptSyntaxNodeCache.TryGetNode((int)SyntaxKind.SelfExpression, token, this.context, out hash);
            if (cached != null) return (SelfExpressionSyntax)cached;

            var result = new SelfExpressionSyntax(SyntaxKind.SelfExpression, token, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public SuperExpressionSyntax SuperExpression(SyntaxToken token)
        {
#if DEBUG
            if (token == null) throw new ArgumentNullException(nameof(token));
            if (token.Kind != SyntaxKind.SuperKeyword) throw new ArgumentException(nameof(token));
#endif

            int hash;
            var cached = MoonScriptSyntaxNodeCache.TryGetNode((int)SyntaxKind.SuperExpression, token, this.context, out hash);
            if (cached != null) return (SuperExpressionSyntax)cached;

            var result = new SuperExpressionSyntax(SyntaxKind.SuperExpression, token, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public TypeExpressionSyntax TypeExpression(SyntaxToken token)
        {
#if DEBUG
            if (token == null) throw new ArgumentNullException(nameof(token));
            if (token.Kind != SyntaxKind.CommercialAtCommercialAtToken) throw new ArgumentException(nameof(token));
#endif

            int hash;
            var cached = MoonScriptSyntaxNodeCache.TryGetNode((int)SyntaxKind.TypeExpression, token, this.context, out hash);
            if (cached != null) return (TypeExpressionSyntax)cached;

            var result = new TypeExpressionSyntax(SyntaxKind.TypeExpression, token, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public ParenthesizedExpressionSyntax ParenthesizedExpression(SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
        {
#if DEBUG
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
#endif

            int hash;
            var cached = MoonScriptSyntaxNodeCache.TryGetNode((int)SyntaxKind.ParenthesizedExpression, openParenToken, expression, closeParenToken, this.context, out hash);
            if (cached != null) return (ParenthesizedExpressionSyntax)cached;

            var result = new ParenthesizedExpressionSyntax(SyntaxKind.ParenthesizedExpression, openParenToken, expression, closeParenToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public ClassExpressionSyntax ClassExpression(SyntaxToken classKeyword, IdentifierNameSyntax name, SyntaxToken extendsKeyword, IdentifierNameSyntax baseName)
        {
#if DEBUG
            if (classKeyword == null) throw new ArgumentNullException(nameof(classKeyword));
            if (classKeyword.Kind != SyntaxKind.ClassKeyword) throw new ArgumentException(nameof(classKeyword));
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (extendsKeyword == null) throw new ArgumentNullException(nameof(extendsKeyword));
            if (extendsKeyword.Kind != SyntaxKind.ExtendsKeyword) throw new ArgumentException(nameof(extendsKeyword));
            if (baseName == null) throw new ArgumentNullException(nameof(baseName));
#endif

            return new ClassExpressionSyntax(SyntaxKind.ClassExpression, classKeyword, name, extendsKeyword, baseName, this.context);
        }

        public AnomymousClassExpressionSyntax AnomymousClassExpression(SyntaxToken classKeyword, SyntaxToken extendsKeyword, IdentifierNameSyntax baseName)
        {
#if DEBUG
            if (classKeyword == null) throw new ArgumentNullException(nameof(classKeyword));
            if (classKeyword.Kind != SyntaxKind.ClassKeyword) throw new ArgumentException(nameof(classKeyword));
            if (extendsKeyword == null) throw new ArgumentNullException(nameof(extendsKeyword));
            if (extendsKeyword.Kind != SyntaxKind.ExtendsKeyword) throw new ArgumentException(nameof(extendsKeyword));
            if (baseName == null) throw new ArgumentNullException(nameof(baseName));
#endif

            int hash;
            var cached = MoonScriptSyntaxNodeCache.TryGetNode((int)SyntaxKind.AnomymousClassExpression, classKeyword, extendsKeyword, baseName, this.context, out hash);
            if (cached != null) return (AnomymousClassExpressionSyntax)cached;

            var result = new AnomymousClassExpressionSyntax(SyntaxKind.AnomymousClassExpression, classKeyword, extendsKeyword, baseName, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public DoExpressionSyntax DoExpression(SyntaxToken doKeyword, BlockSyntax block)
        {
#if DEBUG
            if (doKeyword == null) throw new ArgumentNullException(nameof(doKeyword));
            if (doKeyword.Kind != SyntaxKind.DoKeyword) throw new ArgumentException(nameof(doKeyword));
            if (block == null) throw new ArgumentNullException(nameof(block));
#endif

            int hash;
            var cached = MoonScriptSyntaxNodeCache.TryGetNode((int)SyntaxKind.DoExpression, doKeyword, block, this.context, out hash);
            if (cached != null) return (DoExpressionSyntax)cached;

            var result = new DoExpressionSyntax(SyntaxKind.DoExpression, doKeyword, block, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public ForExpressionSyntax ForExpression(SyntaxToken forKeyword, IdentifierNameSyntax name, SyntaxToken equalsToken, ExpressionSyntax initial, SyntaxToken firstCommaToken, ExpressionSyntax limit, SyntaxToken secondCommaToken, ExpressionSyntax step, BlockSyntax block)
        {
#if DEBUG
            if (forKeyword == null) throw new ArgumentNullException(nameof(forKeyword));
            if (forKeyword.Kind != SyntaxKind.ForKeyword) throw new ArgumentException(nameof(forKeyword));
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (equalsToken == null) throw new ArgumentNullException(nameof(equalsToken));
            if (equalsToken.Kind != SyntaxKind.EqualsToken) throw new ArgumentException(nameof(equalsToken));
            if (initial == null) throw new ArgumentNullException(nameof(initial));
            if (firstCommaToken == null) throw new ArgumentNullException(nameof(firstCommaToken));
            if (firstCommaToken.Kind != SyntaxKind.CommaToken) throw new ArgumentException(nameof(firstCommaToken));
            if (limit == null) throw new ArgumentNullException(nameof(limit));
            if (secondCommaToken == null) throw new ArgumentNullException(nameof(secondCommaToken));
            if (secondCommaToken.Kind != SyntaxKind.CommaToken) throw new ArgumentException(nameof(secondCommaToken));
            if (step == null) throw new ArgumentNullException(nameof(step));
            if (block == null) throw new ArgumentNullException(nameof(block));
#endif

            return new ForExpressionSyntax(SyntaxKind.ForExpression, forKeyword, name, equalsToken, initial, firstCommaToken, limit, secondCommaToken, step, block, this.context);
        }

        public ForInExpressionSyntax ForInExpression(SyntaxToken forKeyword, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ParameterSyntax> names, SyntaxToken inKeyword, ExpressionSyntax iteration, BlockSyntax block)
        {
#if DEBUG
            if (forKeyword == null) throw new ArgumentNullException(nameof(forKeyword));
            if (forKeyword.Kind != SyntaxKind.ForKeyword) throw new ArgumentException(nameof(forKeyword));
            if (inKeyword == null) throw new ArgumentNullException(nameof(inKeyword));
            if (inKeyword.Kind != SyntaxKind.InKeyword) throw new ArgumentException(nameof(inKeyword));
            if (iteration == null) throw new ArgumentNullException(nameof(iteration));
            if (block == null) throw new ArgumentNullException(nameof(block));
#endif

            return new ForInExpressionSyntax(SyntaxKind.ForInExpression, forKeyword, names.Node, inKeyword, iteration, block, this.context);
        }

        public ChunkSyntax Chunk(BlockSyntax block, SyntaxToken endOfFileToken)
        {
#if DEBUG
            if (block == null) throw new ArgumentNullException(nameof(block));
            if (endOfFileToken == null) throw new ArgumentNullException(nameof(endOfFileToken));
            if (endOfFileToken.Kind != SyntaxKind.EndOfFileToken) throw new ArgumentException(nameof(endOfFileToken));
#endif

            int hash;
            var cached = MoonScriptSyntaxNodeCache.TryGetNode((int)SyntaxKind.Chunk, block, endOfFileToken, this.context, out hash);
            if (cached != null) return (ChunkSyntax)cached;

            var result = new ChunkSyntax(SyntaxKind.Chunk, block, endOfFileToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public BlockSyntax Block(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<StatementSyntax> statements)
        {
#if DEBUG
#endif

            int hash;
            var cached = MoonScriptSyntaxNodeCache.TryGetNode((int)SyntaxKind.Block, statements.Node, this.context, out hash);
            if (cached != null) return (BlockSyntax)cached;

            var result = new BlockSyntax(SyntaxKind.Block, statements.Node, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public SkippedTokensTriviaSyntax SkippedTokensTrivia(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> tokens)
        {
#if DEBUG
#endif

            return new SkippedTokensTriviaSyntax(SyntaxKind.SkippedTokensTrivia, tokens.Node, this.context);
        }

        public ExpressionListSyntax ExpressionList(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> expressions)
        {
#if DEBUG
#endif

            int hash;
            var cached = MoonScriptSyntaxNodeCache.TryGetNode((int)SyntaxKind.ExpressionList, expressions.Node, this.context, out hash);
            if (cached != null) return (ExpressionListSyntax)cached;

            var result = new ExpressionListSyntax(SyntaxKind.ExpressionList, expressions.Node, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public ParameterSyntax Parameter(SyntaxToken identifier)
        {
#if DEBUG
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            switch (identifier.Kind)
            {
                case SyntaxKind.IdentifierToken:
                case SyntaxKind.DotDotDotToken: break;
                default: throw new ArgumentException(nameof(identifier));
            }
#endif

            int hash;
            var cached = MoonScriptSyntaxNodeCache.TryGetNode((int)SyntaxKind.Parameter, identifier, this.context, out hash);
            if (cached != null) return (ParameterSyntax)cached;

            var result = new ParameterSyntax(SyntaxKind.Parameter, identifier, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }
    }

    internal static partial class SyntaxFactory
    {

        public static IdentifierNameSyntax IdentifierName(SyntaxToken identifier)
        {
#if DEBUG
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            switch (identifier.Kind)
            {
                case SyntaxKind.IdentifierToken:
                case SyntaxKind.GlobalEnvironmentKeyword:
                case SyntaxKind.EnvironmentKeyword: break;
                default: throw new ArgumentException(nameof(identifier));
            }
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.IdentifierName, identifier, out hash);
            if (cached != null) return (IdentifierNameSyntax)cached;

            var result = new IdentifierNameSyntax(SyntaxKind.IdentifierName, identifier);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static LiteralExpressionSyntax LiteralExpression(SyntaxKind kind, SyntaxToken token)
        {
            switch (kind)
            {
                case SyntaxKind.NilLiteralExpression:
                case SyntaxKind.FalseLiteralExpression:
                case SyntaxKind.TrueLiteralExpression:
                case SyntaxKind.NumericLiteralExpression:
                case SyntaxKind.StringLiteralExpression:
                case SyntaxKind.VariousArgumentsExpression: break;
                default: throw new ArgumentException(nameof(kind));
            }
#if DEBUG
            if (token == null) throw new ArgumentNullException(nameof(token));
            switch (token.Kind)
            {
                case SyntaxKind.NilKeyword:
                case SyntaxKind.FalseKeyword:
                case SyntaxKind.TrueKeyword:
                case SyntaxKind.NumericLiteralToken:
                case SyntaxKind.StringLiteralToken:
                case SyntaxKind.MultiLineRawStringLiteralToken:
                case SyntaxKind.DotDotDotToken: break;
                default: throw new ArgumentException(nameof(token));
            }
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)kind, token, out hash);
            if (cached != null) return (LiteralExpressionSyntax)cached;

            var result = new LiteralExpressionSyntax(kind, token);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static SelfExpressionSyntax SelfExpression(SyntaxToken token)
        {
#if DEBUG
            if (token == null) throw new ArgumentNullException(nameof(token));
            if (token.Kind != SyntaxKind.CommercialAtToken) throw new ArgumentException(nameof(token));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.SelfExpression, token, out hash);
            if (cached != null) return (SelfExpressionSyntax)cached;

            var result = new SelfExpressionSyntax(SyntaxKind.SelfExpression, token);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static SuperExpressionSyntax SuperExpression(SyntaxToken token)
        {
#if DEBUG
            if (token == null) throw new ArgumentNullException(nameof(token));
            if (token.Kind != SyntaxKind.SuperKeyword) throw new ArgumentException(nameof(token));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.SuperExpression, token, out hash);
            if (cached != null) return (SuperExpressionSyntax)cached;

            var result = new SuperExpressionSyntax(SyntaxKind.SuperExpression, token);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static TypeExpressionSyntax TypeExpression(SyntaxToken token)
        {
#if DEBUG
            if (token == null) throw new ArgumentNullException(nameof(token));
            if (token.Kind != SyntaxKind.CommercialAtCommercialAtToken) throw new ArgumentException(nameof(token));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.TypeExpression, token, out hash);
            if (cached != null) return (TypeExpressionSyntax)cached;

            var result = new TypeExpressionSyntax(SyntaxKind.TypeExpression, token);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static ParenthesizedExpressionSyntax ParenthesizedExpression(SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
        {
#if DEBUG
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ParenthesizedExpression, openParenToken, expression, closeParenToken, out hash);
            if (cached != null) return (ParenthesizedExpressionSyntax)cached;

            var result = new ParenthesizedExpressionSyntax(SyntaxKind.ParenthesizedExpression, openParenToken, expression, closeParenToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static ClassExpressionSyntax ClassExpression(SyntaxToken classKeyword, IdentifierNameSyntax name, SyntaxToken extendsKeyword, IdentifierNameSyntax baseName)
        {
#if DEBUG
            if (classKeyword == null) throw new ArgumentNullException(nameof(classKeyword));
            if (classKeyword.Kind != SyntaxKind.ClassKeyword) throw new ArgumentException(nameof(classKeyword));
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (extendsKeyword == null) throw new ArgumentNullException(nameof(extendsKeyword));
            if (extendsKeyword.Kind != SyntaxKind.ExtendsKeyword) throw new ArgumentException(nameof(extendsKeyword));
            if (baseName == null) throw new ArgumentNullException(nameof(baseName));
#endif

            return new ClassExpressionSyntax(SyntaxKind.ClassExpression, classKeyword, name, extendsKeyword, baseName);
        }

        public static AnomymousClassExpressionSyntax AnomymousClassExpression(SyntaxToken classKeyword, SyntaxToken extendsKeyword, IdentifierNameSyntax baseName)
        {
#if DEBUG
            if (classKeyword == null) throw new ArgumentNullException(nameof(classKeyword));
            if (classKeyword.Kind != SyntaxKind.ClassKeyword) throw new ArgumentException(nameof(classKeyword));
            if (extendsKeyword == null) throw new ArgumentNullException(nameof(extendsKeyword));
            if (extendsKeyword.Kind != SyntaxKind.ExtendsKeyword) throw new ArgumentException(nameof(extendsKeyword));
            if (baseName == null) throw new ArgumentNullException(nameof(baseName));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.AnomymousClassExpression, classKeyword, extendsKeyword, baseName, out hash);
            if (cached != null) return (AnomymousClassExpressionSyntax)cached;

            var result = new AnomymousClassExpressionSyntax(SyntaxKind.AnomymousClassExpression, classKeyword, extendsKeyword, baseName);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static DoExpressionSyntax DoExpression(SyntaxToken doKeyword, BlockSyntax block)
        {
#if DEBUG
            if (doKeyword == null) throw new ArgumentNullException(nameof(doKeyword));
            if (doKeyword.Kind != SyntaxKind.DoKeyword) throw new ArgumentException(nameof(doKeyword));
            if (block == null) throw new ArgumentNullException(nameof(block));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.DoExpression, doKeyword, block, out hash);
            if (cached != null) return (DoExpressionSyntax)cached;

            var result = new DoExpressionSyntax(SyntaxKind.DoExpression, doKeyword, block);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static ForExpressionSyntax ForExpression(SyntaxToken forKeyword, IdentifierNameSyntax name, SyntaxToken equalsToken, ExpressionSyntax initial, SyntaxToken firstCommaToken, ExpressionSyntax limit, SyntaxToken secondCommaToken, ExpressionSyntax step, BlockSyntax block)
        {
#if DEBUG
            if (forKeyword == null) throw new ArgumentNullException(nameof(forKeyword));
            if (forKeyword.Kind != SyntaxKind.ForKeyword) throw new ArgumentException(nameof(forKeyword));
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (equalsToken == null) throw new ArgumentNullException(nameof(equalsToken));
            if (equalsToken.Kind != SyntaxKind.EqualsToken) throw new ArgumentException(nameof(equalsToken));
            if (initial == null) throw new ArgumentNullException(nameof(initial));
            if (firstCommaToken == null) throw new ArgumentNullException(nameof(firstCommaToken));
            if (firstCommaToken.Kind != SyntaxKind.CommaToken) throw new ArgumentException(nameof(firstCommaToken));
            if (limit == null) throw new ArgumentNullException(nameof(limit));
            if (secondCommaToken == null) throw new ArgumentNullException(nameof(secondCommaToken));
            if (secondCommaToken.Kind != SyntaxKind.CommaToken) throw new ArgumentException(nameof(secondCommaToken));
            if (step == null) throw new ArgumentNullException(nameof(step));
            if (block == null) throw new ArgumentNullException(nameof(block));
#endif

            return new ForExpressionSyntax(SyntaxKind.ForExpression, forKeyword, name, equalsToken, initial, firstCommaToken, limit, secondCommaToken, step, block);
        }

        public static ForInExpressionSyntax ForInExpression(SyntaxToken forKeyword, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ParameterSyntax> names, SyntaxToken inKeyword, ExpressionSyntax iteration, BlockSyntax block)
        {
#if DEBUG
            if (forKeyword == null) throw new ArgumentNullException(nameof(forKeyword));
            if (forKeyword.Kind != SyntaxKind.ForKeyword) throw new ArgumentException(nameof(forKeyword));
            if (inKeyword == null) throw new ArgumentNullException(nameof(inKeyword));
            if (inKeyword.Kind != SyntaxKind.InKeyword) throw new ArgumentException(nameof(inKeyword));
            if (iteration == null) throw new ArgumentNullException(nameof(iteration));
            if (block == null) throw new ArgumentNullException(nameof(block));
#endif

            return new ForInExpressionSyntax(SyntaxKind.ForInExpression, forKeyword, names.Node, inKeyword, iteration, block);
        }

        public static ChunkSyntax Chunk(BlockSyntax block, SyntaxToken endOfFileToken)
        {
#if DEBUG
            if (block == null) throw new ArgumentNullException(nameof(block));
            if (endOfFileToken == null) throw new ArgumentNullException(nameof(endOfFileToken));
            if (endOfFileToken.Kind != SyntaxKind.EndOfFileToken) throw new ArgumentException(nameof(endOfFileToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.Chunk, block, endOfFileToken, out hash);
            if (cached != null) return (ChunkSyntax)cached;

            var result = new ChunkSyntax(SyntaxKind.Chunk, block, endOfFileToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static BlockSyntax Block(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<StatementSyntax> statements)
        {
#if DEBUG
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.Block, statements.Node, out hash);
            if (cached != null) return (BlockSyntax)cached;

            var result = new BlockSyntax(SyntaxKind.Block, statements.Node);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static SkippedTokensTriviaSyntax SkippedTokensTrivia(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> tokens)
        {
#if DEBUG
#endif

            return new SkippedTokensTriviaSyntax(SyntaxKind.SkippedTokensTrivia, tokens.Node);
        }

        public static ExpressionListSyntax ExpressionList(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> expressions)
        {
#if DEBUG
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ExpressionList, expressions.Node, out hash);
            if (cached != null) return (ExpressionListSyntax)cached;

            var result = new ExpressionListSyntax(SyntaxKind.ExpressionList, expressions.Node);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static ParameterSyntax Parameter(SyntaxToken identifier)
        {
#if DEBUG
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            switch (identifier.Kind)
            {
                case SyntaxKind.IdentifierToken:
                case SyntaxKind.DotDotDotToken: break;
                default: throw new ArgumentException(nameof(identifier));
            }
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.Parameter, identifier, out hash);
            if (cached != null) return (ParameterSyntax)cached;

            var result = new ParameterSyntax(SyntaxKind.Parameter, identifier);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        internal static IEnumerable<Type> GetNodeTypes()
            => new Type[]
            {
                typeof(IdentifierNameSyntax),
                typeof(LiteralExpressionSyntax),
                typeof(SelfExpressionSyntax),
                typeof(SuperExpressionSyntax),
                typeof(TypeExpressionSyntax),
                typeof(ParenthesizedExpressionSyntax),
                typeof(ClassExpressionSyntax),
                typeof(AnomymousClassExpressionSyntax),
                typeof(DoExpressionSyntax),
                typeof(ForExpressionSyntax),
                typeof(ForInExpressionSyntax),
                typeof(ChunkSyntax),
                typeof(BlockSyntax),
                typeof(SkippedTokensTriviaSyntax),
                typeof(ExpressionListSyntax),
                typeof(ParameterSyntax),
            };
    }
}
