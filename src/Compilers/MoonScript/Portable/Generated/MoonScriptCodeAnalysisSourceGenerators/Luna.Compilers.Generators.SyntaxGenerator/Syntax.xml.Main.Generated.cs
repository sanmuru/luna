// <auto-generated />

#nullable enable

using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Syntax.InternalSyntax;
using SamLu.CodeAnalysis.MoonScript;
using Roslyn.Utilities;

namespace SamLu.CodeAnalysis.MoonScript
{
    using System.Diagnostics.CodeAnalysis;
    using Microsoft.CodeAnalysis;
    using SamLu.CodeAnalysis.MoonScript.Syntax;

    public partial class MoonScriptSyntaxVisitor<TResult>
    {
        /// <summary>Called when the visitor visits a IdentifierNameSyntax node.</summary>
        public virtual TResult? VisitIdentifierName(IdentifierNameSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a LiteralExpressionSyntax node.</summary>
        public virtual TResult? VisitLiteralExpression(LiteralExpressionSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a SelfExpressionSyntax node.</summary>
        public virtual TResult? VisitSelfExpression(SelfExpressionSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a SuperExpressionSyntax node.</summary>
        public virtual TResult? VisitSuperExpression(SuperExpressionSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a TypeExpressionSyntax node.</summary>
        public virtual TResult? VisitTypeExpression(TypeExpressionSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a ParenthesizedExpressionSyntax node.</summary>
        public virtual TResult? VisitParenthesizedExpression(ParenthesizedExpressionSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a ClassExpressionSyntax node.</summary>
        public virtual TResult? VisitClassExpression(ClassExpressionSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a AnomymousClassExpressionSyntax node.</summary>
        public virtual TResult? VisitAnomymousClassExpression(AnomymousClassExpressionSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a DoExpressionSyntax node.</summary>
        public virtual TResult? VisitDoExpression(DoExpressionSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a ForExpressionSyntax node.</summary>
        public virtual TResult? VisitForExpression(ForExpressionSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a ForInExpressionSyntax node.</summary>
        public virtual TResult? VisitForInExpression(ForInExpressionSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a ChunkSyntax node.</summary>
        public virtual TResult? VisitChunk(ChunkSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a BlockSyntax node.</summary>
        public virtual TResult? VisitBlock(BlockSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a SkippedTokensTriviaSyntax node.</summary>
        public virtual TResult? VisitSkippedTokensTrivia(SkippedTokensTriviaSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a ExpressionListSyntax node.</summary>
        public virtual TResult? VisitExpressionList(ExpressionListSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a ParameterSyntax node.</summary>
        public virtual TResult? VisitParameter(ParameterSyntax node) => this.DefaultVisit(node);
    }

    public partial class MoonScriptSyntaxVisitor
    {
        /// <summary>Called when the visitor visits a IdentifierNameSyntax node.</summary>
        public virtual void VisitIdentifierName(IdentifierNameSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a LiteralExpressionSyntax node.</summary>
        public virtual void VisitLiteralExpression(LiteralExpressionSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a SelfExpressionSyntax node.</summary>
        public virtual void VisitSelfExpression(SelfExpressionSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a SuperExpressionSyntax node.</summary>
        public virtual void VisitSuperExpression(SuperExpressionSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a TypeExpressionSyntax node.</summary>
        public virtual void VisitTypeExpression(TypeExpressionSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a ParenthesizedExpressionSyntax node.</summary>
        public virtual void VisitParenthesizedExpression(ParenthesizedExpressionSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a ClassExpressionSyntax node.</summary>
        public virtual void VisitClassExpression(ClassExpressionSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a AnomymousClassExpressionSyntax node.</summary>
        public virtual void VisitAnomymousClassExpression(AnomymousClassExpressionSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a DoExpressionSyntax node.</summary>
        public virtual void VisitDoExpression(DoExpressionSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a ForExpressionSyntax node.</summary>
        public virtual void VisitForExpression(ForExpressionSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a ForInExpressionSyntax node.</summary>
        public virtual void VisitForInExpression(ForInExpressionSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a ChunkSyntax node.</summary>
        public virtual void VisitChunk(ChunkSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a BlockSyntax node.</summary>
        public virtual void VisitBlock(BlockSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a SkippedTokensTriviaSyntax node.</summary>
        public virtual void VisitSkippedTokensTrivia(SkippedTokensTriviaSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a ExpressionListSyntax node.</summary>
        public virtual void VisitExpressionList(ExpressionListSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a ParameterSyntax node.</summary>
        public virtual void VisitParameter(ParameterSyntax node) => this.DefaultVisit(node);
    }

    public partial class MoonScriptSyntaxRewriter
    {
        public override MoonScriptSyntaxNode? VisitIdentifierName(IdentifierNameSyntax node)
            => node.Update(VisitToken(node.Identifier));

        public override MoonScriptSyntaxNode? VisitLiteralExpression(LiteralExpressionSyntax node)
            => node.Update(VisitToken(node.Token));

        public override MoonScriptSyntaxNode? VisitSelfExpression(SelfExpressionSyntax node)
            => node.Update(VisitToken(node.Token));

        public override MoonScriptSyntaxNode? VisitSuperExpression(SuperExpressionSyntax node)
            => node.Update(VisitToken(node.Token));

        public override MoonScriptSyntaxNode? VisitTypeExpression(TypeExpressionSyntax node)
            => node.Update(VisitToken(node.Token));

        public override MoonScriptSyntaxNode? VisitParenthesizedExpression(ParenthesizedExpressionSyntax node)
            => node.Update(VisitToken(node.OpenParenToken), (ExpressionSyntax?)Visit(node.Expression) ?? throw new ArgumentNullException("expression"), VisitToken(node.CloseParenToken));

        public override MoonScriptSyntaxNode? VisitClassExpression(ClassExpressionSyntax node)
            => node.Update(VisitToken(node.ClassKeyword), (IdentifierNameSyntax?)Visit(node.Name) ?? throw new ArgumentNullException("name"), VisitToken(node.ExtendsKeyword), (IdentifierNameSyntax?)Visit(node.BaseName) ?? throw new ArgumentNullException("baseName"));

        public override MoonScriptSyntaxNode? VisitAnomymousClassExpression(AnomymousClassExpressionSyntax node)
            => node.Update(VisitToken(node.ClassKeyword), VisitToken(node.ExtendsKeyword), (IdentifierNameSyntax?)Visit(node.BaseName) ?? throw new ArgumentNullException("baseName"));

        public override MoonScriptSyntaxNode? VisitDoExpression(DoExpressionSyntax node)
            => node.Update(VisitToken(node.DoKeyword), (BlockSyntax?)Visit(node.Block) ?? throw new ArgumentNullException("block"));

        public override MoonScriptSyntaxNode? VisitForExpression(ForExpressionSyntax node)
            => node.Update(VisitToken(node.ForKeyword), (IdentifierNameSyntax?)Visit(node.Name) ?? throw new ArgumentNullException("name"), VisitToken(node.EqualsToken), (ExpressionSyntax?)Visit(node.Initial) ?? throw new ArgumentNullException("initial"), VisitToken(node.FirstCommaToken), (ExpressionSyntax?)Visit(node.Limit) ?? throw new ArgumentNullException("limit"), VisitToken(node.SecondCommaToken), (ExpressionSyntax?)Visit(node.Step) ?? throw new ArgumentNullException("step"), (BlockSyntax?)Visit(node.Block) ?? throw new ArgumentNullException("block"));

        public override MoonScriptSyntaxNode? VisitForInExpression(ForInExpressionSyntax node)
            => node.Update(VisitToken(node.ForKeyword), VisitList(node.Names), VisitToken(node.InKeyword), (ExpressionSyntax?)Visit(node.Iteration) ?? throw new ArgumentNullException("iteration"), (BlockSyntax?)Visit(node.Block) ?? throw new ArgumentNullException("block"));

        public override MoonScriptSyntaxNode? VisitChunk(ChunkSyntax node)
            => node.Update((BlockSyntax?)Visit(node.Block) ?? throw new ArgumentNullException("block"), VisitToken(node.EndOfFileToken));

        public override MoonScriptSyntaxNode? VisitBlock(BlockSyntax node)
            => node.Update(VisitList(node.Statements));

        public override MoonScriptSyntaxNode? VisitSkippedTokensTrivia(SkippedTokensTriviaSyntax node)
            => node.Update(VisitList(node.Tokens));

        public override MoonScriptSyntaxNode? VisitExpressionList(ExpressionListSyntax node)
            => node.Update(VisitList(node.Expressions));

        public override MoonScriptSyntaxNode? VisitParameter(ParameterSyntax node)
            => node.Update(VisitToken(node.Identifier));
    }

    public static partial class SyntaxFactory
    {

        /// <summary>Creates a new IdentifierNameSyntax instance.</summary>
        public static IdentifierNameSyntax IdentifierName(SyntaxToken identifier)
        {
            switch (identifier.Kind())
            {
                case SyntaxKind.IdentifierToken:
                case SyntaxKind.GlobalEnvironmentKeyword:
                case SyntaxKind.EnvironmentKeyword: break;
                default: throw new ArgumentException(nameof(identifier));
            }
            return (IdentifierNameSyntax)Syntax.InternalSyntax.SyntaxFactory.IdentifierName((Syntax.InternalSyntax.SyntaxToken)identifier.Node!).CreateRed();
        }

        /// <summary>Creates a new LiteralExpressionSyntax instance.</summary>
        public static LiteralExpressionSyntax LiteralExpression(SyntaxKind kind, SyntaxToken token)
        {
            switch (kind)
            {
                case SyntaxKind.NilLiteralExpression:
                case SyntaxKind.FalseLiteralExpression:
                case SyntaxKind.TrueLiteralExpression:
                case SyntaxKind.NumericLiteralExpression:
                case SyntaxKind.StringLiteralExpression:
                case SyntaxKind.VariousArgumentsExpression: break;
                default: throw new ArgumentException(nameof(kind));
            }
            switch (token.Kind())
            {
                case SyntaxKind.NilKeyword:
                case SyntaxKind.FalseKeyword:
                case SyntaxKind.TrueKeyword:
                case SyntaxKind.NumericLiteralToken:
                case SyntaxKind.StringLiteralToken:
                case SyntaxKind.MultiLineRawStringLiteralToken:
                case SyntaxKind.DotDotDotToken: break;
                default: throw new ArgumentException(nameof(token));
            }
            return (LiteralExpressionSyntax)Syntax.InternalSyntax.SyntaxFactory.LiteralExpression(kind, (Syntax.InternalSyntax.SyntaxToken)token.Node!).CreateRed();
        }

        /// <summary>Creates a new SelfExpressionSyntax instance.</summary>
        public static SelfExpressionSyntax SelfExpression(SyntaxToken token)
        {
            if (token.Kind() != SyntaxKind.CommercialAtToken) throw new ArgumentException(nameof(token));
            return (SelfExpressionSyntax)Syntax.InternalSyntax.SyntaxFactory.SelfExpression((Syntax.InternalSyntax.SyntaxToken)token.Node!).CreateRed();
        }

        /// <summary>Creates a new SelfExpressionSyntax instance.</summary>
        public static SelfExpressionSyntax SelfExpression()
            => SyntaxFactory.SelfExpression(SyntaxFactory.Token(SyntaxKind.CommercialAtToken));

        /// <summary>Creates a new SuperExpressionSyntax instance.</summary>
        public static SuperExpressionSyntax SuperExpression(SyntaxToken token)
        {
            if (token.Kind() != SyntaxKind.SuperKeyword) throw new ArgumentException(nameof(token));
            return (SuperExpressionSyntax)Syntax.InternalSyntax.SyntaxFactory.SuperExpression((Syntax.InternalSyntax.SyntaxToken)token.Node!).CreateRed();
        }

        /// <summary>Creates a new SuperExpressionSyntax instance.</summary>
        public static SuperExpressionSyntax SuperExpression()
            => SyntaxFactory.SuperExpression(SyntaxFactory.Token(SyntaxKind.SuperKeyword));

        /// <summary>Creates a new TypeExpressionSyntax instance.</summary>
        public static TypeExpressionSyntax TypeExpression(SyntaxToken token)
        {
            if (token.Kind() != SyntaxKind.CommercialAtCommercialAtToken) throw new ArgumentException(nameof(token));
            return (TypeExpressionSyntax)Syntax.InternalSyntax.SyntaxFactory.TypeExpression((Syntax.InternalSyntax.SyntaxToken)token.Node!).CreateRed();
        }

        /// <summary>Creates a new TypeExpressionSyntax instance.</summary>
        public static TypeExpressionSyntax TypeExpression()
            => SyntaxFactory.TypeExpression(SyntaxFactory.Token(SyntaxKind.CommercialAtCommercialAtToken));

        /// <summary>Creates a new ParenthesizedExpressionSyntax instance.</summary>
        public static ParenthesizedExpressionSyntax ParenthesizedExpression(SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
        {
            if (openParenToken.Kind() != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (closeParenToken.Kind() != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
            return (ParenthesizedExpressionSyntax)Syntax.InternalSyntax.SyntaxFactory.ParenthesizedExpression((Syntax.InternalSyntax.SyntaxToken)openParenToken.Node!, (Syntax.InternalSyntax.ExpressionSyntax)expression.Green, (Syntax.InternalSyntax.SyntaxToken)closeParenToken.Node!).CreateRed();
        }

        /// <summary>Creates a new ParenthesizedExpressionSyntax instance.</summary>
        public static ParenthesizedExpressionSyntax ParenthesizedExpression(ExpressionSyntax expression)
            => SyntaxFactory.ParenthesizedExpression(SyntaxFactory.Token(SyntaxKind.OpenParenToken), expression, SyntaxFactory.Token(SyntaxKind.CloseParenToken));

        /// <summary>Creates a new ClassExpressionSyntax instance.</summary>
        public static ClassExpressionSyntax ClassExpression(SyntaxToken classKeyword, IdentifierNameSyntax name, SyntaxToken extendsKeyword, IdentifierNameSyntax baseName)
        {
            if (classKeyword.Kind() != SyntaxKind.ClassKeyword) throw new ArgumentException(nameof(classKeyword));
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (extendsKeyword.Kind() != SyntaxKind.ExtendsKeyword) throw new ArgumentException(nameof(extendsKeyword));
            if (baseName == null) throw new ArgumentNullException(nameof(baseName));
            return (ClassExpressionSyntax)Syntax.InternalSyntax.SyntaxFactory.ClassExpression((Syntax.InternalSyntax.SyntaxToken)classKeyword.Node!, (Syntax.InternalSyntax.IdentifierNameSyntax)name.Green, (Syntax.InternalSyntax.SyntaxToken)extendsKeyword.Node!, (Syntax.InternalSyntax.IdentifierNameSyntax)baseName.Green).CreateRed();
        }

        /// <summary>Creates a new ClassExpressionSyntax instance.</summary>
        public static ClassExpressionSyntax ClassExpression(IdentifierNameSyntax name, IdentifierNameSyntax baseName)
            => SyntaxFactory.ClassExpression(SyntaxFactory.Token(SyntaxKind.ClassKeyword), name, SyntaxFactory.Token(SyntaxKind.ExtendsKeyword), baseName);

        /// <summary>Creates a new ClassExpressionSyntax instance.</summary>
        public static ClassExpressionSyntax ClassExpression(string name, string baseName)
            => SyntaxFactory.ClassExpression(SyntaxFactory.Token(SyntaxKind.ClassKeyword), SyntaxFactory.IdentifierName(name), SyntaxFactory.Token(SyntaxKind.ExtendsKeyword), SyntaxFactory.IdentifierName(baseName));

        /// <summary>Creates a new AnomymousClassExpressionSyntax instance.</summary>
        public static AnomymousClassExpressionSyntax AnomymousClassExpression(SyntaxToken classKeyword, SyntaxToken extendsKeyword, IdentifierNameSyntax baseName)
        {
            if (classKeyword.Kind() != SyntaxKind.ClassKeyword) throw new ArgumentException(nameof(classKeyword));
            if (extendsKeyword.Kind() != SyntaxKind.ExtendsKeyword) throw new ArgumentException(nameof(extendsKeyword));
            if (baseName == null) throw new ArgumentNullException(nameof(baseName));
            return (AnomymousClassExpressionSyntax)Syntax.InternalSyntax.SyntaxFactory.AnomymousClassExpression((Syntax.InternalSyntax.SyntaxToken)classKeyword.Node!, (Syntax.InternalSyntax.SyntaxToken)extendsKeyword.Node!, (Syntax.InternalSyntax.IdentifierNameSyntax)baseName.Green).CreateRed();
        }

        /// <summary>Creates a new AnomymousClassExpressionSyntax instance.</summary>
        public static AnomymousClassExpressionSyntax AnomymousClassExpression(IdentifierNameSyntax baseName)
            => SyntaxFactory.AnomymousClassExpression(SyntaxFactory.Token(SyntaxKind.ClassKeyword), SyntaxFactory.Token(SyntaxKind.ExtendsKeyword), baseName);

        /// <summary>Creates a new AnomymousClassExpressionSyntax instance.</summary>
        public static AnomymousClassExpressionSyntax AnomymousClassExpression(string baseName)
            => SyntaxFactory.AnomymousClassExpression(SyntaxFactory.Token(SyntaxKind.ClassKeyword), SyntaxFactory.Token(SyntaxKind.ExtendsKeyword), SyntaxFactory.IdentifierName(baseName));

        /// <summary>Creates a new DoExpressionSyntax instance.</summary>
        public static DoExpressionSyntax DoExpression(SyntaxToken doKeyword, BlockSyntax block)
        {
            if (doKeyword.Kind() != SyntaxKind.DoKeyword) throw new ArgumentException(nameof(doKeyword));
            if (block == null) throw new ArgumentNullException(nameof(block));
            return (DoExpressionSyntax)Syntax.InternalSyntax.SyntaxFactory.DoExpression((Syntax.InternalSyntax.SyntaxToken)doKeyword.Node!, (Syntax.InternalSyntax.BlockSyntax)block.Green).CreateRed();
        }

        /// <summary>Creates a new DoExpressionSyntax instance.</summary>
        public static DoExpressionSyntax DoExpression(BlockSyntax? block = default)
            => SyntaxFactory.DoExpression(SyntaxFactory.Token(SyntaxKind.DoKeyword), block ?? SyntaxFactory.Block());

        /// <summary>Creates a new ForExpressionSyntax instance.</summary>
        public static ForExpressionSyntax ForExpression(SyntaxToken forKeyword, IdentifierNameSyntax name, SyntaxToken equalsToken, ExpressionSyntax initial, SyntaxToken firstCommaToken, ExpressionSyntax limit, SyntaxToken secondCommaToken, ExpressionSyntax step, BlockSyntax block)
        {
            if (forKeyword.Kind() != SyntaxKind.ForKeyword) throw new ArgumentException(nameof(forKeyword));
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (equalsToken.Kind() != SyntaxKind.EqualsToken) throw new ArgumentException(nameof(equalsToken));
            if (initial == null) throw new ArgumentNullException(nameof(initial));
            if (firstCommaToken.Kind() != SyntaxKind.CommaToken) throw new ArgumentException(nameof(firstCommaToken));
            if (limit == null) throw new ArgumentNullException(nameof(limit));
            if (secondCommaToken.Kind() != SyntaxKind.CommaToken) throw new ArgumentException(nameof(secondCommaToken));
            if (step == null) throw new ArgumentNullException(nameof(step));
            if (block == null) throw new ArgumentNullException(nameof(block));
            return (ForExpressionSyntax)Syntax.InternalSyntax.SyntaxFactory.ForExpression((Syntax.InternalSyntax.SyntaxToken)forKeyword.Node!, (Syntax.InternalSyntax.IdentifierNameSyntax)name.Green, (Syntax.InternalSyntax.SyntaxToken)equalsToken.Node!, (Syntax.InternalSyntax.ExpressionSyntax)initial.Green, (Syntax.InternalSyntax.SyntaxToken)firstCommaToken.Node!, (Syntax.InternalSyntax.ExpressionSyntax)limit.Green, (Syntax.InternalSyntax.SyntaxToken)secondCommaToken.Node!, (Syntax.InternalSyntax.ExpressionSyntax)step.Green, (Syntax.InternalSyntax.BlockSyntax)block.Green).CreateRed();
        }

        /// <summary>Creates a new ForExpressionSyntax instance.</summary>
        public static ForExpressionSyntax ForExpression(IdentifierNameSyntax name, ExpressionSyntax initial, ExpressionSyntax limit, ExpressionSyntax step, BlockSyntax block)
            => SyntaxFactory.ForExpression(SyntaxFactory.Token(SyntaxKind.ForKeyword), name, SyntaxFactory.Token(SyntaxKind.EqualsToken), initial, SyntaxFactory.Token(SyntaxKind.CommaToken), limit, SyntaxFactory.Token(SyntaxKind.CommaToken), step, block);

        /// <summary>Creates a new ForExpressionSyntax instance.</summary>
        public static ForExpressionSyntax ForExpression(IdentifierNameSyntax name, ExpressionSyntax initial, ExpressionSyntax limit, ExpressionSyntax step)
            => SyntaxFactory.ForExpression(SyntaxFactory.Token(SyntaxKind.ForKeyword), name, SyntaxFactory.Token(SyntaxKind.EqualsToken), initial, SyntaxFactory.Token(SyntaxKind.CommaToken), limit, SyntaxFactory.Token(SyntaxKind.CommaToken), step, SyntaxFactory.Block());

        /// <summary>Creates a new ForExpressionSyntax instance.</summary>
        public static ForExpressionSyntax ForExpression(string name, ExpressionSyntax initial, ExpressionSyntax limit, ExpressionSyntax step)
            => SyntaxFactory.ForExpression(SyntaxFactory.Token(SyntaxKind.ForKeyword), SyntaxFactory.IdentifierName(name), SyntaxFactory.Token(SyntaxKind.EqualsToken), initial, SyntaxFactory.Token(SyntaxKind.CommaToken), limit, SyntaxFactory.Token(SyntaxKind.CommaToken), step, SyntaxFactory.Block());

        /// <summary>Creates a new ForInExpressionSyntax instance.</summary>
        public static ForInExpressionSyntax ForInExpression(SyntaxToken forKeyword, SeparatedSyntaxList<ParameterSyntax> names, SyntaxToken inKeyword, ExpressionSyntax iteration, BlockSyntax block)
        {
            if (forKeyword.Kind() != SyntaxKind.ForKeyword) throw new ArgumentException(nameof(forKeyword));
            if (inKeyword.Kind() != SyntaxKind.InKeyword) throw new ArgumentException(nameof(inKeyword));
            if (iteration == null) throw new ArgumentNullException(nameof(iteration));
            if (block == null) throw new ArgumentNullException(nameof(block));
            return (ForInExpressionSyntax)Syntax.InternalSyntax.SyntaxFactory.ForInExpression((Syntax.InternalSyntax.SyntaxToken)forKeyword.Node!, names.Node.ToGreenSeparatedList<Syntax.InternalSyntax.ParameterSyntax>(), (Syntax.InternalSyntax.SyntaxToken)inKeyword.Node!, (Syntax.InternalSyntax.ExpressionSyntax)iteration.Green, (Syntax.InternalSyntax.BlockSyntax)block.Green).CreateRed();
        }

        /// <summary>Creates a new ForInExpressionSyntax instance.</summary>
        public static ForInExpressionSyntax ForInExpression(SeparatedSyntaxList<ParameterSyntax> names, ExpressionSyntax iteration, BlockSyntax block)
            => SyntaxFactory.ForInExpression(SyntaxFactory.Token(SyntaxKind.ForKeyword), names, SyntaxFactory.Token(SyntaxKind.InKeyword), iteration, block);

        /// <summary>Creates a new ForInExpressionSyntax instance.</summary>
        public static ForInExpressionSyntax ForInExpression(ExpressionSyntax iteration)
            => SyntaxFactory.ForInExpression(SyntaxFactory.Token(SyntaxKind.ForKeyword), default, SyntaxFactory.Token(SyntaxKind.InKeyword), iteration, SyntaxFactory.Block());

        /// <summary>Creates a new ChunkSyntax instance.</summary>
        public static ChunkSyntax Chunk(BlockSyntax block, SyntaxToken endOfFileToken)
        {
            if (block == null) throw new ArgumentNullException(nameof(block));
            if (endOfFileToken.Kind() != SyntaxKind.EndOfFileToken) throw new ArgumentException(nameof(endOfFileToken));
            return (ChunkSyntax)Syntax.InternalSyntax.SyntaxFactory.Chunk((Syntax.InternalSyntax.BlockSyntax)block.Green, (Syntax.InternalSyntax.SyntaxToken)endOfFileToken.Node!).CreateRed();
        }

        /// <summary>Creates a new ChunkSyntax instance.</summary>
        public static ChunkSyntax Chunk(BlockSyntax? block = default)
            => SyntaxFactory.Chunk(block ?? SyntaxFactory.Block(), SyntaxFactory.Token(SyntaxKind.EndOfFileToken));

        /// <summary>Creates a new BlockSyntax instance.</summary>
        public static BlockSyntax Block(SyntaxList<StatementSyntax> statements)
        {
            return (BlockSyntax)Syntax.InternalSyntax.SyntaxFactory.Block(statements.Node.ToGreenList<Syntax.InternalSyntax.StatementSyntax>()).CreateRed();
        }

        /// <summary>Creates a new BlockSyntax instance.</summary>
        public static BlockSyntax Block()
            => SyntaxFactory.Block(default);

        /// <summary>Creates a new SkippedTokensTriviaSyntax instance.</summary>
        public static SkippedTokensTriviaSyntax SkippedTokensTrivia(SyntaxTokenList tokens)
        {
            return (SkippedTokensTriviaSyntax)Syntax.InternalSyntax.SyntaxFactory.SkippedTokensTrivia(tokens.Node.ToGreenList<Syntax.InternalSyntax.SyntaxToken>()).CreateRed();
        }

        /// <summary>Creates a new SkippedTokensTriviaSyntax instance.</summary>
        public static SkippedTokensTriviaSyntax SkippedTokensTrivia()
            => SyntaxFactory.SkippedTokensTrivia(default(SyntaxTokenList));

        /// <summary>Creates a new ExpressionListSyntax instance.</summary>
        public static ExpressionListSyntax ExpressionList(SeparatedSyntaxList<ExpressionSyntax> expressions)
        {
            return (ExpressionListSyntax)Syntax.InternalSyntax.SyntaxFactory.ExpressionList(expressions.Node.ToGreenSeparatedList<Syntax.InternalSyntax.ExpressionSyntax>()).CreateRed();
        }

        /// <summary>Creates a new ExpressionListSyntax instance.</summary>
        public static ExpressionListSyntax ExpressionList()
            => SyntaxFactory.ExpressionList(default);

        /// <summary>Creates a new ParameterSyntax instance.</summary>
        public static ParameterSyntax Parameter(SyntaxToken identifier)
        {
            switch (identifier.Kind())
            {
                case SyntaxKind.IdentifierToken:
                case SyntaxKind.DotDotDotToken: break;
                default: throw new ArgumentException(nameof(identifier));
            }
            return (ParameterSyntax)Syntax.InternalSyntax.SyntaxFactory.Parameter((Syntax.InternalSyntax.SyntaxToken)identifier.Node!).CreateRed();
        }
    }
}
