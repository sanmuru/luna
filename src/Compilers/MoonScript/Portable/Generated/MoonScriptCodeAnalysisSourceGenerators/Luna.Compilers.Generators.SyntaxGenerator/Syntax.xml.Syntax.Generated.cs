// <auto-generated />

#nullable enable

using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Syntax.InternalSyntax;
using SamLu.CodeAnalysis.MoonScript;
using Roslyn.Utilities;

namespace SamLu.CodeAnalysis.MoonScript.Syntax
{
    using Microsoft.CodeAnalysis;

    /// <summary>提供表示名称语法节点继承用的父类，此类必须被继承。</summary>
    public abstract partial class NameSyntax : MoonScriptSyntaxNode
    {
        internal NameSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }
    }

    /// <summary>提供表示简单名称语法节点继承用的父类，此类必须被继承。</summary>
    public abstract partial class SimpleNameSyntax : NameSyntax
    {
        internal SimpleNameSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>表示简单名称的语法标志。</summary>
        public abstract SyntaxToken Identifier { get; }
        public SimpleNameSyntax WithIdentifier(SyntaxToken identifier) => WithIdentifierCore(identifier);
        internal abstract SimpleNameSyntax WithIdentifierCore(SyntaxToken identifier);
    }

    /// <summary>Class which represents the syntax node for identifier name.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.IdentifierName"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class IdentifierNameSyntax : SimpleNameSyntax
    {

        internal IdentifierNameSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>SyntaxToken representing the keyword for the kind of the identifier name.</summary>
        public override SyntaxToken Identifier => new SyntaxToken(this, ((Syntax.InternalSyntax.IdentifierNameSyntax)this.Green).identifier, Position, 0);

        internal override SyntaxNode? GetNodeSlot(int index) => null;

        internal override SyntaxNode? GetCachedSlot(int index) => null;

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitIdentifierName(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitIdentifierName(this);

        public IdentifierNameSyntax Update(SyntaxToken identifier)
        {
            if (identifier != this.Identifier)
            {
                var newNode = SyntaxFactory.IdentifierName(identifier);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        internal override SimpleNameSyntax WithIdentifierCore(SyntaxToken identifier) => WithIdentifier(identifier);
        public new IdentifierNameSyntax WithIdentifier(SyntaxToken identifier) => Update(identifier);
    }

    /// <summary>Provides the base class from which the classes that represent expression syntax nodes are derived. This is an abstract class.</summary>
    public abstract partial class ExpressionSyntax : MoonScriptSyntaxNode
    {
        internal ExpressionSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }
    }

    /// <summary>Class which represents the syntax node for a literal expression.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.NilLiteralExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.FalseLiteralExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.TrueLiteralExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.NumericLiteralExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.StringLiteralExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.VariousArgumentsExpression"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class LiteralExpressionSyntax : ExpressionSyntax
    {

        internal LiteralExpressionSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>SyntaxToken representing the keyword corresponding to the kind of the literal expression.</summary>
        public SyntaxToken Token => new SyntaxToken(this, ((Syntax.InternalSyntax.LiteralExpressionSyntax)this.Green).token, Position, 0);

        internal override SyntaxNode? GetNodeSlot(int index) => null;

        internal override SyntaxNode? GetCachedSlot(int index) => null;

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitLiteralExpression(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitLiteralExpression(this);

        public LiteralExpressionSyntax Update(SyntaxToken token)
        {
            if (token != this.Token)
            {
                var newNode = SyntaxFactory.LiteralExpression(this.Kind(), token);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public LiteralExpressionSyntax WithToken(SyntaxToken token) => Update(token);
    }

    public abstract partial class BaseInstanceExpressionSyntax : ExpressionSyntax
    {
        internal BaseInstanceExpressionSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public abstract SyntaxToken Token { get; }
        public BaseInstanceExpressionSyntax WithToken(SyntaxToken token) => WithTokenCore(token);
        internal abstract BaseInstanceExpressionSyntax WithTokenCore(SyntaxToken token);
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.SelfExpression"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class SelfExpressionSyntax : BaseInstanceExpressionSyntax
    {

        internal SelfExpressionSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public override SyntaxToken Token => new SyntaxToken(this, ((Syntax.InternalSyntax.SelfExpressionSyntax)this.Green).token, Position, 0);

        internal override SyntaxNode? GetNodeSlot(int index) => null;

        internal override SyntaxNode? GetCachedSlot(int index) => null;

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitSelfExpression(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitSelfExpression(this);

        public SelfExpressionSyntax Update(SyntaxToken token)
        {
            if (token != this.Token)
            {
                var newNode = SyntaxFactory.SelfExpression(token);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        internal override BaseInstanceExpressionSyntax WithTokenCore(SyntaxToken token) => WithToken(token);
        public new SelfExpressionSyntax WithToken(SyntaxToken token) => Update(token);
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.SuperExpression"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class SuperExpressionSyntax : BaseInstanceExpressionSyntax
    {

        internal SuperExpressionSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public override SyntaxToken Token => new SyntaxToken(this, ((Syntax.InternalSyntax.SuperExpressionSyntax)this.Green).token, Position, 0);

        internal override SyntaxNode? GetNodeSlot(int index) => null;

        internal override SyntaxNode? GetCachedSlot(int index) => null;

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitSuperExpression(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitSuperExpression(this);

        public SuperExpressionSyntax Update(SyntaxToken token)
        {
            if (token != this.Token)
            {
                var newNode = SyntaxFactory.SuperExpression(token);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        internal override BaseInstanceExpressionSyntax WithTokenCore(SyntaxToken token) => WithToken(token);
        public new SuperExpressionSyntax WithToken(SyntaxToken token) => Update(token);
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.TypeExpression"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class TypeExpressionSyntax : BaseInstanceExpressionSyntax
    {

        internal TypeExpressionSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public override SyntaxToken Token => new SyntaxToken(this, ((Syntax.InternalSyntax.TypeExpressionSyntax)this.Green).token, Position, 0);

        internal override SyntaxNode? GetNodeSlot(int index) => null;

        internal override SyntaxNode? GetCachedSlot(int index) => null;

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitTypeExpression(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitTypeExpression(this);

        public TypeExpressionSyntax Update(SyntaxToken token)
        {
            if (token != this.Token)
            {
                var newNode = SyntaxFactory.TypeExpression(token);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        internal override BaseInstanceExpressionSyntax WithTokenCore(SyntaxToken token) => WithToken(token);
        public new TypeExpressionSyntax WithToken(SyntaxToken token) => Update(token);
    }

    /// <summary>Class which represents the syntax node for parenthesized expression.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.ParenthesizedExpression"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ParenthesizedExpressionSyntax : ExpressionSyntax
    {
        private ExpressionSyntax? expression;

        internal ParenthesizedExpressionSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>SyntaxToken representing the open parenthesis.</summary>
        public SyntaxToken OpenParenToken => new SyntaxToken(this, ((Syntax.InternalSyntax.ParenthesizedExpressionSyntax)this.Green).openParenToken, Position, 0);

        /// <summary>ExpressionSyntax node representing the expression enclosed within the parenthesis.</summary>
        public ExpressionSyntax Expression => GetRed(ref this.expression, 1)!;

        /// <summary>SyntaxToken representing the close parenthesis.</summary>
        public SyntaxToken CloseParenToken => new SyntaxToken(this, ((Syntax.InternalSyntax.ParenthesizedExpressionSyntax)this.Green).closeParenToken, GetChildPosition(2), GetChildIndex(2));

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.expression, 1)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.expression : null;

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitParenthesizedExpression(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitParenthesizedExpression(this);

        public ParenthesizedExpressionSyntax Update(SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
        {
            if (openParenToken != this.OpenParenToken || expression != this.Expression || closeParenToken != this.CloseParenToken)
            {
                var newNode = SyntaxFactory.ParenthesizedExpression(openParenToken, expression, closeParenToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ParenthesizedExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken) => Update(openParenToken, this.Expression, this.CloseParenToken);
        public ParenthesizedExpressionSyntax WithExpression(ExpressionSyntax expression) => Update(this.OpenParenToken, expression, this.CloseParenToken);
        public ParenthesizedExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken) => Update(this.OpenParenToken, this.Expression, closeParenToken);
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.ClassExpression"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ClassExpressionSyntax : ExpressionSyntax
    {
        private IdentifierNameSyntax? name;
        private IdentifierNameSyntax? baseName;

        internal ClassExpressionSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken ClassKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.ClassExpressionSyntax)this.Green).classKeyword, Position, 0);

        public IdentifierNameSyntax Name => GetRed(ref this.name, 1)!;

        public SyntaxToken ExtendsKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.ClassExpressionSyntax)this.Green).extendsKeyword, GetChildPosition(2), GetChildIndex(2));

        public IdentifierNameSyntax BaseName => GetRed(ref this.baseName, 3)!;

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                1 => GetRed(ref this.name, 1)!,
                3 => GetRed(ref this.baseName, 3)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                1 => this.name,
                3 => this.baseName,
                _ => null,
            };

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitClassExpression(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitClassExpression(this);

        public ClassExpressionSyntax Update(SyntaxToken classKeyword, IdentifierNameSyntax name, SyntaxToken extendsKeyword, IdentifierNameSyntax baseName)
        {
            if (classKeyword != this.ClassKeyword || name != this.Name || extendsKeyword != this.ExtendsKeyword || baseName != this.BaseName)
            {
                var newNode = SyntaxFactory.ClassExpression(classKeyword, name, extendsKeyword, baseName);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ClassExpressionSyntax WithClassKeyword(SyntaxToken classKeyword) => Update(classKeyword, this.Name, this.ExtendsKeyword, this.BaseName);
        public ClassExpressionSyntax WithName(IdentifierNameSyntax name) => Update(this.ClassKeyword, name, this.ExtendsKeyword, this.BaseName);
        public ClassExpressionSyntax WithExtendsKeyword(SyntaxToken extendsKeyword) => Update(this.ClassKeyword, this.Name, extendsKeyword, this.BaseName);
        public ClassExpressionSyntax WithBaseName(IdentifierNameSyntax baseName) => Update(this.ClassKeyword, this.Name, this.ExtendsKeyword, baseName);
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.AnomymousClassExpression"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class AnomymousClassExpressionSyntax : ExpressionSyntax
    {
        private IdentifierNameSyntax? baseName;

        internal AnomymousClassExpressionSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken ClassKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.AnomymousClassExpressionSyntax)this.Green).classKeyword, Position, 0);

        public SyntaxToken ExtendsKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.AnomymousClassExpressionSyntax)this.Green).extendsKeyword, GetChildPosition(1), GetChildIndex(1));

        public IdentifierNameSyntax BaseName => GetRed(ref this.baseName, 2)!;

        internal override SyntaxNode? GetNodeSlot(int index) => index == 2 ? GetRed(ref this.baseName, 2)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 2 ? this.baseName : null;

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitAnomymousClassExpression(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitAnomymousClassExpression(this);

        public AnomymousClassExpressionSyntax Update(SyntaxToken classKeyword, SyntaxToken extendsKeyword, IdentifierNameSyntax baseName)
        {
            if (classKeyword != this.ClassKeyword || extendsKeyword != this.ExtendsKeyword || baseName != this.BaseName)
            {
                var newNode = SyntaxFactory.AnomymousClassExpression(classKeyword, extendsKeyword, baseName);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public AnomymousClassExpressionSyntax WithClassKeyword(SyntaxToken classKeyword) => Update(classKeyword, this.ExtendsKeyword, this.BaseName);
        public AnomymousClassExpressionSyntax WithExtendsKeyword(SyntaxToken extendsKeyword) => Update(this.ClassKeyword, extendsKeyword, this.BaseName);
        public AnomymousClassExpressionSyntax WithBaseName(IdentifierNameSyntax baseName) => Update(this.ClassKeyword, this.ExtendsKeyword, baseName);
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.DoExpression"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class DoExpressionSyntax : ExpressionSyntax
    {
        private BlockSyntax? block;

        internal DoExpressionSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken DoKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.DoExpressionSyntax)this.Green).doKeyword, Position, 0);

        public BlockSyntax Block => GetRed(ref this.block, 1)!;

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.block, 1)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.block : null;

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitDoExpression(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitDoExpression(this);

        public DoExpressionSyntax Update(SyntaxToken doKeyword, BlockSyntax block)
        {
            if (doKeyword != this.DoKeyword || block != this.Block)
            {
                var newNode = SyntaxFactory.DoExpression(doKeyword, block);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public DoExpressionSyntax WithDoKeyword(SyntaxToken doKeyword) => Update(doKeyword, this.Block);
        public DoExpressionSyntax WithBlock(BlockSyntax block) => Update(this.DoKeyword, block);

        public DoExpressionSyntax AddBlockStatements(params StatementSyntax[] items) => WithBlock(this.Block.WithStatements(this.Block.Statements.AddRange(items)));
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.ForExpression"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ForExpressionSyntax : ExpressionSyntax
    {
        private IdentifierNameSyntax? name;
        private ExpressionSyntax? initial;
        private ExpressionSyntax? limit;
        private ExpressionSyntax? step;
        private BlockSyntax? block;

        internal ForExpressionSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken ForKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.ForExpressionSyntax)this.Green).forKeyword, Position, 0);

        public IdentifierNameSyntax Name => GetRed(ref this.name, 1)!;

        public SyntaxToken EqualsToken => new SyntaxToken(this, ((Syntax.InternalSyntax.ForExpressionSyntax)this.Green).equalsToken, GetChildPosition(2), GetChildIndex(2));

        public ExpressionSyntax Initial => GetRed(ref this.initial, 3)!;

        public SyntaxToken FirstCommaToken => new SyntaxToken(this, ((Syntax.InternalSyntax.ForExpressionSyntax)this.Green).firstCommaToken, GetChildPosition(4), GetChildIndex(4));

        public ExpressionSyntax Limit => GetRed(ref this.limit, 5)!;

        public SyntaxToken SecondCommaToken => new SyntaxToken(this, ((Syntax.InternalSyntax.ForExpressionSyntax)this.Green).secondCommaToken, GetChildPosition(6), GetChildIndex(6));

        public ExpressionSyntax Step => GetRed(ref this.step, 7)!;

        public BlockSyntax Block => GetRed(ref this.block, 8)!;

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                1 => GetRed(ref this.name, 1)!,
                3 => GetRed(ref this.initial, 3)!,
                5 => GetRed(ref this.limit, 5)!,
                7 => GetRed(ref this.step, 7)!,
                8 => GetRed(ref this.block, 8)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                1 => this.name,
                3 => this.initial,
                5 => this.limit,
                7 => this.step,
                8 => this.block,
                _ => null,
            };

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitForExpression(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitForExpression(this);

        public ForExpressionSyntax Update(SyntaxToken forKeyword, IdentifierNameSyntax name, SyntaxToken equalsToken, ExpressionSyntax initial, SyntaxToken firstCommaToken, ExpressionSyntax limit, SyntaxToken secondCommaToken, ExpressionSyntax step, BlockSyntax block)
        {
            if (forKeyword != this.ForKeyword || name != this.Name || equalsToken != this.EqualsToken || initial != this.Initial || firstCommaToken != this.FirstCommaToken || limit != this.Limit || secondCommaToken != this.SecondCommaToken || step != this.Step || block != this.Block)
            {
                var newNode = SyntaxFactory.ForExpression(forKeyword, name, equalsToken, initial, firstCommaToken, limit, secondCommaToken, step, block);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ForExpressionSyntax WithForKeyword(SyntaxToken forKeyword) => Update(forKeyword, this.Name, this.EqualsToken, this.Initial, this.FirstCommaToken, this.Limit, this.SecondCommaToken, this.Step, this.Block);
        public ForExpressionSyntax WithName(IdentifierNameSyntax name) => Update(this.ForKeyword, name, this.EqualsToken, this.Initial, this.FirstCommaToken, this.Limit, this.SecondCommaToken, this.Step, this.Block);
        public ForExpressionSyntax WithEqualsToken(SyntaxToken equalsToken) => Update(this.ForKeyword, this.Name, equalsToken, this.Initial, this.FirstCommaToken, this.Limit, this.SecondCommaToken, this.Step, this.Block);
        public ForExpressionSyntax WithInitial(ExpressionSyntax initial) => Update(this.ForKeyword, this.Name, this.EqualsToken, initial, this.FirstCommaToken, this.Limit, this.SecondCommaToken, this.Step, this.Block);
        public ForExpressionSyntax WithFirstCommaToken(SyntaxToken firstCommaToken) => Update(this.ForKeyword, this.Name, this.EqualsToken, this.Initial, firstCommaToken, this.Limit, this.SecondCommaToken, this.Step, this.Block);
        public ForExpressionSyntax WithLimit(ExpressionSyntax limit) => Update(this.ForKeyword, this.Name, this.EqualsToken, this.Initial, this.FirstCommaToken, limit, this.SecondCommaToken, this.Step, this.Block);
        public ForExpressionSyntax WithSecondCommaToken(SyntaxToken secondCommaToken) => Update(this.ForKeyword, this.Name, this.EqualsToken, this.Initial, this.FirstCommaToken, this.Limit, secondCommaToken, this.Step, this.Block);
        public ForExpressionSyntax WithStep(ExpressionSyntax step) => Update(this.ForKeyword, this.Name, this.EqualsToken, this.Initial, this.FirstCommaToken, this.Limit, this.SecondCommaToken, step, this.Block);
        public ForExpressionSyntax WithBlock(BlockSyntax block) => Update(this.ForKeyword, this.Name, this.EqualsToken, this.Initial, this.FirstCommaToken, this.Limit, this.SecondCommaToken, this.Step, block);

        public ForExpressionSyntax AddBlockStatements(params StatementSyntax[] items) => WithBlock(this.Block.WithStatements(this.Block.Statements.AddRange(items)));
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.ForInExpression"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ForInExpressionSyntax : ExpressionSyntax
    {
        private SyntaxNode? names;
        private ExpressionSyntax? iteration;
        private BlockSyntax? block;

        internal ForInExpressionSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken ForKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.ForInExpressionSyntax)this.Green).forKeyword, Position, 0);

        public SeparatedSyntaxList<ParameterSyntax> Names
        {
            get
            {
                var red = GetRed(ref this.names, 1);
                return red != null ? new SeparatedSyntaxList<ParameterSyntax>(red, GetChildIndex(1)) : default;
            }
        }

        public SyntaxToken InKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.ForInExpressionSyntax)this.Green).inKeyword, GetChildPosition(2), GetChildIndex(2));

        public ExpressionSyntax Iteration => GetRed(ref this.iteration, 3)!;

        public BlockSyntax Block => GetRed(ref this.block, 4)!;

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                1 => GetRed(ref this.names, 1)!,
                3 => GetRed(ref this.iteration, 3)!,
                4 => GetRed(ref this.block, 4)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                1 => this.names,
                3 => this.iteration,
                4 => this.block,
                _ => null,
            };

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitForInExpression(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitForInExpression(this);

        public ForInExpressionSyntax Update(SyntaxToken forKeyword, SeparatedSyntaxList<ParameterSyntax> names, SyntaxToken inKeyword, ExpressionSyntax iteration, BlockSyntax block)
        {
            if (forKeyword != this.ForKeyword || names != this.Names || inKeyword != this.InKeyword || iteration != this.Iteration || block != this.Block)
            {
                var newNode = SyntaxFactory.ForInExpression(forKeyword, names, inKeyword, iteration, block);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ForInExpressionSyntax WithForKeyword(SyntaxToken forKeyword) => Update(forKeyword, this.Names, this.InKeyword, this.Iteration, this.Block);
        public ForInExpressionSyntax WithNames(SeparatedSyntaxList<ParameterSyntax> names) => Update(this.ForKeyword, names, this.InKeyword, this.Iteration, this.Block);
        public ForInExpressionSyntax WithInKeyword(SyntaxToken inKeyword) => Update(this.ForKeyword, this.Names, inKeyword, this.Iteration, this.Block);
        public ForInExpressionSyntax WithIteration(ExpressionSyntax iteration) => Update(this.ForKeyword, this.Names, this.InKeyword, iteration, this.Block);
        public ForInExpressionSyntax WithBlock(BlockSyntax block) => Update(this.ForKeyword, this.Names, this.InKeyword, this.Iteration, block);

        public ForInExpressionSyntax AddNames(params ParameterSyntax[] items) => WithNames(this.Names.AddRange(items));
        public ForInExpressionSyntax AddBlockStatements(params StatementSyntax[] items) => WithBlock(this.Block.WithStatements(this.Block.Statements.AddRange(items)));
    }

    /// <summary>Provides the base class from which the classes that represent statement syntax nodes are derived. This is an abstract class.</summary>
    public abstract partial class StatementSyntax : MoonScriptSyntaxNode
    {
        internal StatementSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.Chunk"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ChunkSyntax : MoonScriptSyntaxNode
    {
        private BlockSyntax? block;

        internal ChunkSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public BlockSyntax Block => GetRedAtZero(ref this.block)!;

        public SyntaxToken EndOfFileToken => new SyntaxToken(this, ((Syntax.InternalSyntax.ChunkSyntax)this.Green).endOfFileToken, GetChildPosition(1), GetChildIndex(1));

        internal override SyntaxNode? GetNodeSlot(int index) => index == 0 ? GetRedAtZero(ref this.block)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 0 ? this.block : null;

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitChunk(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitChunk(this);

        public ChunkSyntax Update(BlockSyntax block, SyntaxToken endOfFileToken)
        {
            if (block != this.Block || endOfFileToken != this.EndOfFileToken)
            {
                var newNode = SyntaxFactory.Chunk(block, endOfFileToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ChunkSyntax WithBlock(BlockSyntax block) => Update(block, this.EndOfFileToken);
        public ChunkSyntax WithEndOfFileToken(SyntaxToken endOfFileToken) => Update(this.Block, endOfFileToken);

        public ChunkSyntax AddBlockStatements(params StatementSyntax[] items) => WithBlock(this.Block.WithStatements(this.Block.Statements.AddRange(items)));
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.Block"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class BlockSyntax : MoonScriptSyntaxNode
    {
        private SyntaxNode? statements;

        internal BlockSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxList<StatementSyntax> Statements => new SyntaxList<StatementSyntax>(GetRed(ref this.statements, 0));

        internal override SyntaxNode? GetNodeSlot(int index) => index == 0 ? GetRedAtZero(ref this.statements)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 0 ? this.statements : null;

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitBlock(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitBlock(this);

        public BlockSyntax Update(SyntaxList<StatementSyntax> statements)
        {
            if (statements != this.Statements)
            {
                var newNode = SyntaxFactory.Block(statements);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public BlockSyntax WithStatements(SyntaxList<StatementSyntax> statements) => Update(statements);

        public BlockSyntax AddStatements(params StatementSyntax[] items) => WithStatements(this.Statements.AddRange(items));
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.SkippedTokensTrivia"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class SkippedTokensTriviaSyntax : StructuredTriviaSyntax
    {

        internal SkippedTokensTriviaSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxTokenList Tokens
        {
            get
            {
                var slot = this.Green.GetSlot(0);
                return slot != null ? new SyntaxTokenList(this, slot, Position, 0) : default;
            }
        }

        internal override SyntaxNode? GetNodeSlot(int index) => null;

        internal override SyntaxNode? GetCachedSlot(int index) => null;

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitSkippedTokensTrivia(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitSkippedTokensTrivia(this);

        public SkippedTokensTriviaSyntax Update(SyntaxTokenList tokens)
        {
            if (tokens != this.Tokens)
            {
                var newNode = SyntaxFactory.SkippedTokensTrivia(tokens);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public SkippedTokensTriviaSyntax WithTokens(SyntaxTokenList tokens) => Update(tokens);

        public SkippedTokensTriviaSyntax AddTokens(params SyntaxToken[] items) => WithTokens(this.Tokens.AddRange(items));
    }

    /// <summary>Class which represents the syntax node for the list of expressions.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.ExpressionList"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ExpressionListSyntax : MoonScriptSyntaxNode
    {
        private SyntaxNode? expressions;

        internal ExpressionListSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>SeparatedSyntaxList of ExpressionSyntax nodes representing the list of expressions.</summary>
        public SeparatedSyntaxList<ExpressionSyntax> Expressions
        {
            get
            {
                var red = GetRed(ref this.expressions, 0);
                return red != null ? new SeparatedSyntaxList<ExpressionSyntax>(red, 0) : default;
            }
        }

        internal override SyntaxNode? GetNodeSlot(int index) => index == 0 ? GetRedAtZero(ref this.expressions)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 0 ? this.expressions : null;

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitExpressionList(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitExpressionList(this);

        public ExpressionListSyntax Update(SeparatedSyntaxList<ExpressionSyntax> expressions)
        {
            if (expressions != this.Expressions)
            {
                var newNode = SyntaxFactory.ExpressionList(expressions);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ExpressionListSyntax WithExpressions(SeparatedSyntaxList<ExpressionSyntax> expressions) => Update(expressions);

        public ExpressionListSyntax AddExpressions(params ExpressionSyntax[] items) => WithExpressions(this.Expressions.AddRange(items));
    }

    /// <summary>Parameter syntax.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.Parameter"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ParameterSyntax : MoonScriptSyntaxNode
    {

        internal ParameterSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>Gets the identifier.</summary>
        public SyntaxToken Identifier => new SyntaxToken(this, ((Syntax.InternalSyntax.ParameterSyntax)this.Green).identifier, Position, 0);

        internal override SyntaxNode? GetNodeSlot(int index) => null;

        internal override SyntaxNode? GetCachedSlot(int index) => null;

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitParameter(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitParameter(this);

        public ParameterSyntax Update(SyntaxToken identifier)
        {
            if (identifier != this.Identifier)
            {
                var newNode = SyntaxFactory.Parameter(identifier);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ParameterSyntax WithIdentifier(SyntaxToken identifier) => Update(identifier);
    }
}
