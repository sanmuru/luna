// <auto-generated />

#nullable enable

using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Syntax.InternalSyntax;
using SamLu.CodeAnalysis.MoonScript;
using Roslyn.Utilities;

namespace SamLu.CodeAnalysis.MoonScript.Syntax
{
    using Microsoft.CodeAnalysis;

    /// <summary>提供表示名称语法节点继承用的父类，此类必须被继承。</summary>
    public abstract partial class NameSyntax : MoonScriptSyntaxNode
    {
        internal NameSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }
    }

    /// <summary>提供表示简单名称语法节点继承用的父类，此类必须被继承。</summary>
    public abstract partial class SimpleNameSyntax : NameSyntax
    {
        internal SimpleNameSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>表示简单名称的语法标志。</summary>
        public abstract SyntaxToken Identifier { get; }
        public SimpleNameSyntax WithIdentifier(SyntaxToken identifier) => WithIdentifierCore(identifier);
        internal abstract SimpleNameSyntax WithIdentifierCore(SyntaxToken identifier);
    }

    /// <summary>Class which represents the syntax node for identifier name.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.IdentifierName"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class IdentifierNameSyntax : SimpleNameSyntax
    {

        internal IdentifierNameSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>SyntaxToken representing the keyword for the kind of the identifier name.</summary>
        public override SyntaxToken Identifier => new SyntaxToken(this, ((Syntax.InternalSyntax.IdentifierNameSyntax)this.Green).identifier, Position, 0);

        internal override SyntaxNode? GetNodeSlot(int index) => null;

        internal override SyntaxNode? GetCachedSlot(int index) => null;

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitIdentifierName(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitIdentifierName(this);

        public IdentifierNameSyntax Update(SyntaxToken identifier)
        {
            if (identifier != this.Identifier)
            {
                var newNode = SyntaxFactory.IdentifierName(identifier);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        internal override SimpleNameSyntax WithIdentifierCore(SyntaxToken identifier) => WithIdentifier(identifier);
        public new IdentifierNameSyntax WithIdentifier(SyntaxToken identifier) => Update(identifier);
    }

    /// <summary>Provides the base class from which the classes that represent expression syntax nodes are derived. This is an abstract class.</summary>
    public abstract partial class ExpressionSyntax : MoonScriptSyntaxNode
    {
        internal ExpressionSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }
    }

    /// <summary>Class which represents the syntax node for a literal expression.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.NilLiteralExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.FalseLiteralExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.TrueLiteralExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.NumericLiteralExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.StringLiteralExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.VariousArgumentsExpression"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class LiteralExpressionSyntax : ExpressionSyntax
    {

        internal LiteralExpressionSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>SyntaxToken representing the keyword corresponding to the kind of the literal expression.</summary>
        public SyntaxToken Token => new SyntaxToken(this, ((Syntax.InternalSyntax.LiteralExpressionSyntax)this.Green).token, Position, 0);

        internal override SyntaxNode? GetNodeSlot(int index) => null;

        internal override SyntaxNode? GetCachedSlot(int index) => null;

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitLiteralExpression(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitLiteralExpression(this);

        public LiteralExpressionSyntax Update(SyntaxToken token)
        {
            if (token != this.Token)
            {
                var newNode = SyntaxFactory.LiteralExpression(this.Kind(), token);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public LiteralExpressionSyntax WithToken(SyntaxToken token) => Update(token);
    }

    public abstract partial class BaseInstanceExpressionSyntax : ExpressionSyntax
    {
        internal BaseInstanceExpressionSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public abstract SyntaxToken Token { get; }
        public BaseInstanceExpressionSyntax WithToken(SyntaxToken token) => WithTokenCore(token);
        internal abstract BaseInstanceExpressionSyntax WithTokenCore(SyntaxToken token);
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.SelfExpression"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class SelfExpressionSyntax : BaseInstanceExpressionSyntax
    {

        internal SelfExpressionSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public override SyntaxToken Token => new SyntaxToken(this, ((Syntax.InternalSyntax.SelfExpressionSyntax)this.Green).token, Position, 0);

        internal override SyntaxNode? GetNodeSlot(int index) => null;

        internal override SyntaxNode? GetCachedSlot(int index) => null;

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitSelfExpression(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitSelfExpression(this);

        public SelfExpressionSyntax Update(SyntaxToken token)
        {
            if (token != this.Token)
            {
                var newNode = SyntaxFactory.SelfExpression(token);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        internal override BaseInstanceExpressionSyntax WithTokenCore(SyntaxToken token) => WithToken(token);
        public new SelfExpressionSyntax WithToken(SyntaxToken token) => Update(token);
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.SuperExpression"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class SuperExpressionSyntax : BaseInstanceExpressionSyntax
    {

        internal SuperExpressionSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public override SyntaxToken Token => new SyntaxToken(this, ((Syntax.InternalSyntax.SuperExpressionSyntax)this.Green).token, Position, 0);

        internal override SyntaxNode? GetNodeSlot(int index) => null;

        internal override SyntaxNode? GetCachedSlot(int index) => null;

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitSuperExpression(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitSuperExpression(this);

        public SuperExpressionSyntax Update(SyntaxToken token)
        {
            if (token != this.Token)
            {
                var newNode = SyntaxFactory.SuperExpression(token);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        internal override BaseInstanceExpressionSyntax WithTokenCore(SyntaxToken token) => WithToken(token);
        public new SuperExpressionSyntax WithToken(SyntaxToken token) => Update(token);
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.TypeExpression"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class TypeExpressionSyntax : BaseInstanceExpressionSyntax
    {

        internal TypeExpressionSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public override SyntaxToken Token => new SyntaxToken(this, ((Syntax.InternalSyntax.TypeExpressionSyntax)this.Green).token, Position, 0);

        internal override SyntaxNode? GetNodeSlot(int index) => null;

        internal override SyntaxNode? GetCachedSlot(int index) => null;

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitTypeExpression(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitTypeExpression(this);

        public TypeExpressionSyntax Update(SyntaxToken token)
        {
            if (token != this.Token)
            {
                var newNode = SyntaxFactory.TypeExpression(token);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        internal override BaseInstanceExpressionSyntax WithTokenCore(SyntaxToken token) => WithToken(token);
        public new TypeExpressionSyntax WithToken(SyntaxToken token) => Update(token);
    }

    /// <summary>Class which represents the syntax node for parenthesized expression.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.ParenthesizedExpression"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ParenthesizedExpressionSyntax : ExpressionSyntax
    {
        private ExpressionSyntax? expression;

        internal ParenthesizedExpressionSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>SyntaxToken representing the open parenthesis.</summary>
        public SyntaxToken OpenParenToken => new SyntaxToken(this, ((Syntax.InternalSyntax.ParenthesizedExpressionSyntax)this.Green).openParenToken, Position, 0);

        /// <summary>ExpressionSyntax node representing the expression enclosed within the parenthesis.</summary>
        public ExpressionSyntax Expression => GetRed(ref this.expression, 1)!;

        /// <summary>SyntaxToken representing the close parenthesis.</summary>
        public SyntaxToken CloseParenToken => new SyntaxToken(this, ((Syntax.InternalSyntax.ParenthesizedExpressionSyntax)this.Green).closeParenToken, GetChildPosition(2), GetChildIndex(2));

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.expression, 1)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.expression : null;

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitParenthesizedExpression(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitParenthesizedExpression(this);

        public ParenthesizedExpressionSyntax Update(SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
        {
            if (openParenToken != this.OpenParenToken || expression != this.Expression || closeParenToken != this.CloseParenToken)
            {
                var newNode = SyntaxFactory.ParenthesizedExpression(openParenToken, expression, closeParenToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ParenthesizedExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken) => Update(openParenToken, this.Expression, this.CloseParenToken);
        public ParenthesizedExpressionSyntax WithExpression(ExpressionSyntax expression) => Update(this.OpenParenToken, expression, this.CloseParenToken);
        public ParenthesizedExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken) => Update(this.OpenParenToken, this.Expression, closeParenToken);
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.ClassExpression"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ClassExpressionSyntax : ExpressionSyntax
    {
        private IdentifierNameSyntax? name;
        private IdentifierNameSyntax? baseName;
        private SyntaxNode? statements;

        internal ClassExpressionSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken ClassKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.ClassExpressionSyntax)this.Green).classKeyword, Position, 0);

        public IdentifierNameSyntax Name => GetRed(ref this.name, 1)!;

        public SyntaxToken ExtendsKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.ClassExpressionSyntax)this.Green).extendsKeyword, GetChildPosition(2), GetChildIndex(2));

        public IdentifierNameSyntax BaseName => GetRed(ref this.baseName, 3)!;

        public SyntaxList<StatementSyntax> Statements => new SyntaxList<StatementSyntax>(GetRed(ref this.statements, 4));

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                1 => GetRed(ref this.name, 1)!,
                3 => GetRed(ref this.baseName, 3)!,
                4 => GetRed(ref this.statements, 4)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                1 => this.name,
                3 => this.baseName,
                4 => this.statements,
                _ => null,
            };

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitClassExpression(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitClassExpression(this);

        public ClassExpressionSyntax Update(SyntaxToken classKeyword, IdentifierNameSyntax name, SyntaxToken extendsKeyword, IdentifierNameSyntax baseName, SyntaxList<StatementSyntax> statements)
        {
            if (classKeyword != this.ClassKeyword || name != this.Name || extendsKeyword != this.ExtendsKeyword || baseName != this.BaseName || statements != this.Statements)
            {
                var newNode = SyntaxFactory.ClassExpression(classKeyword, name, extendsKeyword, baseName, statements);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ClassExpressionSyntax WithClassKeyword(SyntaxToken classKeyword) => Update(classKeyword, this.Name, this.ExtendsKeyword, this.BaseName, this.Statements);
        public ClassExpressionSyntax WithName(IdentifierNameSyntax name) => Update(this.ClassKeyword, name, this.ExtendsKeyword, this.BaseName, this.Statements);
        public ClassExpressionSyntax WithExtendsKeyword(SyntaxToken extendsKeyword) => Update(this.ClassKeyword, this.Name, extendsKeyword, this.BaseName, this.Statements);
        public ClassExpressionSyntax WithBaseName(IdentifierNameSyntax baseName) => Update(this.ClassKeyword, this.Name, this.ExtendsKeyword, baseName, this.Statements);
        public ClassExpressionSyntax WithStatements(SyntaxList<StatementSyntax> statements) => Update(this.ClassKeyword, this.Name, this.ExtendsKeyword, this.BaseName, statements);

        public ClassExpressionSyntax AddStatements(params StatementSyntax[] items) => WithStatements(this.Statements.AddRange(items));
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.AnomymousClassExpression"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class AnomymousClassExpressionSyntax : ExpressionSyntax
    {
        private IdentifierNameSyntax? baseName;
        private SyntaxNode? statements;

        internal AnomymousClassExpressionSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken ClassKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.AnomymousClassExpressionSyntax)this.Green).classKeyword, Position, 0);

        public SyntaxToken ExtendsKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.AnomymousClassExpressionSyntax)this.Green).extendsKeyword, GetChildPosition(1), GetChildIndex(1));

        public IdentifierNameSyntax BaseName => GetRed(ref this.baseName, 2)!;

        public SyntaxList<StatementSyntax> Statements => new SyntaxList<StatementSyntax>(GetRed(ref this.statements, 3));

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                2 => GetRed(ref this.baseName, 2)!,
                3 => GetRed(ref this.statements, 3)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                2 => this.baseName,
                3 => this.statements,
                _ => null,
            };

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitAnomymousClassExpression(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitAnomymousClassExpression(this);

        public AnomymousClassExpressionSyntax Update(SyntaxToken classKeyword, SyntaxToken extendsKeyword, IdentifierNameSyntax baseName, SyntaxList<StatementSyntax> statements)
        {
            if (classKeyword != this.ClassKeyword || extendsKeyword != this.ExtendsKeyword || baseName != this.BaseName || statements != this.Statements)
            {
                var newNode = SyntaxFactory.AnomymousClassExpression(classKeyword, extendsKeyword, baseName, statements);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public AnomymousClassExpressionSyntax WithClassKeyword(SyntaxToken classKeyword) => Update(classKeyword, this.ExtendsKeyword, this.BaseName, this.Statements);
        public AnomymousClassExpressionSyntax WithExtendsKeyword(SyntaxToken extendsKeyword) => Update(this.ClassKeyword, extendsKeyword, this.BaseName, this.Statements);
        public AnomymousClassExpressionSyntax WithBaseName(IdentifierNameSyntax baseName) => Update(this.ClassKeyword, this.ExtendsKeyword, baseName, this.Statements);
        public AnomymousClassExpressionSyntax WithStatements(SyntaxList<StatementSyntax> statements) => Update(this.ClassKeyword, this.ExtendsKeyword, this.BaseName, statements);

        public AnomymousClassExpressionSyntax AddStatements(params StatementSyntax[] items) => WithStatements(this.Statements.AddRange(items));
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.DoExpression"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class DoExpressionSyntax : ExpressionSyntax
    {
        private BlockSyntax? block;

        internal DoExpressionSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken DoKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.DoExpressionSyntax)this.Green).doKeyword, Position, 0);

        public BlockSyntax Block => GetRed(ref this.block, 1)!;

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.block, 1)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.block : null;

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitDoExpression(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitDoExpression(this);

        public DoExpressionSyntax Update(SyntaxToken doKeyword, BlockSyntax block)
        {
            if (doKeyword != this.DoKeyword || block != this.Block)
            {
                var newNode = SyntaxFactory.DoExpression(doKeyword, block);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public DoExpressionSyntax WithDoKeyword(SyntaxToken doKeyword) => Update(doKeyword, this.Block);
        public DoExpressionSyntax WithBlock(BlockSyntax block) => Update(this.DoKeyword, block);

        public DoExpressionSyntax AddBlockStatements(params StatementSyntax[] items) => WithBlock(this.Block.WithStatements(this.Block.Statements.AddRange(items)));
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.ForExpression"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ForExpressionSyntax : ExpressionSyntax
    {
        private IdentifierNameSyntax? name;
        private ExpressionSyntax? initial;
        private ExpressionSyntax? limit;
        private ExpressionSyntax? step;
        private BlockSyntax? block;

        internal ForExpressionSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken ForKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.ForExpressionSyntax)this.Green).forKeyword, Position, 0);

        public IdentifierNameSyntax Name => GetRed(ref this.name, 1)!;

        public SyntaxToken EqualsToken => new SyntaxToken(this, ((Syntax.InternalSyntax.ForExpressionSyntax)this.Green).equalsToken, GetChildPosition(2), GetChildIndex(2));

        public ExpressionSyntax Initial => GetRed(ref this.initial, 3)!;

        public SyntaxToken FirstCommaToken => new SyntaxToken(this, ((Syntax.InternalSyntax.ForExpressionSyntax)this.Green).firstCommaToken, GetChildPosition(4), GetChildIndex(4));

        public ExpressionSyntax Limit => GetRed(ref this.limit, 5)!;

        public SyntaxToken SecondCommaToken => new SyntaxToken(this, ((Syntax.InternalSyntax.ForExpressionSyntax)this.Green).secondCommaToken, GetChildPosition(6), GetChildIndex(6));

        public ExpressionSyntax Step => GetRed(ref this.step, 7)!;

        public SyntaxToken DoKeyword
        {
            get
            {
                var slot = ((Syntax.InternalSyntax.ForExpressionSyntax)this.Green).doKeyword;
                return slot != null ? new SyntaxToken(this, slot, GetChildPosition(8), GetChildIndex(8)) : default;
            }
        }

        public BlockSyntax Block => GetRed(ref this.block, 9)!;

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                1 => GetRed(ref this.name, 1)!,
                3 => GetRed(ref this.initial, 3)!,
                5 => GetRed(ref this.limit, 5)!,
                7 => GetRed(ref this.step, 7)!,
                9 => GetRed(ref this.block, 9)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                1 => this.name,
                3 => this.initial,
                5 => this.limit,
                7 => this.step,
                9 => this.block,
                _ => null,
            };

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitForExpression(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitForExpression(this);

        public ForExpressionSyntax Update(SyntaxToken forKeyword, IdentifierNameSyntax name, SyntaxToken equalsToken, ExpressionSyntax initial, SyntaxToken firstCommaToken, ExpressionSyntax limit, SyntaxToken secondCommaToken, ExpressionSyntax step, SyntaxToken doKeyword, BlockSyntax block)
        {
            if (forKeyword != this.ForKeyword || name != this.Name || equalsToken != this.EqualsToken || initial != this.Initial || firstCommaToken != this.FirstCommaToken || limit != this.Limit || secondCommaToken != this.SecondCommaToken || step != this.Step || doKeyword != this.DoKeyword || block != this.Block)
            {
                var newNode = SyntaxFactory.ForExpression(forKeyword, name, equalsToken, initial, firstCommaToken, limit, secondCommaToken, step, doKeyword, block);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ForExpressionSyntax WithForKeyword(SyntaxToken forKeyword) => Update(forKeyword, this.Name, this.EqualsToken, this.Initial, this.FirstCommaToken, this.Limit, this.SecondCommaToken, this.Step, this.DoKeyword, this.Block);
        public ForExpressionSyntax WithName(IdentifierNameSyntax name) => Update(this.ForKeyword, name, this.EqualsToken, this.Initial, this.FirstCommaToken, this.Limit, this.SecondCommaToken, this.Step, this.DoKeyword, this.Block);
        public ForExpressionSyntax WithEqualsToken(SyntaxToken equalsToken) => Update(this.ForKeyword, this.Name, equalsToken, this.Initial, this.FirstCommaToken, this.Limit, this.SecondCommaToken, this.Step, this.DoKeyword, this.Block);
        public ForExpressionSyntax WithInitial(ExpressionSyntax initial) => Update(this.ForKeyword, this.Name, this.EqualsToken, initial, this.FirstCommaToken, this.Limit, this.SecondCommaToken, this.Step, this.DoKeyword, this.Block);
        public ForExpressionSyntax WithFirstCommaToken(SyntaxToken firstCommaToken) => Update(this.ForKeyword, this.Name, this.EqualsToken, this.Initial, firstCommaToken, this.Limit, this.SecondCommaToken, this.Step, this.DoKeyword, this.Block);
        public ForExpressionSyntax WithLimit(ExpressionSyntax limit) => Update(this.ForKeyword, this.Name, this.EqualsToken, this.Initial, this.FirstCommaToken, limit, this.SecondCommaToken, this.Step, this.DoKeyword, this.Block);
        public ForExpressionSyntax WithSecondCommaToken(SyntaxToken secondCommaToken) => Update(this.ForKeyword, this.Name, this.EqualsToken, this.Initial, this.FirstCommaToken, this.Limit, secondCommaToken, this.Step, this.DoKeyword, this.Block);
        public ForExpressionSyntax WithStep(ExpressionSyntax step) => Update(this.ForKeyword, this.Name, this.EqualsToken, this.Initial, this.FirstCommaToken, this.Limit, this.SecondCommaToken, step, this.DoKeyword, this.Block);
        public ForExpressionSyntax WithDoKeyword(SyntaxToken doKeyword) => Update(this.ForKeyword, this.Name, this.EqualsToken, this.Initial, this.FirstCommaToken, this.Limit, this.SecondCommaToken, this.Step, doKeyword, this.Block);
        public ForExpressionSyntax WithBlock(BlockSyntax block) => Update(this.ForKeyword, this.Name, this.EqualsToken, this.Initial, this.FirstCommaToken, this.Limit, this.SecondCommaToken, this.Step, this.DoKeyword, block);

        public ForExpressionSyntax AddBlockStatements(params StatementSyntax[] items) => WithBlock(this.Block.WithStatements(this.Block.Statements.AddRange(items)));
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.ForInExpression"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ForInExpressionSyntax : ExpressionSyntax
    {
        private SyntaxNode? names;
        private ExpressionSyntax? iteration;
        private BlockSyntax? block;

        internal ForInExpressionSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken ForKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.ForInExpressionSyntax)this.Green).forKeyword, Position, 0);

        public SeparatedSyntaxList<IdentifierNameSyntax> Names
        {
            get
            {
                var red = GetRed(ref this.names, 1);
                return red != null ? new SeparatedSyntaxList<IdentifierNameSyntax>(red, GetChildIndex(1)) : default;
            }
        }

        public SyntaxToken InKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.ForInExpressionSyntax)this.Green).inKeyword, GetChildPosition(2), GetChildIndex(2));

        public ExpressionSyntax Iteration => GetRed(ref this.iteration, 3)!;

        public SyntaxToken DoKeyword
        {
            get
            {
                var slot = ((Syntax.InternalSyntax.ForInExpressionSyntax)this.Green).doKeyword;
                return slot != null ? new SyntaxToken(this, slot, GetChildPosition(4), GetChildIndex(4)) : default;
            }
        }

        public BlockSyntax Block => GetRed(ref this.block, 5)!;

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                1 => GetRed(ref this.names, 1)!,
                3 => GetRed(ref this.iteration, 3)!,
                5 => GetRed(ref this.block, 5)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                1 => this.names,
                3 => this.iteration,
                5 => this.block,
                _ => null,
            };

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitForInExpression(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitForInExpression(this);

        public ForInExpressionSyntax Update(SyntaxToken forKeyword, SeparatedSyntaxList<IdentifierNameSyntax> names, SyntaxToken inKeyword, ExpressionSyntax iteration, SyntaxToken doKeyword, BlockSyntax block)
        {
            if (forKeyword != this.ForKeyword || names != this.Names || inKeyword != this.InKeyword || iteration != this.Iteration || doKeyword != this.DoKeyword || block != this.Block)
            {
                var newNode = SyntaxFactory.ForInExpression(forKeyword, names, inKeyword, iteration, doKeyword, block);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ForInExpressionSyntax WithForKeyword(SyntaxToken forKeyword) => Update(forKeyword, this.Names, this.InKeyword, this.Iteration, this.DoKeyword, this.Block);
        public ForInExpressionSyntax WithNames(SeparatedSyntaxList<IdentifierNameSyntax> names) => Update(this.ForKeyword, names, this.InKeyword, this.Iteration, this.DoKeyword, this.Block);
        public ForInExpressionSyntax WithInKeyword(SyntaxToken inKeyword) => Update(this.ForKeyword, this.Names, inKeyword, this.Iteration, this.DoKeyword, this.Block);
        public ForInExpressionSyntax WithIteration(ExpressionSyntax iteration) => Update(this.ForKeyword, this.Names, this.InKeyword, iteration, this.DoKeyword, this.Block);
        public ForInExpressionSyntax WithDoKeyword(SyntaxToken doKeyword) => Update(this.ForKeyword, this.Names, this.InKeyword, this.Iteration, doKeyword, this.Block);
        public ForInExpressionSyntax WithBlock(BlockSyntax block) => Update(this.ForKeyword, this.Names, this.InKeyword, this.Iteration, this.DoKeyword, block);

        public ForInExpressionSyntax AddNames(params IdentifierNameSyntax[] items) => WithNames(this.Names.AddRange(items));
        public ForInExpressionSyntax AddBlockStatements(params StatementSyntax[] items) => WithBlock(this.Block.WithStatements(this.Block.Statements.AddRange(items)));
    }

    public abstract partial class BaseConditionalExpressionSyntax : ExpressionSyntax
    {
        internal BaseConditionalExpressionSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public abstract ExpressionSyntax Condition { get; }
        public BaseConditionalExpressionSyntax WithCondition(ExpressionSyntax condition) => WithConditionCore(condition);
        internal abstract BaseConditionalExpressionSyntax WithConditionCore(ExpressionSyntax condition);

        public abstract BlockSyntax Block { get; }
        public BaseConditionalExpressionSyntax WithBlock(BlockSyntax block) => WithBlockCore(block);
        internal abstract BaseConditionalExpressionSyntax WithBlockCore(BlockSyntax block);

        public BaseConditionalExpressionSyntax AddBlockStatements(params StatementSyntax[] items) => AddBlockStatementsCore(items);
        internal abstract BaseConditionalExpressionSyntax AddBlockStatementsCore(params StatementSyntax[] items);
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.IfExpression"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class IfExpressionSyntax : BaseConditionalExpressionSyntax
    {
        private ExpressionSyntax? condition;
        private BlockSyntax? block;
        private SyntaxNode? elseIfs;
        private ElseClauseSyntax? @else;

        internal IfExpressionSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken IfKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.IfExpressionSyntax)this.Green).ifKeyword, Position, 0);

        public override ExpressionSyntax Condition => GetRed(ref this.condition, 1)!;

        public SyntaxToken ThenKeyword
        {
            get
            {
                var slot = ((Syntax.InternalSyntax.IfExpressionSyntax)this.Green).thenKeyword;
                return slot != null ? new SyntaxToken(this, slot, GetChildPosition(2), GetChildIndex(2)) : default;
            }
        }

        public override BlockSyntax Block => GetRed(ref this.block, 3)!;

        public SyntaxList<ElseIfClauseSyntax> ElseIfs => new SyntaxList<ElseIfClauseSyntax>(GetRed(ref this.elseIfs, 4));

        public ElseClauseSyntax? Else => GetRed(ref this.@else, 5);

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                1 => GetRed(ref this.condition, 1)!,
                3 => GetRed(ref this.block, 3)!,
                4 => GetRed(ref this.elseIfs, 4),
                5 => GetRed(ref this.@else, 5),
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                1 => this.condition,
                3 => this.block,
                4 => this.elseIfs,
                5 => this.@else,
                _ => null,
            };

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitIfExpression(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitIfExpression(this);

        public IfExpressionSyntax Update(SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken thenKeyword, BlockSyntax block, SyntaxList<ElseIfClauseSyntax> elseIfs, ElseClauseSyntax? @else)
        {
            if (ifKeyword != this.IfKeyword || condition != this.Condition || thenKeyword != this.ThenKeyword || block != this.Block || elseIfs != this.ElseIfs || @else != this.Else)
            {
                var newNode = SyntaxFactory.IfExpression(ifKeyword, condition, thenKeyword, block, elseIfs, @else);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public IfExpressionSyntax WithIfKeyword(SyntaxToken ifKeyword) => Update(ifKeyword, this.Condition, this.ThenKeyword, this.Block, this.ElseIfs, this.Else);
        internal override BaseConditionalExpressionSyntax WithConditionCore(ExpressionSyntax condition) => WithCondition(condition);
        public new IfExpressionSyntax WithCondition(ExpressionSyntax condition) => Update(this.IfKeyword, condition, this.ThenKeyword, this.Block, this.ElseIfs, this.Else);
        public IfExpressionSyntax WithThenKeyword(SyntaxToken thenKeyword) => Update(this.IfKeyword, this.Condition, thenKeyword, this.Block, this.ElseIfs, this.Else);
        internal override BaseConditionalExpressionSyntax WithBlockCore(BlockSyntax block) => WithBlock(block);
        public new IfExpressionSyntax WithBlock(BlockSyntax block) => Update(this.IfKeyword, this.Condition, this.ThenKeyword, block, this.ElseIfs, this.Else);
        public IfExpressionSyntax WithElseIfs(SyntaxList<ElseIfClauseSyntax> elseIfs) => Update(this.IfKeyword, this.Condition, this.ThenKeyword, this.Block, elseIfs, this.Else);
        public IfExpressionSyntax WithElse(ElseClauseSyntax? @else) => Update(this.IfKeyword, this.Condition, this.ThenKeyword, this.Block, this.ElseIfs, @else);

        internal override BaseConditionalExpressionSyntax AddBlockStatementsCore(params StatementSyntax[] items) => AddBlockStatements(items);
        public new IfExpressionSyntax AddBlockStatements(params StatementSyntax[] items) => WithBlock(this.Block.WithStatements(this.Block.Statements.AddRange(items)));
        public IfExpressionSyntax AddElseIfs(params ElseIfClauseSyntax[] items) => WithElseIfs(this.ElseIfs.AddRange(items));
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.ElseIfClause"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ElseIfClauseSyntax : MoonScriptSyntaxNode
    {
        private ExpressionSyntax? condition;
        private BlockSyntax? block;

        internal ElseIfClauseSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken ElseIfKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.ElseIfClauseSyntax)this.Green).elseIfKeyword, Position, 0);

        public ExpressionSyntax Condition => GetRed(ref this.condition, 1)!;

        public SyntaxToken ThenKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.ElseIfClauseSyntax)this.Green).thenKeyword, GetChildPosition(2), GetChildIndex(2));

        public BlockSyntax Block => GetRed(ref this.block, 3)!;

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                1 => GetRed(ref this.condition, 1)!,
                3 => GetRed(ref this.block, 3)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                1 => this.condition,
                3 => this.block,
                _ => null,
            };

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitElseIfClause(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitElseIfClause(this);

        public ElseIfClauseSyntax Update(SyntaxToken elseIfKeyword, ExpressionSyntax condition, SyntaxToken thenKeyword, BlockSyntax block)
        {
            if (elseIfKeyword != this.ElseIfKeyword || condition != this.Condition || thenKeyword != this.ThenKeyword || block != this.Block)
            {
                var newNode = SyntaxFactory.ElseIfClause(elseIfKeyword, condition, thenKeyword, block);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ElseIfClauseSyntax WithElseIfKeyword(SyntaxToken elseIfKeyword) => Update(elseIfKeyword, this.Condition, this.ThenKeyword, this.Block);
        public ElseIfClauseSyntax WithCondition(ExpressionSyntax condition) => Update(this.ElseIfKeyword, condition, this.ThenKeyword, this.Block);
        public ElseIfClauseSyntax WithThenKeyword(SyntaxToken thenKeyword) => Update(this.ElseIfKeyword, this.Condition, thenKeyword, this.Block);
        public ElseIfClauseSyntax WithBlock(BlockSyntax block) => Update(this.ElseIfKeyword, this.Condition, this.ThenKeyword, block);

        public ElseIfClauseSyntax AddBlockStatements(params StatementSyntax[] items) => WithBlock(this.Block.WithStatements(this.Block.Statements.AddRange(items)));
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.ElseClause"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ElseClauseSyntax : MoonScriptSyntaxNode
    {
        private BlockSyntax? block;

        internal ElseClauseSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken ElseKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.ElseClauseSyntax)this.Green).elseKeyword, Position, 0);

        public BlockSyntax Block => GetRed(ref this.block, 1)!;

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.block, 1)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.block : null;

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitElseClause(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitElseClause(this);

        public ElseClauseSyntax Update(SyntaxToken elseKeyword, BlockSyntax block)
        {
            if (elseKeyword != this.ElseKeyword || block != this.Block)
            {
                var newNode = SyntaxFactory.ElseClause(elseKeyword, block);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ElseClauseSyntax WithElseKeyword(SyntaxToken elseKeyword) => Update(elseKeyword, this.Block);
        public ElseClauseSyntax WithBlock(BlockSyntax block) => Update(this.ElseKeyword, block);

        public ElseClauseSyntax AddBlockStatements(params StatementSyntax[] items) => WithBlock(this.Block.WithStatements(this.Block.Statements.AddRange(items)));
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.SwitchExpression"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class SwitchExpressionSyntax : ExpressionSyntax
    {
        private ExpressionSyntax? expression;
        private SyntaxNode? whens;
        private ElseClauseSyntax? @else;

        internal SwitchExpressionSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public ExpressionSyntax Expression => GetRedAtZero(ref this.expression)!;

        public SyntaxList<WhenClauseSyntax> Whens => new SyntaxList<WhenClauseSyntax>(GetRed(ref this.whens, 1));

        public ElseClauseSyntax Else => GetRed(ref this.@else, 2)!;

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                0 => GetRedAtZero(ref this.expression)!,
                1 => GetRed(ref this.whens, 1)!,
                2 => GetRed(ref this.@else, 2)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                0 => this.expression,
                1 => this.whens,
                2 => this.@else,
                _ => null,
            };

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitSwitchExpression(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitSwitchExpression(this);

        public SwitchExpressionSyntax Update(ExpressionSyntax expression, SyntaxList<WhenClauseSyntax> whens, ElseClauseSyntax @else)
        {
            if (expression != this.Expression || whens != this.Whens || @else != this.Else)
            {
                var newNode = SyntaxFactory.SwitchExpression(expression, whens, @else);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public SwitchExpressionSyntax WithExpression(ExpressionSyntax expression) => Update(expression, this.Whens, this.Else);
        public SwitchExpressionSyntax WithWhens(SyntaxList<WhenClauseSyntax> whens) => Update(this.Expression, whens, this.Else);
        public SwitchExpressionSyntax WithElse(ElseClauseSyntax @else) => Update(this.Expression, this.Whens, @else);

        public SwitchExpressionSyntax AddWhens(params WhenClauseSyntax[] items) => WithWhens(this.Whens.AddRange(items));
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.WhenClause"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class WhenClauseSyntax : MoonScriptSyntaxNode
    {
        private ExpressionListSyntax? values;
        private BlockSyntax? block;

        internal WhenClauseSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken WhenKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.WhenClauseSyntax)this.Green).whenKeyword, Position, 0);

        public ExpressionListSyntax Values => GetRed(ref this.values, 1)!;

        public SyntaxToken ThenKeyword
        {
            get
            {
                var slot = ((Syntax.InternalSyntax.WhenClauseSyntax)this.Green).thenKeyword;
                return slot != null ? new SyntaxToken(this, slot, GetChildPosition(2), GetChildIndex(2)) : default;
            }
        }

        public BlockSyntax Block => GetRed(ref this.block, 3)!;

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                1 => GetRed(ref this.values, 1)!,
                3 => GetRed(ref this.block, 3)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                1 => this.values,
                3 => this.block,
                _ => null,
            };

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitWhenClause(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitWhenClause(this);

        public WhenClauseSyntax Update(SyntaxToken whenKeyword, ExpressionListSyntax values, SyntaxToken thenKeyword, BlockSyntax block)
        {
            if (whenKeyword != this.WhenKeyword || values != this.Values || thenKeyword != this.ThenKeyword || block != this.Block)
            {
                var newNode = SyntaxFactory.WhenClause(whenKeyword, values, thenKeyword, block);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public WhenClauseSyntax WithWhenKeyword(SyntaxToken whenKeyword) => Update(whenKeyword, this.Values, this.ThenKeyword, this.Block);
        public WhenClauseSyntax WithValues(ExpressionListSyntax values) => Update(this.WhenKeyword, values, this.ThenKeyword, this.Block);
        public WhenClauseSyntax WithThenKeyword(SyntaxToken thenKeyword) => Update(this.WhenKeyword, this.Values, thenKeyword, this.Block);
        public WhenClauseSyntax WithBlock(BlockSyntax block) => Update(this.WhenKeyword, this.Values, this.ThenKeyword, block);

        public WhenClauseSyntax AddValuesExpressions(params ExpressionSyntax[] items) => WithValues(this.Values.WithExpressions(this.Values.Expressions.AddRange(items)));
        public WhenClauseSyntax AddBlockStatements(params StatementSyntax[] items) => WithBlock(this.Block.WithStatements(this.Block.Statements.AddRange(items)));
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.UnlessExpression"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class UnlessExpressionSyntax : BaseConditionalExpressionSyntax
    {
        private ExpressionSyntax? condition;
        private BlockSyntax? block;

        internal UnlessExpressionSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken UnlessKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.UnlessExpressionSyntax)this.Green).unlessKeyword, Position, 0);

        public override ExpressionSyntax Condition => GetRed(ref this.condition, 1)!;

        public SyntaxToken ThenKeyword
        {
            get
            {
                var slot = ((Syntax.InternalSyntax.UnlessExpressionSyntax)this.Green).thenKeyword;
                return slot != null ? new SyntaxToken(this, slot, GetChildPosition(2), GetChildIndex(2)) : default;
            }
        }

        public override BlockSyntax Block => GetRed(ref this.block, 3)!;

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                1 => GetRed(ref this.condition, 1)!,
                3 => GetRed(ref this.block, 3)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                1 => this.condition,
                3 => this.block,
                _ => null,
            };

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitUnlessExpression(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitUnlessExpression(this);

        public UnlessExpressionSyntax Update(SyntaxToken unlessKeyword, ExpressionSyntax condition, SyntaxToken thenKeyword, BlockSyntax block)
        {
            if (unlessKeyword != this.UnlessKeyword || condition != this.Condition || thenKeyword != this.ThenKeyword || block != this.Block)
            {
                var newNode = SyntaxFactory.UnlessExpression(unlessKeyword, condition, thenKeyword, block);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public UnlessExpressionSyntax WithUnlessKeyword(SyntaxToken unlessKeyword) => Update(unlessKeyword, this.Condition, this.ThenKeyword, this.Block);
        internal override BaseConditionalExpressionSyntax WithConditionCore(ExpressionSyntax condition) => WithCondition(condition);
        public new UnlessExpressionSyntax WithCondition(ExpressionSyntax condition) => Update(this.UnlessKeyword, condition, this.ThenKeyword, this.Block);
        public UnlessExpressionSyntax WithThenKeyword(SyntaxToken thenKeyword) => Update(this.UnlessKeyword, this.Condition, thenKeyword, this.Block);
        internal override BaseConditionalExpressionSyntax WithBlockCore(BlockSyntax block) => WithBlock(block);
        public new UnlessExpressionSyntax WithBlock(BlockSyntax block) => Update(this.UnlessKeyword, this.Condition, this.ThenKeyword, block);

        internal override BaseConditionalExpressionSyntax AddBlockStatementsCore(params StatementSyntax[] items) => AddBlockStatements(items);
        public new UnlessExpressionSyntax AddBlockStatements(params StatementSyntax[] items) => WithBlock(this.Block.WithStatements(this.Block.Statements.AddRange(items)));
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.WhileExpression"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class WhileExpressionSyntax : ExpressionSyntax
    {
        private ExpressionSyntax? condition;
        private BlockSyntax? block;

        internal WhileExpressionSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken WhileKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.WhileExpressionSyntax)this.Green).whileKeyword, Position, 0);

        public ExpressionSyntax Condition => GetRed(ref this.condition, 1)!;

        public SyntaxToken DoKeyword
        {
            get
            {
                var slot = ((Syntax.InternalSyntax.WhileExpressionSyntax)this.Green).doKeyword;
                return slot != null ? new SyntaxToken(this, slot, GetChildPosition(2), GetChildIndex(2)) : default;
            }
        }

        public BlockSyntax Block => GetRed(ref this.block, 3)!;

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                1 => GetRed(ref this.condition, 1)!,
                3 => GetRed(ref this.block, 3)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                1 => this.condition,
                3 => this.block,
                _ => null,
            };

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitWhileExpression(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitWhileExpression(this);

        public WhileExpressionSyntax Update(SyntaxToken whileKeyword, ExpressionSyntax condition, SyntaxToken doKeyword, BlockSyntax block)
        {
            if (whileKeyword != this.WhileKeyword || condition != this.Condition || doKeyword != this.DoKeyword || block != this.Block)
            {
                var newNode = SyntaxFactory.WhileExpression(whileKeyword, condition, doKeyword, block);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public WhileExpressionSyntax WithWhileKeyword(SyntaxToken whileKeyword) => Update(whileKeyword, this.Condition, this.DoKeyword, this.Block);
        public WhileExpressionSyntax WithCondition(ExpressionSyntax condition) => Update(this.WhileKeyword, condition, this.DoKeyword, this.Block);
        public WhileExpressionSyntax WithDoKeyword(SyntaxToken doKeyword) => Update(this.WhileKeyword, this.Condition, doKeyword, this.Block);
        public WhileExpressionSyntax WithBlock(BlockSyntax block) => Update(this.WhileKeyword, this.Condition, this.DoKeyword, block);

        public WhileExpressionSyntax AddBlockStatements(params StatementSyntax[] items) => WithBlock(this.Block.WithStatements(this.Block.Statements.AddRange(items)));
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.WithExpression"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class WithExpressionSyntax : ExpressionSyntax
    {
        private ExpressionSyntax? expression;
        private BlockSyntax? block;

        internal WithExpressionSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken WithKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.WithExpressionSyntax)this.Green).withKeyword, Position, 0);

        public ExpressionSyntax Expression => GetRed(ref this.expression, 1)!;

        public BlockSyntax Block => GetRed(ref this.block, 2)!;

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                1 => GetRed(ref this.expression, 1)!,
                2 => GetRed(ref this.block, 2)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                1 => this.expression,
                2 => this.block,
                _ => null,
            };

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitWithExpression(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitWithExpression(this);

        public WithExpressionSyntax Update(SyntaxToken withKeyword, ExpressionSyntax expression, BlockSyntax block)
        {
            if (withKeyword != this.WithKeyword || expression != this.Expression || block != this.Block)
            {
                var newNode = SyntaxFactory.WithExpression(withKeyword, expression, block);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public WithExpressionSyntax WithWithKeyword(SyntaxToken withKeyword) => Update(withKeyword, this.Expression, this.Block);
        public WithExpressionSyntax WithExpression(ExpressionSyntax expression) => Update(this.WithKeyword, expression, this.Block);
        public WithExpressionSyntax WithBlock(BlockSyntax block) => Update(this.WithKeyword, this.Expression, block);

        public WithExpressionSyntax AddBlockStatements(params StatementSyntax[] items) => WithBlock(this.Block.WithStatements(this.Block.Statements.AddRange(items)));
    }

    public abstract partial class BaseComprehensionExpressionSyntax : ExpressionSyntax
    {
        internal BaseComprehensionExpressionSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public abstract ExpressionSyntax Expression { get; }
        public BaseComprehensionExpressionSyntax WithExpression(ExpressionSyntax expression) => WithExpressionCore(expression);
        internal abstract BaseComprehensionExpressionSyntax WithExpressionCore(ExpressionSyntax expression);

        public abstract BaseComprehensionClauseSyntax FirstClause { get; }
        public BaseComprehensionExpressionSyntax WithFirstClause(BaseComprehensionClauseSyntax firstClause) => WithFirstClauseCore(firstClause);
        internal abstract BaseComprehensionExpressionSyntax WithFirstClauseCore(BaseComprehensionClauseSyntax firstClause);

        public abstract SyntaxList<BaseComprehensionClauseSyntax> RestClauses { get; }
        public BaseComprehensionExpressionSyntax WithRestClauses(SyntaxList<BaseComprehensionClauseSyntax> restClauses) => WithRestClausesCore(restClauses);
        internal abstract BaseComprehensionExpressionSyntax WithRestClausesCore(SyntaxList<BaseComprehensionClauseSyntax> restClauses);

        public BaseComprehensionExpressionSyntax AddRestClauses(params BaseComprehensionClauseSyntax[] items) => AddRestClausesCore(items);
        internal abstract BaseComprehensionExpressionSyntax AddRestClausesCore(params BaseComprehensionClauseSyntax[] items);
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.ListComprehensionExpression"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ListComprehensionExpressionSyntax : BaseComprehensionExpressionSyntax
    {
        private ExpressionSyntax? expression;
        private BaseComprehensionClauseSyntax? firstClause;
        private SyntaxNode? restClauses;

        internal ListComprehensionExpressionSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken OpenBracketToken => new SyntaxToken(this, ((Syntax.InternalSyntax.ListComprehensionExpressionSyntax)this.Green).openBracketToken, Position, 0);

        public override ExpressionSyntax Expression => GetRed(ref this.expression, 1)!;

        public override BaseComprehensionClauseSyntax FirstClause => GetRed(ref this.firstClause, 2)!;

        public override SyntaxList<BaseComprehensionClauseSyntax> RestClauses => new SyntaxList<BaseComprehensionClauseSyntax>(GetRed(ref this.restClauses, 3));

        public SyntaxToken CloseBracketToken => new SyntaxToken(this, ((Syntax.InternalSyntax.ListComprehensionExpressionSyntax)this.Green).closeBracketToken, GetChildPosition(4), GetChildIndex(4));

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                1 => GetRed(ref this.expression, 1)!,
                2 => GetRed(ref this.firstClause, 2)!,
                3 => GetRed(ref this.restClauses, 3)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                1 => this.expression,
                2 => this.firstClause,
                3 => this.restClauses,
                _ => null,
            };

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitListComprehensionExpression(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitListComprehensionExpression(this);

        public ListComprehensionExpressionSyntax Update(SyntaxToken openBracketToken, ExpressionSyntax expression, BaseComprehensionClauseSyntax firstClause, SyntaxList<BaseComprehensionClauseSyntax> restClauses, SyntaxToken closeBracketToken)
        {
            if (openBracketToken != this.OpenBracketToken || expression != this.Expression || firstClause != this.FirstClause || restClauses != this.RestClauses || closeBracketToken != this.CloseBracketToken)
            {
                var newNode = SyntaxFactory.ListComprehensionExpression(openBracketToken, expression, firstClause, restClauses, closeBracketToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ListComprehensionExpressionSyntax WithOpenBracketToken(SyntaxToken openBracketToken) => Update(openBracketToken, this.Expression, this.FirstClause, this.RestClauses, this.CloseBracketToken);
        internal override BaseComprehensionExpressionSyntax WithExpressionCore(ExpressionSyntax expression) => WithExpression(expression);
        public new ListComprehensionExpressionSyntax WithExpression(ExpressionSyntax expression) => Update(this.OpenBracketToken, expression, this.FirstClause, this.RestClauses, this.CloseBracketToken);
        internal override BaseComprehensionExpressionSyntax WithFirstClauseCore(BaseComprehensionClauseSyntax firstClause) => WithFirstClause(firstClause);
        public new ListComprehensionExpressionSyntax WithFirstClause(BaseComprehensionClauseSyntax firstClause) => Update(this.OpenBracketToken, this.Expression, firstClause, this.RestClauses, this.CloseBracketToken);
        internal override BaseComprehensionExpressionSyntax WithRestClausesCore(SyntaxList<BaseComprehensionClauseSyntax> restClauses) => WithRestClauses(restClauses);
        public new ListComprehensionExpressionSyntax WithRestClauses(SyntaxList<BaseComprehensionClauseSyntax> restClauses) => Update(this.OpenBracketToken, this.Expression, this.FirstClause, restClauses, this.CloseBracketToken);
        public ListComprehensionExpressionSyntax WithCloseBracketToken(SyntaxToken closeBracketToken) => Update(this.OpenBracketToken, this.Expression, this.FirstClause, this.RestClauses, closeBracketToken);

        internal override BaseComprehensionExpressionSyntax AddRestClausesCore(params BaseComprehensionClauseSyntax[] items) => AddRestClauses(items);
        public new ListComprehensionExpressionSyntax AddRestClauses(params BaseComprehensionClauseSyntax[] items) => WithRestClauses(this.RestClauses.AddRange(items));
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.TableComprehensionExpression"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class TableComprehensionExpressionSyntax : BaseComprehensionExpressionSyntax
    {
        private ExpressionSyntax? expression;
        private BaseComprehensionClauseSyntax? firstClause;
        private SyntaxNode? restClauses;

        internal TableComprehensionExpressionSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken OpenBraceToken => new SyntaxToken(this, ((Syntax.InternalSyntax.TableComprehensionExpressionSyntax)this.Green).openBraceToken, Position, 0);

        public override ExpressionSyntax Expression => GetRed(ref this.expression, 1)!;

        public override BaseComprehensionClauseSyntax FirstClause => GetRed(ref this.firstClause, 2)!;

        public override SyntaxList<BaseComprehensionClauseSyntax> RestClauses => new SyntaxList<BaseComprehensionClauseSyntax>(GetRed(ref this.restClauses, 3));

        public SyntaxToken CloseBraceToken => new SyntaxToken(this, ((Syntax.InternalSyntax.TableComprehensionExpressionSyntax)this.Green).closeBraceToken, GetChildPosition(4), GetChildIndex(4));

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                1 => GetRed(ref this.expression, 1)!,
                2 => GetRed(ref this.firstClause, 2)!,
                3 => GetRed(ref this.restClauses, 3)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                1 => this.expression,
                2 => this.firstClause,
                3 => this.restClauses,
                _ => null,
            };

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitTableComprehensionExpression(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitTableComprehensionExpression(this);

        public TableComprehensionExpressionSyntax Update(SyntaxToken openBraceToken, ExpressionSyntax expression, BaseComprehensionClauseSyntax firstClause, SyntaxList<BaseComprehensionClauseSyntax> restClauses, SyntaxToken closeBraceToken)
        {
            if (openBraceToken != this.OpenBraceToken || expression != this.Expression || firstClause != this.FirstClause || restClauses != this.RestClauses || closeBraceToken != this.CloseBraceToken)
            {
                var newNode = SyntaxFactory.TableComprehensionExpression(openBraceToken, expression, firstClause, restClauses, closeBraceToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public TableComprehensionExpressionSyntax WithOpenBraceToken(SyntaxToken openBraceToken) => Update(openBraceToken, this.Expression, this.FirstClause, this.RestClauses, this.CloseBraceToken);
        internal override BaseComprehensionExpressionSyntax WithExpressionCore(ExpressionSyntax expression) => WithExpression(expression);
        public new TableComprehensionExpressionSyntax WithExpression(ExpressionSyntax expression) => Update(this.OpenBraceToken, expression, this.FirstClause, this.RestClauses, this.CloseBraceToken);
        internal override BaseComprehensionExpressionSyntax WithFirstClauseCore(BaseComprehensionClauseSyntax firstClause) => WithFirstClause(firstClause);
        public new TableComprehensionExpressionSyntax WithFirstClause(BaseComprehensionClauseSyntax firstClause) => Update(this.OpenBraceToken, this.Expression, firstClause, this.RestClauses, this.CloseBraceToken);
        internal override BaseComprehensionExpressionSyntax WithRestClausesCore(SyntaxList<BaseComprehensionClauseSyntax> restClauses) => WithRestClauses(restClauses);
        public new TableComprehensionExpressionSyntax WithRestClauses(SyntaxList<BaseComprehensionClauseSyntax> restClauses) => Update(this.OpenBraceToken, this.Expression, this.FirstClause, restClauses, this.CloseBraceToken);
        public TableComprehensionExpressionSyntax WithCloseBraceToken(SyntaxToken closeBraceToken) => Update(this.OpenBraceToken, this.Expression, this.FirstClause, this.RestClauses, closeBraceToken);

        internal override BaseComprehensionExpressionSyntax AddRestClausesCore(params BaseComprehensionClauseSyntax[] items) => AddRestClauses(items);
        public new TableComprehensionExpressionSyntax AddRestClauses(params BaseComprehensionClauseSyntax[] items) => WithRestClauses(this.RestClauses.AddRange(items));
    }

    public abstract partial class BaseComprehensionClauseSyntax : MoonScriptSyntaxNode
    {
        internal BaseComprehensionClauseSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.ForComprehensionClause"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ForComprehensionClauseSyntax : BaseComprehensionClauseSyntax
    {
        private IdentifierNameSyntax? name;
        private ExpressionSyntax? initial;
        private ExpressionSyntax? limit;
        private ExpressionSyntax? step;

        internal ForComprehensionClauseSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken ForKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.ForComprehensionClauseSyntax)this.Green).forKeyword, Position, 0);

        public IdentifierNameSyntax Name => GetRed(ref this.name, 1)!;

        public SyntaxToken EqualsToken => new SyntaxToken(this, ((Syntax.InternalSyntax.ForComprehensionClauseSyntax)this.Green).equalsToken, GetChildPosition(2), GetChildIndex(2));

        public ExpressionSyntax Initial => GetRed(ref this.initial, 3)!;

        public SyntaxToken FirstCommaToken => new SyntaxToken(this, ((Syntax.InternalSyntax.ForComprehensionClauseSyntax)this.Green).firstCommaToken, GetChildPosition(4), GetChildIndex(4));

        public ExpressionSyntax Limit => GetRed(ref this.limit, 5)!;

        public SyntaxToken SecondCommaToken => new SyntaxToken(this, ((Syntax.InternalSyntax.ForComprehensionClauseSyntax)this.Green).secondCommaToken, GetChildPosition(6), GetChildIndex(6));

        public ExpressionSyntax Step => GetRed(ref this.step, 7)!;

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                1 => GetRed(ref this.name, 1)!,
                3 => GetRed(ref this.initial, 3)!,
                5 => GetRed(ref this.limit, 5)!,
                7 => GetRed(ref this.step, 7)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                1 => this.name,
                3 => this.initial,
                5 => this.limit,
                7 => this.step,
                _ => null,
            };

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitForComprehensionClause(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitForComprehensionClause(this);

        public ForComprehensionClauseSyntax Update(SyntaxToken forKeyword, IdentifierNameSyntax name, SyntaxToken equalsToken, ExpressionSyntax initial, SyntaxToken firstCommaToken, ExpressionSyntax limit, SyntaxToken secondCommaToken, ExpressionSyntax step)
        {
            if (forKeyword != this.ForKeyword || name != this.Name || equalsToken != this.EqualsToken || initial != this.Initial || firstCommaToken != this.FirstCommaToken || limit != this.Limit || secondCommaToken != this.SecondCommaToken || step != this.Step)
            {
                var newNode = SyntaxFactory.ForComprehensionClause(forKeyword, name, equalsToken, initial, firstCommaToken, limit, secondCommaToken, step);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ForComprehensionClauseSyntax WithForKeyword(SyntaxToken forKeyword) => Update(forKeyword, this.Name, this.EqualsToken, this.Initial, this.FirstCommaToken, this.Limit, this.SecondCommaToken, this.Step);
        public ForComprehensionClauseSyntax WithName(IdentifierNameSyntax name) => Update(this.ForKeyword, name, this.EqualsToken, this.Initial, this.FirstCommaToken, this.Limit, this.SecondCommaToken, this.Step);
        public ForComprehensionClauseSyntax WithEqualsToken(SyntaxToken equalsToken) => Update(this.ForKeyword, this.Name, equalsToken, this.Initial, this.FirstCommaToken, this.Limit, this.SecondCommaToken, this.Step);
        public ForComprehensionClauseSyntax WithInitial(ExpressionSyntax initial) => Update(this.ForKeyword, this.Name, this.EqualsToken, initial, this.FirstCommaToken, this.Limit, this.SecondCommaToken, this.Step);
        public ForComprehensionClauseSyntax WithFirstCommaToken(SyntaxToken firstCommaToken) => Update(this.ForKeyword, this.Name, this.EqualsToken, this.Initial, firstCommaToken, this.Limit, this.SecondCommaToken, this.Step);
        public ForComprehensionClauseSyntax WithLimit(ExpressionSyntax limit) => Update(this.ForKeyword, this.Name, this.EqualsToken, this.Initial, this.FirstCommaToken, limit, this.SecondCommaToken, this.Step);
        public ForComprehensionClauseSyntax WithSecondCommaToken(SyntaxToken secondCommaToken) => Update(this.ForKeyword, this.Name, this.EqualsToken, this.Initial, this.FirstCommaToken, this.Limit, secondCommaToken, this.Step);
        public ForComprehensionClauseSyntax WithStep(ExpressionSyntax step) => Update(this.ForKeyword, this.Name, this.EqualsToken, this.Initial, this.FirstCommaToken, this.Limit, this.SecondCommaToken, step);
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.ForInComprehensionClause"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ForInComprehensionClauseSyntax : BaseComprehensionClauseSyntax
    {
        private SyntaxNode? names;
        private ExpressionSyntax? iteration;

        internal ForInComprehensionClauseSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken ForKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.ForInComprehensionClauseSyntax)this.Green).forKeyword, Position, 0);

        public SeparatedSyntaxList<IdentifierNameSyntax> Names
        {
            get
            {
                var red = GetRed(ref this.names, 1);
                return red != null ? new SeparatedSyntaxList<IdentifierNameSyntax>(red, GetChildIndex(1)) : default;
            }
        }

        public SyntaxToken InKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.ForInComprehensionClauseSyntax)this.Green).inKeyword, GetChildPosition(2), GetChildIndex(2));

        public ExpressionSyntax Iteration => GetRed(ref this.iteration, 3)!;

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                1 => GetRed(ref this.names, 1)!,
                3 => GetRed(ref this.iteration, 3)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                1 => this.names,
                3 => this.iteration,
                _ => null,
            };

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitForInComprehensionClause(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitForInComprehensionClause(this);

        public ForInComprehensionClauseSyntax Update(SyntaxToken forKeyword, SeparatedSyntaxList<IdentifierNameSyntax> names, SyntaxToken inKeyword, ExpressionSyntax iteration)
        {
            if (forKeyword != this.ForKeyword || names != this.Names || inKeyword != this.InKeyword || iteration != this.Iteration)
            {
                var newNode = SyntaxFactory.ForInComprehensionClause(forKeyword, names, inKeyword, iteration);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ForInComprehensionClauseSyntax WithForKeyword(SyntaxToken forKeyword) => Update(forKeyword, this.Names, this.InKeyword, this.Iteration);
        public ForInComprehensionClauseSyntax WithNames(SeparatedSyntaxList<IdentifierNameSyntax> names) => Update(this.ForKeyword, names, this.InKeyword, this.Iteration);
        public ForInComprehensionClauseSyntax WithInKeyword(SyntaxToken inKeyword) => Update(this.ForKeyword, this.Names, inKeyword, this.Iteration);
        public ForInComprehensionClauseSyntax WithIteration(ExpressionSyntax iteration) => Update(this.ForKeyword, this.Names, this.InKeyword, iteration);

        public ForInComprehensionClauseSyntax AddNames(params IdentifierNameSyntax[] items) => WithNames(this.Names.AddRange(items));
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.WhenComprehensionClause"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class WhenComprehensionClauseSyntax : BaseComprehensionClauseSyntax
    {
        private ExpressionSyntax? condition;

        internal WhenComprehensionClauseSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken WhenKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.WhenComprehensionClauseSyntax)this.Green).whenKeyword, Position, 0);

        public ExpressionSyntax Condition => GetRed(ref this.condition, 1)!;

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.condition, 1)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.condition : null;

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitWhenComprehensionClause(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitWhenComprehensionClause(this);

        public WhenComprehensionClauseSyntax Update(SyntaxToken whenKeyword, ExpressionSyntax condition)
        {
            if (whenKeyword != this.WhenKeyword || condition != this.Condition)
            {
                var newNode = SyntaxFactory.WhenComprehensionClause(whenKeyword, condition);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public WhenComprehensionClauseSyntax WithWhenKeyword(SyntaxToken whenKeyword) => Update(whenKeyword, this.Condition);
        public WhenComprehensionClauseSyntax WithCondition(ExpressionSyntax condition) => Update(this.WhenKeyword, condition);
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.NumericallyIterateExpression"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class NumericallyIterateExpressionSyntax : ExpressionSyntax
    {
        private ExpressionSyntax? expression;

        internal NumericallyIterateExpressionSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken AsteriskToken => new SyntaxToken(this, ((Syntax.InternalSyntax.NumericallyIterateExpressionSyntax)this.Green).asteriskToken, Position, 0);

        public ExpressionSyntax Expression => GetRed(ref this.expression, 1)!;

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.expression, 1)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.expression : null;

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitNumericallyIterateExpression(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitNumericallyIterateExpression(this);

        public NumericallyIterateExpressionSyntax Update(SyntaxToken asteriskToken, ExpressionSyntax expression)
        {
            if (asteriskToken != this.AsteriskToken || expression != this.Expression)
            {
                var newNode = SyntaxFactory.NumericallyIterateExpression(asteriskToken, expression);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public NumericallyIterateExpressionSyntax WithAsteriskToken(SyntaxToken asteriskToken) => Update(asteriskToken, this.Expression);
        public NumericallyIterateExpressionSyntax WithExpression(ExpressionSyntax expression) => Update(this.AsteriskToken, expression);
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.SlicingExpression"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class SlicingExpressionSyntax : ExpressionSyntax
    {
        private ExpressionSyntax? numericallyIterateExpression;
        private ExpressionSyntax? initial;
        private ExpressionSyntax? limit;
        private ExpressionSyntax? step;

        internal SlicingExpressionSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public ExpressionSyntax NumericallyIterateExpression => GetRedAtZero(ref this.numericallyIterateExpression)!;

        public SyntaxToken OpenBracketToken => new SyntaxToken(this, ((Syntax.InternalSyntax.SlicingExpressionSyntax)this.Green).openBracketToken, GetChildPosition(1), GetChildIndex(1));

        public ExpressionSyntax? Initial => GetRed(ref this.initial, 2);

        public SyntaxToken FirstCommaToken => new SyntaxToken(this, ((Syntax.InternalSyntax.SlicingExpressionSyntax)this.Green).firstCommaToken, GetChildPosition(3), GetChildIndex(3));

        public ExpressionSyntax? Limit => GetRed(ref this.limit, 4);

        public SyntaxToken SecondCommaToken => new SyntaxToken(this, ((Syntax.InternalSyntax.SlicingExpressionSyntax)this.Green).secondCommaToken, GetChildPosition(5), GetChildIndex(5));

        public ExpressionSyntax Step => GetRed(ref this.step, 6)!;

        public SyntaxToken CloseBracketToken => new SyntaxToken(this, ((Syntax.InternalSyntax.SlicingExpressionSyntax)this.Green).closeBracketToken, GetChildPosition(7), GetChildIndex(7));

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                0 => GetRedAtZero(ref this.numericallyIterateExpression)!,
                2 => GetRed(ref this.initial, 2),
                4 => GetRed(ref this.limit, 4),
                6 => GetRed(ref this.step, 6)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                0 => this.numericallyIterateExpression,
                2 => this.initial,
                4 => this.limit,
                6 => this.step,
                _ => null,
            };

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitSlicingExpression(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitSlicingExpression(this);

        public SlicingExpressionSyntax Update(ExpressionSyntax numericallyIterateExpression, SyntaxToken openBracketToken, ExpressionSyntax? initial, SyntaxToken firstCommaToken, ExpressionSyntax? limit, SyntaxToken secondCommaToken, ExpressionSyntax step, SyntaxToken closeBracketToken)
        {
            if (numericallyIterateExpression != this.NumericallyIterateExpression || openBracketToken != this.OpenBracketToken || initial != this.Initial || firstCommaToken != this.FirstCommaToken || limit != this.Limit || secondCommaToken != this.SecondCommaToken || step != this.Step || closeBracketToken != this.CloseBracketToken)
            {
                var newNode = SyntaxFactory.SlicingExpression(numericallyIterateExpression, openBracketToken, initial, firstCommaToken, limit, secondCommaToken, step, closeBracketToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public SlicingExpressionSyntax WithNumericallyIterateExpression(ExpressionSyntax numericallyIterateExpression) => Update(numericallyIterateExpression, this.OpenBracketToken, this.Initial, this.FirstCommaToken, this.Limit, this.SecondCommaToken, this.Step, this.CloseBracketToken);
        public SlicingExpressionSyntax WithOpenBracketToken(SyntaxToken openBracketToken) => Update(this.NumericallyIterateExpression, openBracketToken, this.Initial, this.FirstCommaToken, this.Limit, this.SecondCommaToken, this.Step, this.CloseBracketToken);
        public SlicingExpressionSyntax WithInitial(ExpressionSyntax? initial) => Update(this.NumericallyIterateExpression, this.OpenBracketToken, initial, this.FirstCommaToken, this.Limit, this.SecondCommaToken, this.Step, this.CloseBracketToken);
        public SlicingExpressionSyntax WithFirstCommaToken(SyntaxToken firstCommaToken) => Update(this.NumericallyIterateExpression, this.OpenBracketToken, this.Initial, firstCommaToken, this.Limit, this.SecondCommaToken, this.Step, this.CloseBracketToken);
        public SlicingExpressionSyntax WithLimit(ExpressionSyntax? limit) => Update(this.NumericallyIterateExpression, this.OpenBracketToken, this.Initial, this.FirstCommaToken, limit, this.SecondCommaToken, this.Step, this.CloseBracketToken);
        public SlicingExpressionSyntax WithSecondCommaToken(SyntaxToken secondCommaToken) => Update(this.NumericallyIterateExpression, this.OpenBracketToken, this.Initial, this.FirstCommaToken, this.Limit, secondCommaToken, this.Step, this.CloseBracketToken);
        public SlicingExpressionSyntax WithStep(ExpressionSyntax step) => Update(this.NumericallyIterateExpression, this.OpenBracketToken, this.Initial, this.FirstCommaToken, this.Limit, this.SecondCommaToken, step, this.CloseBracketToken);
        public SlicingExpressionSyntax WithCloseBracketToken(SyntaxToken closeBracketToken) => Update(this.NumericallyIterateExpression, this.OpenBracketToken, this.Initial, this.FirstCommaToken, this.Limit, this.SecondCommaToken, this.Step, closeBracketToken);
    }

    /// <summary>Class which represents the syntax node for invocation expression.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.InvocationExpression"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class InvocationExpressionSyntax : ExpressionSyntax
    {
        private ExpressionSyntax? expression;
        private ImplicitSelfCallSyntax? selfCall;
        private ArgumentListSyntax? argumentList;

        internal InvocationExpressionSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>ExpressionSyntax node representing the expression part of the invocation.</summary>
        public ExpressionSyntax? Expression => GetRedAtZero(ref this.expression);

        public ImplicitSelfCallSyntax? SelfCall => GetRed(ref this.selfCall, 1);

        /// <summary>ArgumentListSyntax node representing the list of arguments of the invocation expression.</summary>
        public ArgumentListSyntax ArgumentList => GetRed(ref this.argumentList, 2)!;

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                0 => GetRedAtZero(ref this.expression),
                1 => GetRed(ref this.selfCall, 1),
                2 => GetRed(ref this.argumentList, 2)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                0 => this.expression,
                1 => this.selfCall,
                2 => this.argumentList,
                _ => null,
            };

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitInvocationExpression(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitInvocationExpression(this);

        public InvocationExpressionSyntax Update(ExpressionSyntax? expression, ImplicitSelfCallSyntax? selfCall, ArgumentListSyntax argumentList)
        {
            if (expression != this.Expression || selfCall != this.SelfCall || argumentList != this.ArgumentList)
            {
                var newNode = SyntaxFactory.InvocationExpression(expression, selfCall, argumentList);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public InvocationExpressionSyntax WithExpression(ExpressionSyntax? expression) => Update(expression, this.SelfCall, this.ArgumentList);
        public InvocationExpressionSyntax WithSelfCall(ImplicitSelfCallSyntax? selfCall) => Update(this.Expression, selfCall, this.ArgumentList);
        public InvocationExpressionSyntax WithArgumentList(ArgumentListSyntax argumentList) => Update(this.Expression, this.SelfCall, argumentList);

        public InvocationExpressionSyntax AddArgumentListArguments(params ArgumentSyntax[] items) => WithArgumentList(this.ArgumentList.WithArguments(this.ArgumentList.Arguments.AddRange(items)));
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.LambdaExpression"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class LambdaExpressionSyntax : ExpressionSyntax
    {
        private ParameterListSyntax? parameters;
        private BlockSyntax? block;

        internal LambdaExpressionSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public ParameterListSyntax? Parameters => GetRedAtZero(ref this.parameters);

        public SyntaxToken Arrow => new SyntaxToken(this, ((Syntax.InternalSyntax.LambdaExpressionSyntax)this.Green).arrow, GetChildPosition(1), GetChildIndex(1));

        public BlockSyntax Block => GetRed(ref this.block, 2)!;

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                0 => GetRedAtZero(ref this.parameters),
                2 => GetRed(ref this.block, 2)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                0 => this.parameters,
                2 => this.block,
                _ => null,
            };

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitLambdaExpression(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitLambdaExpression(this);

        public LambdaExpressionSyntax Update(ParameterListSyntax? parameters, SyntaxToken arrow, BlockSyntax block)
        {
            if (parameters != this.Parameters || arrow != this.Arrow || block != this.Block)
            {
                var newNode = SyntaxFactory.LambdaExpression(parameters, arrow, block);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public LambdaExpressionSyntax WithParameters(ParameterListSyntax? parameters) => Update(parameters, this.Arrow, this.Block);
        public LambdaExpressionSyntax WithArrow(SyntaxToken arrow) => Update(this.Parameters, arrow, this.Block);
        public LambdaExpressionSyntax WithBlock(BlockSyntax block) => Update(this.Parameters, this.Arrow, block);

        public LambdaExpressionSyntax AddParametersParameters(params ParameterSyntax[] items)
        {
            var parameters = this.Parameters ?? SyntaxFactory.ParameterList();
            return WithParameters(parameters.WithParameters(parameters.Parameters.AddRange(items)));
        }
        public LambdaExpressionSyntax AddBlockStatements(params StatementSyntax[] items) => WithBlock(this.Block.WithStatements(this.Block.Statements.AddRange(items)));
    }

    /// <summary>Class which represents an expression that has a binary operator.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.AdditionExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.SubtractionExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.MultiplicationExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.DivisionExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.FloorDivisionExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.ExponentiationExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.ModuloExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.BitwiseAndExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.BitwiseExclusiveOrExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.BitwiseOrExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.BitwiseLeftShiftExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.BitwiseRightShiftExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.ConcatenationExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.LessThanExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.LessThanOrEqualExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.GreaterThanExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.GreaterThanOrEqualExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.EqualExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.NotEqualExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.AndExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.OrExpression"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class BinaryExpressionSyntax : ExpressionSyntax
    {
        private ExpressionSyntax? left;
        private ExpressionSyntax? right;

        internal BinaryExpressionSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>ExpressionSyntax node representing the expression on the left of the binary operator.</summary>
        public ExpressionSyntax Left => GetRedAtZero(ref this.left)!;

        /// <summary>SyntaxToken representing the operator of the binary expression.</summary>
        public SyntaxToken OperatorToken => new SyntaxToken(this, ((Syntax.InternalSyntax.BinaryExpressionSyntax)this.Green).operatorToken, GetChildPosition(1), GetChildIndex(1));

        /// <summary>ExpressionSyntax node representing the expression on the right of the binary operator.</summary>
        public ExpressionSyntax Right => GetRed(ref this.right, 2)!;

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                0 => GetRedAtZero(ref this.left)!,
                2 => GetRed(ref this.right, 2)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                0 => this.left,
                2 => this.right,
                _ => null,
            };

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitBinaryExpression(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitBinaryExpression(this);

        public BinaryExpressionSyntax Update(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)
        {
            if (left != this.Left || operatorToken != this.OperatorToken || right != this.Right)
            {
                var newNode = SyntaxFactory.BinaryExpression(this.Kind(), left, operatorToken, right);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public BinaryExpressionSyntax WithLeft(ExpressionSyntax left) => Update(left, this.OperatorToken, this.Right);
        public BinaryExpressionSyntax WithOperatorToken(SyntaxToken operatorToken) => Update(this.Left, operatorToken, this.Right);
        public BinaryExpressionSyntax WithRight(ExpressionSyntax right) => Update(this.Left, this.OperatorToken, right);
    }

    /// <summary>Class which represents the syntax node for prefix unary expression.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.UnaryMinusExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.LogicalNotExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.LengthExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.BitwiseNotExpression"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class UnaryExpressionSyntax : ExpressionSyntax
    {
        private ExpressionSyntax? operand;

        internal UnaryExpressionSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>SyntaxToken representing the kind of the operator of the prefix unary expression.</summary>
        public SyntaxToken OperatorToken => new SyntaxToken(this, ((Syntax.InternalSyntax.UnaryExpressionSyntax)this.Green).operatorToken, Position, 0);

        /// <summary>ExpressionSyntax representing the operand of the prefix unary expression.</summary>
        public ExpressionSyntax Operand => GetRed(ref this.operand, 1)!;

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.operand, 1)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.operand : null;

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitUnaryExpression(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitUnaryExpression(this);

        public UnaryExpressionSyntax Update(SyntaxToken operatorToken, ExpressionSyntax operand)
        {
            if (operatorToken != this.OperatorToken || operand != this.Operand)
            {
                var newNode = SyntaxFactory.UnaryExpression(this.Kind(), operatorToken, operand);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public UnaryExpressionSyntax WithOperatorToken(SyntaxToken operatorToken) => Update(operatorToken, this.Operand);
        public UnaryExpressionSyntax WithOperand(ExpressionSyntax operand) => Update(this.OperatorToken, operand);
    }

    public abstract partial class BaseAssignmentExpressionSyntax : ExpressionSyntax
    {
        internal BaseAssignmentExpressionSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public abstract SyntaxToken OperatorToken { get; }
        public BaseAssignmentExpressionSyntax WithOperatorToken(SyntaxToken operatorToken) => WithOperatorTokenCore(operatorToken);
        internal abstract BaseAssignmentExpressionSyntax WithOperatorTokenCore(SyntaxToken operatorToken);
    }

    /// <summary>Class which represents an expression that has an assignment operator.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.SimpleAssignmentExpression"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class SimpleAssignmentExpressionSyntax : BaseAssignmentExpressionSyntax
    {
        private ExpressionListSyntax? left;
        private ExpressionListSyntax? right;

        internal SimpleAssignmentExpressionSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public ExpressionListSyntax Left => GetRedAtZero(ref this.left)!;

        /// <summary>SyntaxToken representing the operator of the assignment expression.</summary>
        public override SyntaxToken OperatorToken => this.EqualsToken;
        public SyntaxToken EqualsToken => new SyntaxToken(this, ((Syntax.InternalSyntax.SimpleAssignmentExpressionSyntax)this.Green).equalsToken, GetChildPosition(1), GetChildIndex(1));

        public ExpressionListSyntax Right => GetRed(ref this.right, 2)!;

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                0 => GetRedAtZero(ref this.left)!,
                2 => GetRed(ref this.right, 2)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                0 => this.left,
                2 => this.right,
                _ => null,
            };

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitSimpleAssignmentExpression(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitSimpleAssignmentExpression(this);

        public SimpleAssignmentExpressionSyntax Update(ExpressionListSyntax left, SyntaxToken equalsToken, ExpressionListSyntax right)
        {
            if (left != this.Left || equalsToken != this.EqualsToken || right != this.Right)
            {
                var newNode = SyntaxFactory.SimpleAssignmentExpression(left, equalsToken, right);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public SimpleAssignmentExpressionSyntax WithLeft(ExpressionListSyntax left) => Update(left, this.EqualsToken, this.Right);
        internal override BaseAssignmentExpressionSyntax WithOperatorTokenCore(SyntaxToken operatorToken) => WithEqualsToken(operatorToken);
        public new SimpleAssignmentExpressionSyntax WithEqualsToken(SyntaxToken equalsToken) => Update(this.Left, equalsToken, this.Right);
        public SimpleAssignmentExpressionSyntax WithRight(ExpressionListSyntax right) => Update(this.Left, this.EqualsToken, right);

        public SimpleAssignmentExpressionSyntax AddLeftExpressions(params ExpressionSyntax[] items) => WithLeft(this.Left.WithExpressions(this.Left.Expressions.AddRange(items)));
        public SimpleAssignmentExpressionSyntax AddRightExpressions(params ExpressionSyntax[] items) => WithRight(this.Right.WithExpressions(this.Right.Expressions.AddRange(items)));
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.AdditionAssignmentExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.SubtractionAssignmentExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.MultiplicationAssignmentExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.DivisionAssignmentExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.FloorDivisionAssignmentExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.ExponentiationAssignmentExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.ModuloAssignmentExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.BitwiseAndAssignmentExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.BitwiseExclusiveOrAssignmentExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.BitwiseOrAssignmentExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.BitwiseLeftShiftAssignmentExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.BitwiseRightShiftAssignmentExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.ConcatenationAssignmentExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.AndAssignmentExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.OrAssignmentExpression"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class UpdateAssignmentExpressionSyntax : BaseAssignmentExpressionSyntax
    {
        private ExpressionSyntax? left;
        private ExpressionListSyntax? right;

        internal UpdateAssignmentExpressionSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>ExpressionSyntax node representing the expression on the left of the assignment operator.</summary>
        public ExpressionSyntax Left => GetRedAtZero(ref this.left)!;

        /// <summary>SyntaxToken representing the operator of the update assignment expression.</summary>
        public override SyntaxToken OperatorToken => new SyntaxToken(this, ((Syntax.InternalSyntax.UpdateAssignmentExpressionSyntax)this.Green).operatorToken, GetChildPosition(1), GetChildIndex(1));

        public ExpressionListSyntax Right => GetRed(ref this.right, 2)!;

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                0 => GetRedAtZero(ref this.left)!,
                2 => GetRed(ref this.right, 2)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                0 => this.left,
                2 => this.right,
                _ => null,
            };

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitUpdateAssignmentExpression(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitUpdateAssignmentExpression(this);

        public UpdateAssignmentExpressionSyntax Update(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionListSyntax right)
        {
            if (left != this.Left || operatorToken != this.OperatorToken || right != this.Right)
            {
                var newNode = SyntaxFactory.UpdateAssignmentExpression(this.Kind(), left, operatorToken, right);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public UpdateAssignmentExpressionSyntax WithLeft(ExpressionSyntax left) => Update(left, this.OperatorToken, this.Right);
        internal override BaseAssignmentExpressionSyntax WithOperatorTokenCore(SyntaxToken operatorToken) => WithOperatorToken(operatorToken);
        public new UpdateAssignmentExpressionSyntax WithOperatorToken(SyntaxToken operatorToken) => Update(this.Left, operatorToken, this.Right);
        public UpdateAssignmentExpressionSyntax WithRight(ExpressionListSyntax right) => Update(this.Left, this.OperatorToken, right);

        public UpdateAssignmentExpressionSyntax AddRightExpressions(params ExpressionSyntax[] items) => WithRight(this.Right.WithExpressions(this.Right.Expressions.AddRange(items)));
    }

    /// <summary>Provides the base class from which the classes that represent statement syntax nodes are derived. This is an abstract class.</summary>
    public abstract partial class StatementSyntax : MoonScriptSyntaxNode
    {
        internal StatementSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.ExpressionStatement"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ExpressionStatementSyntax : StatementSyntax
    {
        private ExpressionSyntax? expression;
        private LineDecoratorSyntax? lineDecorator;

        internal ExpressionStatementSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public ExpressionSyntax Expression => GetRedAtZero(ref this.expression)!;

        public LineDecoratorSyntax? LineDecorator => GetRed(ref this.lineDecorator, 1);

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                0 => GetRedAtZero(ref this.expression)!,
                1 => GetRed(ref this.lineDecorator, 1),
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                0 => this.expression,
                1 => this.lineDecorator,
                _ => null,
            };

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitExpressionStatement(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitExpressionStatement(this);

        public ExpressionStatementSyntax Update(ExpressionSyntax expression, LineDecoratorSyntax? lineDecorator)
        {
            if (expression != this.Expression || lineDecorator != this.LineDecorator)
            {
                var newNode = SyntaxFactory.ExpressionStatement(expression, lineDecorator);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ExpressionStatementSyntax WithExpression(ExpressionSyntax expression) => Update(expression, this.LineDecorator);
        public ExpressionStatementSyntax WithLineDecorator(LineDecoratorSyntax? lineDecorator) => Update(this.Expression, lineDecorator);
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.BreakStatement"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class BreakStatementSyntax : StatementSyntax
    {
        private ConditionalLineDecoratorSyntax? lineDecorator;

        internal BreakStatementSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken BreakKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.BreakStatementSyntax)this.Green).breakKeyword, Position, 0);

        public ConditionalLineDecoratorSyntax? LineDecorator => GetRed(ref this.lineDecorator, 1);

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.lineDecorator, 1) : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.lineDecorator : null;

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitBreakStatement(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitBreakStatement(this);

        public BreakStatementSyntax Update(SyntaxToken breakKeyword, ConditionalLineDecoratorSyntax? lineDecorator)
        {
            if (breakKeyword != this.BreakKeyword || lineDecorator != this.LineDecorator)
            {
                var newNode = SyntaxFactory.BreakStatement(breakKeyword, lineDecorator);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public BreakStatementSyntax WithBreakKeyword(SyntaxToken breakKeyword) => Update(breakKeyword, this.LineDecorator);
        public BreakStatementSyntax WithLineDecorator(ConditionalLineDecoratorSyntax? lineDecorator) => Update(this.BreakKeyword, lineDecorator);
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.ClassStatement"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ClassStatementSyntax : MoonScriptSyntaxNode
    {
        private IdentifierNameSyntax? name;
        private IdentifierNameSyntax? baseName;
        private SyntaxNode? statements;

        internal ClassStatementSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken ClassKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.ClassStatementSyntax)this.Green).classKeyword, Position, 0);

        public IdentifierNameSyntax Name => GetRed(ref this.name, 1)!;

        public SyntaxToken ExtendsKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.ClassStatementSyntax)this.Green).extendsKeyword, GetChildPosition(2), GetChildIndex(2));

        public IdentifierNameSyntax BaseName => GetRed(ref this.baseName, 3)!;

        public SyntaxList<StatementSyntax> Statements => new SyntaxList<StatementSyntax>(GetRed(ref this.statements, 4));

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                1 => GetRed(ref this.name, 1)!,
                3 => GetRed(ref this.baseName, 3)!,
                4 => GetRed(ref this.statements, 4)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                1 => this.name,
                3 => this.baseName,
                4 => this.statements,
                _ => null,
            };

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitClassStatement(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitClassStatement(this);

        public ClassStatementSyntax Update(SyntaxToken classKeyword, IdentifierNameSyntax name, SyntaxToken extendsKeyword, IdentifierNameSyntax baseName, SyntaxList<StatementSyntax> statements)
        {
            if (classKeyword != this.ClassKeyword || name != this.Name || extendsKeyword != this.ExtendsKeyword || baseName != this.BaseName || statements != this.Statements)
            {
                var newNode = SyntaxFactory.ClassStatement(classKeyword, name, extendsKeyword, baseName, statements);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ClassStatementSyntax WithClassKeyword(SyntaxToken classKeyword) => Update(classKeyword, this.Name, this.ExtendsKeyword, this.BaseName, this.Statements);
        public ClassStatementSyntax WithName(IdentifierNameSyntax name) => Update(this.ClassKeyword, name, this.ExtendsKeyword, this.BaseName, this.Statements);
        public ClassStatementSyntax WithExtendsKeyword(SyntaxToken extendsKeyword) => Update(this.ClassKeyword, this.Name, extendsKeyword, this.BaseName, this.Statements);
        public ClassStatementSyntax WithBaseName(IdentifierNameSyntax baseName) => Update(this.ClassKeyword, this.Name, this.ExtendsKeyword, baseName, this.Statements);
        public ClassStatementSyntax WithStatements(SyntaxList<StatementSyntax> statements) => Update(this.ClassKeyword, this.Name, this.ExtendsKeyword, this.BaseName, statements);

        public ClassStatementSyntax AddStatements(params StatementSyntax[] items) => WithStatements(this.Statements.AddRange(items));
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.MemberStatement"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class MemberStatementSyntax : StatementSyntax
    {
        private NameColonSyntax? nameColon;
        private ExpressionSyntax? expression;

        internal MemberStatementSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken CommercialAtToken
        {
            get
            {
                var slot = ((Syntax.InternalSyntax.MemberStatementSyntax)this.Green).commercialAtToken;
                return slot != null ? new SyntaxToken(this, slot, Position, 0) : default;
            }
        }

        public NameColonSyntax NameColon => GetRed(ref this.nameColon, 1)!;

        public ExpressionSyntax Expression => GetRed(ref this.expression, 2)!;

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                1 => GetRed(ref this.nameColon, 1)!,
                2 => GetRed(ref this.expression, 2)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                1 => this.nameColon,
                2 => this.expression,
                _ => null,
            };

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitMemberStatement(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitMemberStatement(this);

        public MemberStatementSyntax Update(SyntaxToken commercialAtToken, NameColonSyntax nameColon, ExpressionSyntax expression)
        {
            if (commercialAtToken != this.CommercialAtToken || nameColon != this.NameColon || expression != this.Expression)
            {
                var newNode = SyntaxFactory.MemberStatement(commercialAtToken, nameColon, expression);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public MemberStatementSyntax WithCommercialAtToken(SyntaxToken commercialAtToken) => Update(commercialAtToken, this.NameColon, this.Expression);
        public MemberStatementSyntax WithNameColon(NameColonSyntax nameColon) => Update(this.CommercialAtToken, nameColon, this.Expression);
        public MemberStatementSyntax WithExpression(ExpressionSyntax expression) => Update(this.CommercialAtToken, this.NameColon, expression);
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.ContinueStatement"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ContinueStatementSyntax : StatementSyntax
    {
        private ConditionalLineDecoratorSyntax? lineDecorator;

        internal ContinueStatementSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken BreakKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.ContinueStatementSyntax)this.Green).breakKeyword, Position, 0);

        public ConditionalLineDecoratorSyntax? LineDecorator => GetRed(ref this.lineDecorator, 1);

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.lineDecorator, 1) : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.lineDecorator : null;

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitContinueStatement(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitContinueStatement(this);

        public ContinueStatementSyntax Update(SyntaxToken breakKeyword, ConditionalLineDecoratorSyntax? lineDecorator)
        {
            if (breakKeyword != this.BreakKeyword || lineDecorator != this.LineDecorator)
            {
                var newNode = SyntaxFactory.ContinueStatement(breakKeyword, lineDecorator);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ContinueStatementSyntax WithBreakKeyword(SyntaxToken breakKeyword) => Update(breakKeyword, this.LineDecorator);
        public ContinueStatementSyntax WithLineDecorator(ConditionalLineDecoratorSyntax? lineDecorator) => Update(this.BreakKeyword, lineDecorator);
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.DoStatement"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class DoStatementSyntax : StatementSyntax
    {
        private BlockSyntax? block;

        internal DoStatementSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken DoKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.DoStatementSyntax)this.Green).doKeyword, Position, 0);

        public BlockSyntax Block => GetRed(ref this.block, 1)!;

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.block, 1)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.block : null;

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitDoStatement(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitDoStatement(this);

        public DoStatementSyntax Update(SyntaxToken doKeyword, BlockSyntax block)
        {
            if (doKeyword != this.DoKeyword || block != this.Block)
            {
                var newNode = SyntaxFactory.DoStatement(doKeyword, block);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public DoStatementSyntax WithDoKeyword(SyntaxToken doKeyword) => Update(doKeyword, this.Block);
        public DoStatementSyntax WithBlock(BlockSyntax block) => Update(this.DoKeyword, block);

        public DoStatementSyntax AddBlockStatements(params StatementSyntax[] items) => WithBlock(this.Block.WithStatements(this.Block.Statements.AddRange(items)));
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.ExportStatement"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ExportStatementSyntax : StatementSyntax
    {
        private SyntaxNode? names;
        private SimpleAssignmentExpressionSyntax? simpleAssignmentExpression;

        internal ExportStatementSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken ExportKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.ExportStatementSyntax)this.Green).exportKeyword, Position, 0);

        public SeparatedSyntaxList<IdentifierNameSyntax> Names
        {
            get
            {
                var red = GetRed(ref this.names, 1);
                return red != null ? new SeparatedSyntaxList<IdentifierNameSyntax>(red, GetChildIndex(1)) : default;
            }
        }

        public SimpleAssignmentExpressionSyntax? SimpleAssignmentExpression => GetRed(ref this.simpleAssignmentExpression, 2);

        public SyntaxToken AsteriskToken
        {
            get
            {
                var slot = ((Syntax.InternalSyntax.ExportStatementSyntax)this.Green).asteriskToken;
                return slot != null ? new SyntaxToken(this, slot, GetChildPosition(3), GetChildIndex(3)) : default;
            }
        }

        public SyntaxToken CaretToken
        {
            get
            {
                var slot = ((Syntax.InternalSyntax.ExportStatementSyntax)this.Green).caretToken;
                return slot != null ? new SyntaxToken(this, slot, GetChildPosition(4), GetChildIndex(4)) : default;
            }
        }

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                1 => GetRed(ref this.names, 1)!,
                2 => GetRed(ref this.simpleAssignmentExpression, 2),
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                1 => this.names,
                2 => this.simpleAssignmentExpression,
                _ => null,
            };

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitExportStatement(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitExportStatement(this);

        public ExportStatementSyntax Update(SyntaxToken exportKeyword, SeparatedSyntaxList<IdentifierNameSyntax> names, SimpleAssignmentExpressionSyntax? simpleAssignmentExpression, SyntaxToken asteriskToken, SyntaxToken caretToken)
        {
            if (exportKeyword != this.ExportKeyword || names != this.Names || simpleAssignmentExpression != this.SimpleAssignmentExpression || asteriskToken != this.AsteriskToken || caretToken != this.CaretToken)
            {
                var newNode = SyntaxFactory.ExportStatement(exportKeyword, names, simpleAssignmentExpression, asteriskToken, caretToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ExportStatementSyntax WithExportKeyword(SyntaxToken exportKeyword) => Update(exportKeyword, this.Names, this.SimpleAssignmentExpression, this.AsteriskToken, this.CaretToken);
        public ExportStatementSyntax WithNames(SeparatedSyntaxList<IdentifierNameSyntax> names) => Update(this.ExportKeyword, names, this.SimpleAssignmentExpression, this.AsteriskToken, this.CaretToken);
        public ExportStatementSyntax WithSimpleAssignmentExpression(SimpleAssignmentExpressionSyntax? simpleAssignmentExpression) => Update(this.ExportKeyword, this.Names, simpleAssignmentExpression, this.AsteriskToken, this.CaretToken);
        public ExportStatementSyntax WithAsteriskToken(SyntaxToken asteriskToken) => Update(this.ExportKeyword, this.Names, this.SimpleAssignmentExpression, asteriskToken, this.CaretToken);
        public ExportStatementSyntax WithCaretToken(SyntaxToken caretToken) => Update(this.ExportKeyword, this.Names, this.SimpleAssignmentExpression, this.AsteriskToken, caretToken);

        public ExportStatementSyntax AddNames(params IdentifierNameSyntax[] items) => WithNames(this.Names.AddRange(items));
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.ForStatement"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ForStatementSyntax : StatementSyntax
    {
        private IdentifierNameSyntax? name;
        private ExpressionSyntax? initial;
        private ExpressionSyntax? limit;
        private ExpressionSyntax? step;
        private BlockSyntax? block;

        internal ForStatementSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken ForKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.ForStatementSyntax)this.Green).forKeyword, Position, 0);

        public IdentifierNameSyntax Name => GetRed(ref this.name, 1)!;

        public SyntaxToken EqualsToken => new SyntaxToken(this, ((Syntax.InternalSyntax.ForStatementSyntax)this.Green).equalsToken, GetChildPosition(2), GetChildIndex(2));

        public ExpressionSyntax Initial => GetRed(ref this.initial, 3)!;

        public SyntaxToken FirstCommaToken => new SyntaxToken(this, ((Syntax.InternalSyntax.ForStatementSyntax)this.Green).firstCommaToken, GetChildPosition(4), GetChildIndex(4));

        public ExpressionSyntax Limit => GetRed(ref this.limit, 5)!;

        public SyntaxToken SecondCommaToken => new SyntaxToken(this, ((Syntax.InternalSyntax.ForStatementSyntax)this.Green).secondCommaToken, GetChildPosition(6), GetChildIndex(6));

        public ExpressionSyntax Step => GetRed(ref this.step, 7)!;

        public SyntaxToken DoKeyword
        {
            get
            {
                var slot = ((Syntax.InternalSyntax.ForStatementSyntax)this.Green).doKeyword;
                return slot != null ? new SyntaxToken(this, slot, GetChildPosition(8), GetChildIndex(8)) : default;
            }
        }

        public BlockSyntax Block => GetRed(ref this.block, 9)!;

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                1 => GetRed(ref this.name, 1)!,
                3 => GetRed(ref this.initial, 3)!,
                5 => GetRed(ref this.limit, 5)!,
                7 => GetRed(ref this.step, 7)!,
                9 => GetRed(ref this.block, 9)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                1 => this.name,
                3 => this.initial,
                5 => this.limit,
                7 => this.step,
                9 => this.block,
                _ => null,
            };

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitForStatement(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitForStatement(this);

        public ForStatementSyntax Update(SyntaxToken forKeyword, IdentifierNameSyntax name, SyntaxToken equalsToken, ExpressionSyntax initial, SyntaxToken firstCommaToken, ExpressionSyntax limit, SyntaxToken secondCommaToken, ExpressionSyntax step, SyntaxToken doKeyword, BlockSyntax block)
        {
            if (forKeyword != this.ForKeyword || name != this.Name || equalsToken != this.EqualsToken || initial != this.Initial || firstCommaToken != this.FirstCommaToken || limit != this.Limit || secondCommaToken != this.SecondCommaToken || step != this.Step || doKeyword != this.DoKeyword || block != this.Block)
            {
                var newNode = SyntaxFactory.ForStatement(forKeyword, name, equalsToken, initial, firstCommaToken, limit, secondCommaToken, step, doKeyword, block);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ForStatementSyntax WithForKeyword(SyntaxToken forKeyword) => Update(forKeyword, this.Name, this.EqualsToken, this.Initial, this.FirstCommaToken, this.Limit, this.SecondCommaToken, this.Step, this.DoKeyword, this.Block);
        public ForStatementSyntax WithName(IdentifierNameSyntax name) => Update(this.ForKeyword, name, this.EqualsToken, this.Initial, this.FirstCommaToken, this.Limit, this.SecondCommaToken, this.Step, this.DoKeyword, this.Block);
        public ForStatementSyntax WithEqualsToken(SyntaxToken equalsToken) => Update(this.ForKeyword, this.Name, equalsToken, this.Initial, this.FirstCommaToken, this.Limit, this.SecondCommaToken, this.Step, this.DoKeyword, this.Block);
        public ForStatementSyntax WithInitial(ExpressionSyntax initial) => Update(this.ForKeyword, this.Name, this.EqualsToken, initial, this.FirstCommaToken, this.Limit, this.SecondCommaToken, this.Step, this.DoKeyword, this.Block);
        public ForStatementSyntax WithFirstCommaToken(SyntaxToken firstCommaToken) => Update(this.ForKeyword, this.Name, this.EqualsToken, this.Initial, firstCommaToken, this.Limit, this.SecondCommaToken, this.Step, this.DoKeyword, this.Block);
        public ForStatementSyntax WithLimit(ExpressionSyntax limit) => Update(this.ForKeyword, this.Name, this.EqualsToken, this.Initial, this.FirstCommaToken, limit, this.SecondCommaToken, this.Step, this.DoKeyword, this.Block);
        public ForStatementSyntax WithSecondCommaToken(SyntaxToken secondCommaToken) => Update(this.ForKeyword, this.Name, this.EqualsToken, this.Initial, this.FirstCommaToken, this.Limit, secondCommaToken, this.Step, this.DoKeyword, this.Block);
        public ForStatementSyntax WithStep(ExpressionSyntax step) => Update(this.ForKeyword, this.Name, this.EqualsToken, this.Initial, this.FirstCommaToken, this.Limit, this.SecondCommaToken, step, this.DoKeyword, this.Block);
        public ForStatementSyntax WithDoKeyword(SyntaxToken doKeyword) => Update(this.ForKeyword, this.Name, this.EqualsToken, this.Initial, this.FirstCommaToken, this.Limit, this.SecondCommaToken, this.Step, doKeyword, this.Block);
        public ForStatementSyntax WithBlock(BlockSyntax block) => Update(this.ForKeyword, this.Name, this.EqualsToken, this.Initial, this.FirstCommaToken, this.Limit, this.SecondCommaToken, this.Step, this.DoKeyword, block);

        public ForStatementSyntax AddBlockStatements(params StatementSyntax[] items) => WithBlock(this.Block.WithStatements(this.Block.Statements.AddRange(items)));
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.ForInStatement"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ForInStatementSyntax : StatementSyntax
    {
        private SyntaxNode? names;
        private ExpressionSyntax? iteration;
        private BlockSyntax? block;

        internal ForInStatementSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken ForKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.ForInStatementSyntax)this.Green).forKeyword, Position, 0);

        public SeparatedSyntaxList<IdentifierNameSyntax> Names
        {
            get
            {
                var red = GetRed(ref this.names, 1);
                return red != null ? new SeparatedSyntaxList<IdentifierNameSyntax>(red, GetChildIndex(1)) : default;
            }
        }

        public SyntaxToken InKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.ForInStatementSyntax)this.Green).inKeyword, GetChildPosition(2), GetChildIndex(2));

        public ExpressionSyntax Iteration => GetRed(ref this.iteration, 3)!;

        public SyntaxToken DoKeyword
        {
            get
            {
                var slot = ((Syntax.InternalSyntax.ForInStatementSyntax)this.Green).doKeyword;
                return slot != null ? new SyntaxToken(this, slot, GetChildPosition(4), GetChildIndex(4)) : default;
            }
        }

        public BlockSyntax Block => GetRed(ref this.block, 5)!;

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                1 => GetRed(ref this.names, 1)!,
                3 => GetRed(ref this.iteration, 3)!,
                5 => GetRed(ref this.block, 5)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                1 => this.names,
                3 => this.iteration,
                5 => this.block,
                _ => null,
            };

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitForInStatement(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitForInStatement(this);

        public ForInStatementSyntax Update(SyntaxToken forKeyword, SeparatedSyntaxList<IdentifierNameSyntax> names, SyntaxToken inKeyword, ExpressionSyntax iteration, SyntaxToken doKeyword, BlockSyntax block)
        {
            if (forKeyword != this.ForKeyword || names != this.Names || inKeyword != this.InKeyword || iteration != this.Iteration || doKeyword != this.DoKeyword || block != this.Block)
            {
                var newNode = SyntaxFactory.ForInStatement(forKeyword, names, inKeyword, iteration, doKeyword, block);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ForInStatementSyntax WithForKeyword(SyntaxToken forKeyword) => Update(forKeyword, this.Names, this.InKeyword, this.Iteration, this.DoKeyword, this.Block);
        public ForInStatementSyntax WithNames(SeparatedSyntaxList<IdentifierNameSyntax> names) => Update(this.ForKeyword, names, this.InKeyword, this.Iteration, this.DoKeyword, this.Block);
        public ForInStatementSyntax WithInKeyword(SyntaxToken inKeyword) => Update(this.ForKeyword, this.Names, inKeyword, this.Iteration, this.DoKeyword, this.Block);
        public ForInStatementSyntax WithIteration(ExpressionSyntax iteration) => Update(this.ForKeyword, this.Names, this.InKeyword, iteration, this.DoKeyword, this.Block);
        public ForInStatementSyntax WithDoKeyword(SyntaxToken doKeyword) => Update(this.ForKeyword, this.Names, this.InKeyword, this.Iteration, doKeyword, this.Block);
        public ForInStatementSyntax WithBlock(BlockSyntax block) => Update(this.ForKeyword, this.Names, this.InKeyword, this.Iteration, this.DoKeyword, block);

        public ForInStatementSyntax AddNames(params IdentifierNameSyntax[] items) => WithNames(this.Names.AddRange(items));
        public ForInStatementSyntax AddBlockStatements(params StatementSyntax[] items) => WithBlock(this.Block.WithStatements(this.Block.Statements.AddRange(items)));
    }

    public abstract partial class BaseConditionalStatementSyntax : StatementSyntax
    {
        internal BaseConditionalStatementSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public abstract ExpressionSyntax Condition { get; }
        public BaseConditionalStatementSyntax WithCondition(ExpressionSyntax condition) => WithConditionCore(condition);
        internal abstract BaseConditionalStatementSyntax WithConditionCore(ExpressionSyntax condition);

        public abstract BlockSyntax Block { get; }
        public BaseConditionalStatementSyntax WithBlock(BlockSyntax block) => WithBlockCore(block);
        internal abstract BaseConditionalStatementSyntax WithBlockCore(BlockSyntax block);

        public BaseConditionalStatementSyntax AddBlockStatements(params StatementSyntax[] items) => AddBlockStatementsCore(items);
        internal abstract BaseConditionalStatementSyntax AddBlockStatementsCore(params StatementSyntax[] items);
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.IfStatement"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class IfStatementSyntax : BaseConditionalStatementSyntax
    {
        private ExpressionSyntax? condition;
        private BlockSyntax? block;
        private SyntaxNode? elseIfs;
        private ElseClauseSyntax? @else;

        internal IfStatementSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public override ExpressionSyntax Condition => GetRedAtZero(ref this.condition)!;

        public SyntaxToken ThenKeyword
        {
            get
            {
                var slot = ((Syntax.InternalSyntax.IfStatementSyntax)this.Green).thenKeyword;
                return slot != null ? new SyntaxToken(this, slot, GetChildPosition(1), GetChildIndex(1)) : default;
            }
        }

        public override BlockSyntax Block => GetRed(ref this.block, 2)!;

        public SyntaxList<ElseIfClauseSyntax> ElseIfs => new SyntaxList<ElseIfClauseSyntax>(GetRed(ref this.elseIfs, 3));

        public ElseClauseSyntax? Else => GetRed(ref this.@else, 4);

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                0 => GetRedAtZero(ref this.condition)!,
                2 => GetRed(ref this.block, 2)!,
                3 => GetRed(ref this.elseIfs, 3),
                4 => GetRed(ref this.@else, 4),
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                0 => this.condition,
                2 => this.block,
                3 => this.elseIfs,
                4 => this.@else,
                _ => null,
            };

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitIfStatement(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitIfStatement(this);

        public IfStatementSyntax Update(ExpressionSyntax condition, SyntaxToken thenKeyword, BlockSyntax block, SyntaxList<ElseIfClauseSyntax> elseIfs, ElseClauseSyntax? @else)
        {
            if (condition != this.Condition || thenKeyword != this.ThenKeyword || block != this.Block || elseIfs != this.ElseIfs || @else != this.Else)
            {
                var newNode = SyntaxFactory.IfStatement(condition, thenKeyword, block, elseIfs, @else);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        internal override BaseConditionalStatementSyntax WithConditionCore(ExpressionSyntax condition) => WithCondition(condition);
        public new IfStatementSyntax WithCondition(ExpressionSyntax condition) => Update(condition, this.ThenKeyword, this.Block, this.ElseIfs, this.Else);
        public IfStatementSyntax WithThenKeyword(SyntaxToken thenKeyword) => Update(this.Condition, thenKeyword, this.Block, this.ElseIfs, this.Else);
        internal override BaseConditionalStatementSyntax WithBlockCore(BlockSyntax block) => WithBlock(block);
        public new IfStatementSyntax WithBlock(BlockSyntax block) => Update(this.Condition, this.ThenKeyword, block, this.ElseIfs, this.Else);
        public IfStatementSyntax WithElseIfs(SyntaxList<ElseIfClauseSyntax> elseIfs) => Update(this.Condition, this.ThenKeyword, this.Block, elseIfs, this.Else);
        public IfStatementSyntax WithElse(ElseClauseSyntax? @else) => Update(this.Condition, this.ThenKeyword, this.Block, this.ElseIfs, @else);

        internal override BaseConditionalStatementSyntax AddBlockStatementsCore(params StatementSyntax[] items) => AddBlockStatements(items);
        public new IfStatementSyntax AddBlockStatements(params StatementSyntax[] items) => WithBlock(this.Block.WithStatements(this.Block.Statements.AddRange(items)));
        public IfStatementSyntax AddElseIfs(params ElseIfClauseSyntax[] items) => WithElseIfs(this.ElseIfs.AddRange(items));
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.ImportStatement"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ImportStatementSytnax : StatementSyntax
    {
        private SyntaxNode? names;
        private IdentifierNameSyntax? from;

        internal ImportStatementSytnax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken ImportKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.ImportStatementSytnax)this.Green).importKeyword, Position, 0);

        public SeparatedSyntaxList<ImportNameSyntax> Names
        {
            get
            {
                var red = GetRed(ref this.names, 1);
                return red != null ? new SeparatedSyntaxList<ImportNameSyntax>(red, GetChildIndex(1)) : default;
            }
        }

        public SyntaxToken FromKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.ImportStatementSytnax)this.Green).fromKeyword, GetChildPosition(2), GetChildIndex(2));

        public IdentifierNameSyntax From => GetRed(ref this.from, 3)!;

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                1 => GetRed(ref this.names, 1)!,
                3 => GetRed(ref this.from, 3)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                1 => this.names,
                3 => this.from,
                _ => null,
            };

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitImportStatementSytnax(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitImportStatementSytnax(this);

        public ImportStatementSytnax Update(SyntaxToken importKeyword, SeparatedSyntaxList<ImportNameSyntax> names, SyntaxToken fromKeyword, IdentifierNameSyntax from)
        {
            if (importKeyword != this.ImportKeyword || names != this.Names || fromKeyword != this.FromKeyword || from != this.From)
            {
                var newNode = SyntaxFactory.ImportStatementSytnax(importKeyword, names, fromKeyword, from);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ImportStatementSytnax WithImportKeyword(SyntaxToken importKeyword) => Update(importKeyword, this.Names, this.FromKeyword, this.From);
        public ImportStatementSytnax WithNames(SeparatedSyntaxList<ImportNameSyntax> names) => Update(this.ImportKeyword, names, this.FromKeyword, this.From);
        public ImportStatementSytnax WithFromKeyword(SyntaxToken fromKeyword) => Update(this.ImportKeyword, this.Names, fromKeyword, this.From);
        public ImportStatementSytnax WithFrom(IdentifierNameSyntax from) => Update(this.ImportKeyword, this.Names, this.FromKeyword, from);

        public ImportStatementSytnax AddNames(params ImportNameSyntax[] items) => WithNames(this.Names.AddRange(items));
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.LocalStatement"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class LocalStatementSyntax : StatementSyntax
    {
        private SyntaxNode? names;
        private SimpleAssignmentExpressionSyntax? simpleAssignmentExpression;

        internal LocalStatementSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken LocalKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.LocalStatementSyntax)this.Green).localKeyword, Position, 0);

        public SeparatedSyntaxList<IdentifierNameSyntax> Names
        {
            get
            {
                var red = GetRed(ref this.names, 1);
                return red != null ? new SeparatedSyntaxList<IdentifierNameSyntax>(red, GetChildIndex(1)) : default;
            }
        }

        public SimpleAssignmentExpressionSyntax? SimpleAssignmentExpression => GetRed(ref this.simpleAssignmentExpression, 2);

        public SyntaxToken AsteriskToken
        {
            get
            {
                var slot = ((Syntax.InternalSyntax.LocalStatementSyntax)this.Green).asteriskToken;
                return slot != null ? new SyntaxToken(this, slot, GetChildPosition(3), GetChildIndex(3)) : default;
            }
        }

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                1 => GetRed(ref this.names, 1)!,
                2 => GetRed(ref this.simpleAssignmentExpression, 2),
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                1 => this.names,
                2 => this.simpleAssignmentExpression,
                _ => null,
            };

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitLocalStatement(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitLocalStatement(this);

        public LocalStatementSyntax Update(SyntaxToken localKeyword, SeparatedSyntaxList<IdentifierNameSyntax> names, SimpleAssignmentExpressionSyntax? simpleAssignmentExpression, SyntaxToken asteriskToken)
        {
            if (localKeyword != this.LocalKeyword || names != this.Names || simpleAssignmentExpression != this.SimpleAssignmentExpression || asteriskToken != this.AsteriskToken)
            {
                var newNode = SyntaxFactory.LocalStatement(localKeyword, names, simpleAssignmentExpression, asteriskToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public LocalStatementSyntax WithLocalKeyword(SyntaxToken localKeyword) => Update(localKeyword, this.Names, this.SimpleAssignmentExpression, this.AsteriskToken);
        public LocalStatementSyntax WithNames(SeparatedSyntaxList<IdentifierNameSyntax> names) => Update(this.LocalKeyword, names, this.SimpleAssignmentExpression, this.AsteriskToken);
        public LocalStatementSyntax WithSimpleAssignmentExpression(SimpleAssignmentExpressionSyntax? simpleAssignmentExpression) => Update(this.LocalKeyword, this.Names, simpleAssignmentExpression, this.AsteriskToken);
        public LocalStatementSyntax WithAsteriskToken(SyntaxToken asteriskToken) => Update(this.LocalKeyword, this.Names, this.SimpleAssignmentExpression, asteriskToken);

        public LocalStatementSyntax AddNames(params IdentifierNameSyntax[] items) => WithNames(this.Names.AddRange(items));
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.SwitchStatement"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class SwitchStatementSyntax : StatementSyntax
    {
        private ExpressionSyntax? expression;
        private SyntaxNode? whens;
        private ElseClauseSyntax? @else;

        internal SwitchStatementSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public ExpressionSyntax Expression => GetRedAtZero(ref this.expression)!;

        public SyntaxList<WhenClauseSyntax> Whens => new SyntaxList<WhenClauseSyntax>(GetRed(ref this.whens, 1));

        public ElseClauseSyntax Else => GetRed(ref this.@else, 2)!;

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                0 => GetRedAtZero(ref this.expression)!,
                1 => GetRed(ref this.whens, 1)!,
                2 => GetRed(ref this.@else, 2)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                0 => this.expression,
                1 => this.whens,
                2 => this.@else,
                _ => null,
            };

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitSwitchStatement(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitSwitchStatement(this);

        public SwitchStatementSyntax Update(ExpressionSyntax expression, SyntaxList<WhenClauseSyntax> whens, ElseClauseSyntax @else)
        {
            if (expression != this.Expression || whens != this.Whens || @else != this.Else)
            {
                var newNode = SyntaxFactory.SwitchStatement(expression, whens, @else);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public SwitchStatementSyntax WithExpression(ExpressionSyntax expression) => Update(expression, this.Whens, this.Else);
        public SwitchStatementSyntax WithWhens(SyntaxList<WhenClauseSyntax> whens) => Update(this.Expression, whens, this.Else);
        public SwitchStatementSyntax WithElse(ElseClauseSyntax @else) => Update(this.Expression, this.Whens, @else);

        public SwitchStatementSyntax AddWhens(params WhenClauseSyntax[] items) => WithWhens(this.Whens.AddRange(items));
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.UnlessStatement"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class UnlessStatementSyntax : BaseConditionalStatementSyntax
    {
        private ExpressionSyntax? condition;
        private BlockSyntax? block;

        internal UnlessStatementSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken UnlessKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.UnlessStatementSyntax)this.Green).unlessKeyword, Position, 0);

        public override ExpressionSyntax Condition => GetRed(ref this.condition, 1)!;

        public SyntaxToken ThenKeyword
        {
            get
            {
                var slot = ((Syntax.InternalSyntax.UnlessStatementSyntax)this.Green).thenKeyword;
                return slot != null ? new SyntaxToken(this, slot, GetChildPosition(2), GetChildIndex(2)) : default;
            }
        }

        public override BlockSyntax Block => GetRed(ref this.block, 3)!;

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                1 => GetRed(ref this.condition, 1)!,
                3 => GetRed(ref this.block, 3)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                1 => this.condition,
                3 => this.block,
                _ => null,
            };

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitUnlessStatement(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitUnlessStatement(this);

        public UnlessStatementSyntax Update(SyntaxToken unlessKeyword, ExpressionSyntax condition, SyntaxToken thenKeyword, BlockSyntax block)
        {
            if (unlessKeyword != this.UnlessKeyword || condition != this.Condition || thenKeyword != this.ThenKeyword || block != this.Block)
            {
                var newNode = SyntaxFactory.UnlessStatement(unlessKeyword, condition, thenKeyword, block);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public UnlessStatementSyntax WithUnlessKeyword(SyntaxToken unlessKeyword) => Update(unlessKeyword, this.Condition, this.ThenKeyword, this.Block);
        internal override BaseConditionalStatementSyntax WithConditionCore(ExpressionSyntax condition) => WithCondition(condition);
        public new UnlessStatementSyntax WithCondition(ExpressionSyntax condition) => Update(this.UnlessKeyword, condition, this.ThenKeyword, this.Block);
        public UnlessStatementSyntax WithThenKeyword(SyntaxToken thenKeyword) => Update(this.UnlessKeyword, this.Condition, thenKeyword, this.Block);
        internal override BaseConditionalStatementSyntax WithBlockCore(BlockSyntax block) => WithBlock(block);
        public new UnlessStatementSyntax WithBlock(BlockSyntax block) => Update(this.UnlessKeyword, this.Condition, this.ThenKeyword, block);

        internal override BaseConditionalStatementSyntax AddBlockStatementsCore(params StatementSyntax[] items) => AddBlockStatements(items);
        public new UnlessStatementSyntax AddBlockStatements(params StatementSyntax[] items) => WithBlock(this.Block.WithStatements(this.Block.Statements.AddRange(items)));
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.UsingClause"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class UsingClauseSyntax : MoonScriptSyntaxNode
    {
        private SyntaxNode? names;

        internal UsingClauseSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken UsingKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.UsingClauseSyntax)this.Green).usingKeyword, Position, 0);

        public SyntaxToken NilKeyword
        {
            get
            {
                var slot = ((Syntax.InternalSyntax.UsingClauseSyntax)this.Green).nilKeyword;
                return slot != null ? new SyntaxToken(this, slot, GetChildPosition(1), GetChildIndex(1)) : default;
            }
        }

        public SeparatedSyntaxList<IdentifierNameSyntax> Names
        {
            get
            {
                var red = GetRed(ref this.names, 2);
                return red != null ? new SeparatedSyntaxList<IdentifierNameSyntax>(red, GetChildIndex(2)) : default;
            }
        }

        internal override SyntaxNode? GetNodeSlot(int index) => index == 2 ? GetRed(ref this.names, 2)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 2 ? this.names : null;

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitUsingClause(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitUsingClause(this);

        public UsingClauseSyntax Update(SyntaxToken usingKeyword, SyntaxToken nilKeyword, SeparatedSyntaxList<IdentifierNameSyntax> names)
        {
            if (usingKeyword != this.UsingKeyword || nilKeyword != this.NilKeyword || names != this.Names)
            {
                var newNode = SyntaxFactory.UsingClause(usingKeyword, nilKeyword, names);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public UsingClauseSyntax WithUsingKeyword(SyntaxToken usingKeyword) => Update(usingKeyword, this.NilKeyword, this.Names);
        public UsingClauseSyntax WithNilKeyword(SyntaxToken nilKeyword) => Update(this.UsingKeyword, nilKeyword, this.Names);
        public UsingClauseSyntax WithNames(SeparatedSyntaxList<IdentifierNameSyntax> names) => Update(this.UsingKeyword, this.NilKeyword, names);

        public UsingClauseSyntax AddNames(params IdentifierNameSyntax[] items) => WithNames(this.Names.AddRange(items));
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.WhileStatement"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class WhileStatementSyntax : StatementSyntax
    {
        private ExpressionSyntax? condition;
        private BlockSyntax? block;

        internal WhileStatementSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken WhileKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.WhileStatementSyntax)this.Green).whileKeyword, Position, 0);

        public ExpressionSyntax Condition => GetRed(ref this.condition, 1)!;

        public SyntaxToken DoKeyword
        {
            get
            {
                var slot = ((Syntax.InternalSyntax.WhileStatementSyntax)this.Green).doKeyword;
                return slot != null ? new SyntaxToken(this, slot, GetChildPosition(2), GetChildIndex(2)) : default;
            }
        }

        public BlockSyntax Block => GetRed(ref this.block, 3)!;

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                1 => GetRed(ref this.condition, 1)!,
                3 => GetRed(ref this.block, 3)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                1 => this.condition,
                3 => this.block,
                _ => null,
            };

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitWhileStatement(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitWhileStatement(this);

        public WhileStatementSyntax Update(SyntaxToken whileKeyword, ExpressionSyntax condition, SyntaxToken doKeyword, BlockSyntax block)
        {
            if (whileKeyword != this.WhileKeyword || condition != this.Condition || doKeyword != this.DoKeyword || block != this.Block)
            {
                var newNode = SyntaxFactory.WhileStatement(whileKeyword, condition, doKeyword, block);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public WhileStatementSyntax WithWhileKeyword(SyntaxToken whileKeyword) => Update(whileKeyword, this.Condition, this.DoKeyword, this.Block);
        public WhileStatementSyntax WithCondition(ExpressionSyntax condition) => Update(this.WhileKeyword, condition, this.DoKeyword, this.Block);
        public WhileStatementSyntax WithDoKeyword(SyntaxToken doKeyword) => Update(this.WhileKeyword, this.Condition, doKeyword, this.Block);
        public WhileStatementSyntax WithBlock(BlockSyntax block) => Update(this.WhileKeyword, this.Condition, this.DoKeyword, block);

        public WhileStatementSyntax AddBlockStatements(params StatementSyntax[] items) => WithBlock(this.Block.WithStatements(this.Block.Statements.AddRange(items)));
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.WithStatement"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class WithStatementSyntax : StatementSyntax
    {
        private ExpressionSyntax? expression;
        private BlockSyntax? block;

        internal WithStatementSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken WithKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.WithStatementSyntax)this.Green).withKeyword, Position, 0);

        public ExpressionSyntax Expression => GetRed(ref this.expression, 1)!;

        public BlockSyntax Block => GetRed(ref this.block, 2)!;

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                1 => GetRed(ref this.expression, 1)!,
                2 => GetRed(ref this.block, 2)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                1 => this.expression,
                2 => this.block,
                _ => null,
            };

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitWithStatement(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitWithStatement(this);

        public WithStatementSyntax Update(SyntaxToken withKeyword, ExpressionSyntax expression, BlockSyntax block)
        {
            if (withKeyword != this.WithKeyword || expression != this.Expression || block != this.Block)
            {
                var newNode = SyntaxFactory.WithStatement(withKeyword, expression, block);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public WithStatementSyntax WithWithKeyword(SyntaxToken withKeyword) => Update(withKeyword, this.Expression, this.Block);
        public WithStatementSyntax WithExpression(ExpressionSyntax expression) => Update(this.WithKeyword, expression, this.Block);
        public WithStatementSyntax WithBlock(BlockSyntax block) => Update(this.WithKeyword, this.Expression, block);

        public WithStatementSyntax AddBlockStatements(params StatementSyntax[] items) => WithBlock(this.Block.WithStatements(this.Block.Statements.AddRange(items)));
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.DestructuringAssignmentStatement"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class DestructuringAssignmentStatementSyntax : StatementSyntax
    {
        private DestructuringUnitSyntax? unit;
        private ExpressionSyntax? expression;

        internal DestructuringAssignmentStatementSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public DestructuringUnitSyntax Unit => GetRedAtZero(ref this.unit)!;

        public SyntaxToken EqualsToken => new SyntaxToken(this, ((Syntax.InternalSyntax.DestructuringAssignmentStatementSyntax)this.Green).equalsToken, GetChildPosition(1), GetChildIndex(1));

        public ExpressionSyntax Expression => GetRed(ref this.expression, 2)!;

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                0 => GetRedAtZero(ref this.unit)!,
                2 => GetRed(ref this.expression, 2)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                0 => this.unit,
                2 => this.expression,
                _ => null,
            };

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitDestructuringAssignmentStatement(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitDestructuringAssignmentStatement(this);

        public DestructuringAssignmentStatementSyntax Update(DestructuringUnitSyntax unit, SyntaxToken equalsToken, ExpressionSyntax expression)
        {
            if (unit != this.Unit || equalsToken != this.EqualsToken || expression != this.Expression)
            {
                var newNode = SyntaxFactory.DestructuringAssignmentStatement(unit, equalsToken, expression);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public DestructuringAssignmentStatementSyntax WithUnit(DestructuringUnitSyntax unit) => Update(unit, this.EqualsToken, this.Expression);
        public DestructuringAssignmentStatementSyntax WithEqualsToken(SyntaxToken equalsToken) => Update(this.Unit, equalsToken, this.Expression);
        public DestructuringAssignmentStatementSyntax WithExpression(ExpressionSyntax expression) => Update(this.Unit, this.EqualsToken, expression);
    }

    public abstract partial class DestructuringUnitSyntax : MoonScriptSyntaxNode
    {
        internal DestructuringUnitSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.DestructuringIdentifierName"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class DestructuringIdentifierNameSyntax : DestructuringUnitSyntax
    {
        private IdentifierNameSyntax? name;

        internal DestructuringIdentifierNameSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public IdentifierNameSyntax Name => GetRedAtZero(ref this.name)!;

        internal override SyntaxNode? GetNodeSlot(int index) => index == 0 ? GetRedAtZero(ref this.name)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 0 ? this.name : null;

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitDestructuringIdentifierName(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitDestructuringIdentifierName(this);

        public DestructuringIdentifierNameSyntax Update(IdentifierNameSyntax name)
        {
            if (name != this.Name)
            {
                var newNode = SyntaxFactory.DestructuringIdentifierName(name);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public DestructuringIdentifierNameSyntax WithName(IdentifierNameSyntax name) => Update(name);
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.DestructuringList"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class DestructuringListSyntax : DestructuringUnitSyntax
    {
        private SyntaxNode? units;

        internal DestructuringListSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SeparatedSyntaxList<DestructuringUnitSyntax> Units
        {
            get
            {
                var red = GetRed(ref this.units, 0);
                return red != null ? new SeparatedSyntaxList<DestructuringUnitSyntax>(red, 0) : default;
            }
        }

        internal override SyntaxNode? GetNodeSlot(int index) => index == 0 ? GetRedAtZero(ref this.units)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 0 ? this.units : null;

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitDestructuringList(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitDestructuringList(this);

        public DestructuringListSyntax Update(SeparatedSyntaxList<DestructuringUnitSyntax> units)
        {
            if (units != this.Units)
            {
                var newNode = SyntaxFactory.DestructuringList(units);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public DestructuringListSyntax WithUnits(SeparatedSyntaxList<DestructuringUnitSyntax> units) => Update(units);

        public DestructuringListSyntax AddUnits(params DestructuringUnitSyntax[] items) => WithUnits(this.Units.AddRange(items));
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.DestructuringField"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class DestructuringFieldSyntax : DestructuringUnitSyntax
    {
        private DestructuringUnitSyntax? unit;
        private NameColonSyntax? nameColon;
        private DestructuringUnitSyntax? namedUnit;
        private ColonNameSyntax? colonName;

        internal DestructuringFieldSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public DestructuringUnitSyntax? Unit => GetRedAtZero(ref this.unit);

        public NameColonSyntax? NameColon => GetRed(ref this.nameColon, 1);

        public DestructuringUnitSyntax? NamedUnit => GetRed(ref this.namedUnit, 2);

        public ColonNameSyntax? ColonName => GetRed(ref this.colonName, 3);

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                0 => GetRedAtZero(ref this.unit),
                1 => GetRed(ref this.nameColon, 1),
                2 => GetRed(ref this.namedUnit, 2),
                3 => GetRed(ref this.colonName, 3),
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                0 => this.unit,
                1 => this.nameColon,
                2 => this.namedUnit,
                3 => this.colonName,
                _ => null,
            };

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitDestructuringField(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitDestructuringField(this);

        public DestructuringFieldSyntax Update(DestructuringUnitSyntax? unit, NameColonSyntax? nameColon, DestructuringUnitSyntax? namedUnit, ColonNameSyntax? colonName)
        {
            if (unit != this.Unit || nameColon != this.NameColon || namedUnit != this.NamedUnit || colonName != this.ColonName)
            {
                var newNode = SyntaxFactory.DestructuringField(unit, nameColon, namedUnit, colonName);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public DestructuringFieldSyntax WithUnit(DestructuringUnitSyntax? unit) => Update(unit, this.NameColon, this.NamedUnit, this.ColonName);
        public DestructuringFieldSyntax WithNameColon(NameColonSyntax? nameColon) => Update(this.Unit, nameColon, this.NamedUnit, this.ColonName);
        public DestructuringFieldSyntax WithNamedUnit(DestructuringUnitSyntax? namedUnit) => Update(this.Unit, this.NameColon, namedUnit, this.ColonName);
        public DestructuringFieldSyntax WithColonName(ColonNameSyntax? colonName) => Update(this.Unit, this.NameColon, this.NamedUnit, colonName);
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.DestructuringList"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class DestructuringTableSyntax : DestructuringUnitSyntax
    {
        private SyntaxNode? fields;

        internal DestructuringTableSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken OpenBraceToken
        {
            get
            {
                var slot = ((Syntax.InternalSyntax.DestructuringTableSyntax)this.Green).openBraceToken;
                return slot != null ? new SyntaxToken(this, slot, Position, 0) : default;
            }
        }

        public SyntaxList<DestructuringFieldSyntax> Fields => new SyntaxList<DestructuringFieldSyntax>(GetRed(ref this.fields, 1));

        public SyntaxToken CloseBraceToken
        {
            get
            {
                var slot = ((Syntax.InternalSyntax.DestructuringTableSyntax)this.Green).closeBraceToken;
                return slot != null ? new SyntaxToken(this, slot, GetChildPosition(2), GetChildIndex(2)) : default;
            }
        }

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.fields, 1)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.fields : null;

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitDestructuringTable(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitDestructuringTable(this);

        public DestructuringTableSyntax Update(SyntaxToken openBraceToken, SyntaxList<DestructuringFieldSyntax> fields, SyntaxToken closeBraceToken)
        {
            if (openBraceToken != this.OpenBraceToken || fields != this.Fields || closeBraceToken != this.CloseBraceToken)
            {
                var newNode = SyntaxFactory.DestructuringTable(openBraceToken, fields, closeBraceToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public DestructuringTableSyntax WithOpenBraceToken(SyntaxToken openBraceToken) => Update(openBraceToken, this.Fields, this.CloseBraceToken);
        public DestructuringTableSyntax WithFields(SyntaxList<DestructuringFieldSyntax> fields) => Update(this.OpenBraceToken, fields, this.CloseBraceToken);
        public DestructuringTableSyntax WithCloseBraceToken(SyntaxToken closeBraceToken) => Update(this.OpenBraceToken, this.Fields, closeBraceToken);

        public DestructuringTableSyntax AddFields(params DestructuringFieldSyntax[] items) => WithFields(this.Fields.AddRange(items));
    }

    public abstract partial class LineDecoratorSyntax : MoonScriptSyntaxNode
    {
        internal LineDecoratorSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.ForLineDecorator"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ForLineDecoratorSyntax : LineDecoratorSyntax
    {
        private IdentifierNameSyntax? name;
        private ExpressionSyntax? initial;
        private ExpressionSyntax? limit;
        private ExpressionSyntax? step;

        internal ForLineDecoratorSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken ForKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.ForLineDecoratorSyntax)this.Green).forKeyword, Position, 0);

        public IdentifierNameSyntax Name => GetRed(ref this.name, 1)!;

        public SyntaxToken EqualsToken => new SyntaxToken(this, ((Syntax.InternalSyntax.ForLineDecoratorSyntax)this.Green).equalsToken, GetChildPosition(2), GetChildIndex(2));

        public ExpressionSyntax Initial => GetRed(ref this.initial, 3)!;

        public SyntaxToken FirstCommaToken => new SyntaxToken(this, ((Syntax.InternalSyntax.ForLineDecoratorSyntax)this.Green).firstCommaToken, GetChildPosition(4), GetChildIndex(4));

        public ExpressionSyntax Limit => GetRed(ref this.limit, 5)!;

        public SyntaxToken SecondCommaToken => new SyntaxToken(this, ((Syntax.InternalSyntax.ForLineDecoratorSyntax)this.Green).secondCommaToken, GetChildPosition(6), GetChildIndex(6));

        public ExpressionSyntax Step => GetRed(ref this.step, 7)!;

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                1 => GetRed(ref this.name, 1)!,
                3 => GetRed(ref this.initial, 3)!,
                5 => GetRed(ref this.limit, 5)!,
                7 => GetRed(ref this.step, 7)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                1 => this.name,
                3 => this.initial,
                5 => this.limit,
                7 => this.step,
                _ => null,
            };

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitForLineDecorator(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitForLineDecorator(this);

        public ForLineDecoratorSyntax Update(SyntaxToken forKeyword, IdentifierNameSyntax name, SyntaxToken equalsToken, ExpressionSyntax initial, SyntaxToken firstCommaToken, ExpressionSyntax limit, SyntaxToken secondCommaToken, ExpressionSyntax step)
        {
            if (forKeyword != this.ForKeyword || name != this.Name || equalsToken != this.EqualsToken || initial != this.Initial || firstCommaToken != this.FirstCommaToken || limit != this.Limit || secondCommaToken != this.SecondCommaToken || step != this.Step)
            {
                var newNode = SyntaxFactory.ForLineDecorator(forKeyword, name, equalsToken, initial, firstCommaToken, limit, secondCommaToken, step);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ForLineDecoratorSyntax WithForKeyword(SyntaxToken forKeyword) => Update(forKeyword, this.Name, this.EqualsToken, this.Initial, this.FirstCommaToken, this.Limit, this.SecondCommaToken, this.Step);
        public ForLineDecoratorSyntax WithName(IdentifierNameSyntax name) => Update(this.ForKeyword, name, this.EqualsToken, this.Initial, this.FirstCommaToken, this.Limit, this.SecondCommaToken, this.Step);
        public ForLineDecoratorSyntax WithEqualsToken(SyntaxToken equalsToken) => Update(this.ForKeyword, this.Name, equalsToken, this.Initial, this.FirstCommaToken, this.Limit, this.SecondCommaToken, this.Step);
        public ForLineDecoratorSyntax WithInitial(ExpressionSyntax initial) => Update(this.ForKeyword, this.Name, this.EqualsToken, initial, this.FirstCommaToken, this.Limit, this.SecondCommaToken, this.Step);
        public ForLineDecoratorSyntax WithFirstCommaToken(SyntaxToken firstCommaToken) => Update(this.ForKeyword, this.Name, this.EqualsToken, this.Initial, firstCommaToken, this.Limit, this.SecondCommaToken, this.Step);
        public ForLineDecoratorSyntax WithLimit(ExpressionSyntax limit) => Update(this.ForKeyword, this.Name, this.EqualsToken, this.Initial, this.FirstCommaToken, limit, this.SecondCommaToken, this.Step);
        public ForLineDecoratorSyntax WithSecondCommaToken(SyntaxToken secondCommaToken) => Update(this.ForKeyword, this.Name, this.EqualsToken, this.Initial, this.FirstCommaToken, this.Limit, secondCommaToken, this.Step);
        public ForLineDecoratorSyntax WithStep(ExpressionSyntax step) => Update(this.ForKeyword, this.Name, this.EqualsToken, this.Initial, this.FirstCommaToken, this.Limit, this.SecondCommaToken, step);
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.ForInLineDecorator"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ForInLineDecoratorSyntax : LineDecoratorSyntax
    {
        private SyntaxNode? names;
        private ExpressionSyntax? iteration;

        internal ForInLineDecoratorSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken ForKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.ForInLineDecoratorSyntax)this.Green).forKeyword, Position, 0);

        public SeparatedSyntaxList<IdentifierNameSyntax> Names
        {
            get
            {
                var red = GetRed(ref this.names, 1);
                return red != null ? new SeparatedSyntaxList<IdentifierNameSyntax>(red, GetChildIndex(1)) : default;
            }
        }

        public SyntaxToken InKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.ForInLineDecoratorSyntax)this.Green).inKeyword, GetChildPosition(2), GetChildIndex(2));

        public ExpressionSyntax Iteration => GetRed(ref this.iteration, 3)!;

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                1 => GetRed(ref this.names, 1)!,
                3 => GetRed(ref this.iteration, 3)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                1 => this.names,
                3 => this.iteration,
                _ => null,
            };

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitForInLineDecorator(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitForInLineDecorator(this);

        public ForInLineDecoratorSyntax Update(SyntaxToken forKeyword, SeparatedSyntaxList<IdentifierNameSyntax> names, SyntaxToken inKeyword, ExpressionSyntax iteration)
        {
            if (forKeyword != this.ForKeyword || names != this.Names || inKeyword != this.InKeyword || iteration != this.Iteration)
            {
                var newNode = SyntaxFactory.ForInLineDecorator(forKeyword, names, inKeyword, iteration);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ForInLineDecoratorSyntax WithForKeyword(SyntaxToken forKeyword) => Update(forKeyword, this.Names, this.InKeyword, this.Iteration);
        public ForInLineDecoratorSyntax WithNames(SeparatedSyntaxList<IdentifierNameSyntax> names) => Update(this.ForKeyword, names, this.InKeyword, this.Iteration);
        public ForInLineDecoratorSyntax WithInKeyword(SyntaxToken inKeyword) => Update(this.ForKeyword, this.Names, inKeyword, this.Iteration);
        public ForInLineDecoratorSyntax WithIteration(ExpressionSyntax iteration) => Update(this.ForKeyword, this.Names, this.InKeyword, iteration);

        public ForInLineDecoratorSyntax AddNames(params IdentifierNameSyntax[] items) => WithNames(this.Names.AddRange(items));
    }

    public abstract partial class ConditionalLineDecoratorSyntax : LineDecoratorSyntax
    {
        internal ConditionalLineDecoratorSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public abstract ExpressionSyntax Condition { get; }
        public ConditionalLineDecoratorSyntax WithCondition(ExpressionSyntax condition) => WithConditionCore(condition);
        internal abstract ConditionalLineDecoratorSyntax WithConditionCore(ExpressionSyntax condition);
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.IfLineDecorator"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class IfLineDecoratorSyntax : ConditionalLineDecoratorSyntax
    {
        private ExpressionSyntax? condition;

        internal IfLineDecoratorSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken IfKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.IfLineDecoratorSyntax)this.Green).ifKeyword, Position, 0);

        public override ExpressionSyntax Condition => GetRed(ref this.condition, 1)!;

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.condition, 1)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.condition : null;

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitIfLineDecorator(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitIfLineDecorator(this);

        public IfLineDecoratorSyntax Update(SyntaxToken ifKeyword, ExpressionSyntax condition)
        {
            if (ifKeyword != this.IfKeyword || condition != this.Condition)
            {
                var newNode = SyntaxFactory.IfLineDecorator(ifKeyword, condition);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public IfLineDecoratorSyntax WithIfKeyword(SyntaxToken ifKeyword) => Update(ifKeyword, this.Condition);
        internal override ConditionalLineDecoratorSyntax WithConditionCore(ExpressionSyntax condition) => WithCondition(condition);
        public new IfLineDecoratorSyntax WithCondition(ExpressionSyntax condition) => Update(this.IfKeyword, condition);
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.UnlessLineDecorator"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class UnlessLineDecoratorSyntax : ConditionalLineDecoratorSyntax
    {
        private ExpressionSyntax? condition;

        internal UnlessLineDecoratorSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken UnlessKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.UnlessLineDecoratorSyntax)this.Green).unlessKeyword, Position, 0);

        public override ExpressionSyntax Condition => GetRed(ref this.condition, 1)!;

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.condition, 1)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.condition : null;

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitUnlessLineDecorator(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitUnlessLineDecorator(this);

        public UnlessLineDecoratorSyntax Update(SyntaxToken unlessKeyword, ExpressionSyntax condition)
        {
            if (unlessKeyword != this.UnlessKeyword || condition != this.Condition)
            {
                var newNode = SyntaxFactory.UnlessLineDecorator(unlessKeyword, condition);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public UnlessLineDecoratorSyntax WithUnlessKeyword(SyntaxToken unlessKeyword) => Update(unlessKeyword, this.Condition);
        internal override ConditionalLineDecoratorSyntax WithConditionCore(ExpressionSyntax condition) => WithCondition(condition);
        public new UnlessLineDecoratorSyntax WithCondition(ExpressionSyntax condition) => Update(this.UnlessKeyword, condition);
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.WhileLineDecorator"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class WhileLineDecoratorSyntax : LineDecoratorSyntax
    {
        private ExpressionSyntax? condition;

        internal WhileLineDecoratorSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken WhileKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.WhileLineDecoratorSyntax)this.Green).whileKeyword, Position, 0);

        public ExpressionSyntax Condition => GetRed(ref this.condition, 1)!;

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.condition, 1)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.condition : null;

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitWhileLineDecorator(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitWhileLineDecorator(this);

        public WhileLineDecoratorSyntax Update(SyntaxToken whileKeyword, ExpressionSyntax condition)
        {
            if (whileKeyword != this.WhileKeyword || condition != this.Condition)
            {
                var newNode = SyntaxFactory.WhileLineDecorator(whileKeyword, condition);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public WhileLineDecoratorSyntax WithWhileKeyword(SyntaxToken whileKeyword) => Update(whileKeyword, this.Condition);
        public WhileLineDecoratorSyntax WithCondition(ExpressionSyntax condition) => Update(this.WhileKeyword, condition);
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.Chunk"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ChunkSyntax : MoonScriptSyntaxNode
    {
        private BlockSyntax? block;

        internal ChunkSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public BlockSyntax Block => GetRedAtZero(ref this.block)!;

        public SyntaxToken EndOfFileToken => new SyntaxToken(this, ((Syntax.InternalSyntax.ChunkSyntax)this.Green).endOfFileToken, GetChildPosition(1), GetChildIndex(1));

        internal override SyntaxNode? GetNodeSlot(int index) => index == 0 ? GetRedAtZero(ref this.block)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 0 ? this.block : null;

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitChunk(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitChunk(this);

        public ChunkSyntax Update(BlockSyntax block, SyntaxToken endOfFileToken)
        {
            if (block != this.Block || endOfFileToken != this.EndOfFileToken)
            {
                var newNode = SyntaxFactory.Chunk(block, endOfFileToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ChunkSyntax WithBlock(BlockSyntax block) => Update(block, this.EndOfFileToken);
        public ChunkSyntax WithEndOfFileToken(SyntaxToken endOfFileToken) => Update(this.Block, endOfFileToken);

        public ChunkSyntax AddBlockStatements(params StatementSyntax[] items) => WithBlock(this.Block.WithStatements(this.Block.Statements.AddRange(items)));
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.Block"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class BlockSyntax : MoonScriptSyntaxNode
    {
        private SyntaxNode? statements;

        internal BlockSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxList<StatementSyntax> Statements => new SyntaxList<StatementSyntax>(GetRed(ref this.statements, 0));

        internal override SyntaxNode? GetNodeSlot(int index) => index == 0 ? GetRedAtZero(ref this.statements)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 0 ? this.statements : null;

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitBlock(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitBlock(this);

        public BlockSyntax Update(SyntaxList<StatementSyntax> statements)
        {
            if (statements != this.Statements)
            {
                var newNode = SyntaxFactory.Block(statements);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public BlockSyntax WithStatements(SyntaxList<StatementSyntax> statements) => Update(statements);

        public BlockSyntax AddStatements(params StatementSyntax[] items) => WithStatements(this.Statements.AddRange(items));
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.SkippedTokensTrivia"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class SkippedTokensTriviaSyntax : StructuredTriviaSyntax
    {

        internal SkippedTokensTriviaSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxTokenList Tokens
        {
            get
            {
                var slot = this.Green.GetSlot(0);
                return slot != null ? new SyntaxTokenList(this, slot, Position, 0) : default;
            }
        }

        internal override SyntaxNode? GetNodeSlot(int index) => null;

        internal override SyntaxNode? GetCachedSlot(int index) => null;

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitSkippedTokensTrivia(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitSkippedTokensTrivia(this);

        public SkippedTokensTriviaSyntax Update(SyntaxTokenList tokens)
        {
            if (tokens != this.Tokens)
            {
                var newNode = SyntaxFactory.SkippedTokensTrivia(tokens);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public SkippedTokensTriviaSyntax WithTokens(SyntaxTokenList tokens) => Update(tokens);

        public SkippedTokensTriviaSyntax AddTokens(params SyntaxToken[] items) => WithTokens(this.Tokens.AddRange(items));
    }

    /// <summary>Class which represents the syntax node for the list of expressions.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.ExpressionList"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ExpressionListSyntax : MoonScriptSyntaxNode
    {
        private SyntaxNode? expressions;

        internal ExpressionListSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>SeparatedSyntaxList of ExpressionSyntax nodes representing the list of expressions.</summary>
        public SeparatedSyntaxList<ExpressionSyntax> Expressions
        {
            get
            {
                var red = GetRed(ref this.expressions, 0);
                return red != null ? new SeparatedSyntaxList<ExpressionSyntax>(red, 0) : default;
            }
        }

        internal override SyntaxNode? GetNodeSlot(int index) => index == 0 ? GetRedAtZero(ref this.expressions)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 0 ? this.expressions : null;

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitExpressionList(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitExpressionList(this);

        public ExpressionListSyntax Update(SeparatedSyntaxList<ExpressionSyntax> expressions)
        {
            if (expressions != this.Expressions)
            {
                var newNode = SyntaxFactory.ExpressionList(expressions);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ExpressionListSyntax WithExpressions(SeparatedSyntaxList<ExpressionSyntax> expressions) => Update(expressions);

        public ExpressionListSyntax AddExpressions(params ExpressionSyntax[] items) => WithExpressions(this.Expressions.AddRange(items));
    }

    /// <summary>Parameter list syntax.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.ParameterList"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ParameterListSyntax : MoonScriptSyntaxNode
    {
        private SyntaxNode? parameters;
        private UsingClauseSyntax? @using;

        internal ParameterListSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>Gets the open paren token.</summary>
        public SyntaxToken OpenParenToken => new SyntaxToken(this, ((Syntax.InternalSyntax.ParameterListSyntax)this.Green).openParenToken, Position, 0);

        public SeparatedSyntaxList<ParameterSyntax> Parameters
        {
            get
            {
                var red = GetRed(ref this.parameters, 1);
                return red != null ? new SeparatedSyntaxList<ParameterSyntax>(red, GetChildIndex(1)) : default;
            }
        }

        public UsingClauseSyntax? Using => GetRed(ref this.@using, 2);

        /// <summary>Gets the close paren token.</summary>
        public SyntaxToken CloseParenToken => new SyntaxToken(this, ((Syntax.InternalSyntax.ParameterListSyntax)this.Green).closeParenToken, GetChildPosition(3), GetChildIndex(3));

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                1 => GetRed(ref this.parameters, 1)!,
                2 => GetRed(ref this.@using, 2),
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                1 => this.parameters,
                2 => this.@using,
                _ => null,
            };

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitParameterList(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitParameterList(this);

        public ParameterListSyntax Update(SyntaxToken openParenToken, SeparatedSyntaxList<ParameterSyntax> parameters, UsingClauseSyntax? @using, SyntaxToken closeParenToken)
        {
            if (openParenToken != this.OpenParenToken || parameters != this.Parameters || @using != this.Using || closeParenToken != this.CloseParenToken)
            {
                var newNode = SyntaxFactory.ParameterList(openParenToken, parameters, @using, closeParenToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ParameterListSyntax WithOpenParenToken(SyntaxToken openParenToken) => Update(openParenToken, this.Parameters, this.Using, this.CloseParenToken);
        public ParameterListSyntax WithParameters(SeparatedSyntaxList<ParameterSyntax> parameters) => Update(this.OpenParenToken, parameters, this.Using, this.CloseParenToken);
        public ParameterListSyntax WithUsing(UsingClauseSyntax? @using) => Update(this.OpenParenToken, this.Parameters, @using, this.CloseParenToken);
        public ParameterListSyntax WithCloseParenToken(SyntaxToken closeParenToken) => Update(this.OpenParenToken, this.Parameters, this.Using, closeParenToken);

        public ParameterListSyntax AddParameters(params ParameterSyntax[] items) => WithParameters(this.Parameters.AddRange(items));
        public ParameterListSyntax AddUsingNames(params IdentifierNameSyntax[] items)
        {
            var @using = this.Using ?? SyntaxFactory.UsingClause();
            return WithUsing(@using.WithNames(@using.Names.AddRange(items)));
        }
    }

    /// <summary>Parameter syntax.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.Parameter"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ParameterSyntax : MoonScriptSyntaxNode
    {
        private ExpressionSyntax? defaultValue;

        internal ParameterSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>Gets the identifier.</summary>
        public SyntaxToken Identifier => new SyntaxToken(this, ((Syntax.InternalSyntax.ParameterSyntax)this.Green).identifier, Position, 0);

        public SyntaxToken EqualsToken => new SyntaxToken(this, ((Syntax.InternalSyntax.ParameterSyntax)this.Green).equalsToken, GetChildPosition(1), GetChildIndex(1));

        public ExpressionSyntax DefaultValue => GetRed(ref this.defaultValue, 2)!;

        internal override SyntaxNode? GetNodeSlot(int index) => index == 2 ? GetRed(ref this.defaultValue, 2)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 2 ? this.defaultValue : null;

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitParameter(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitParameter(this);

        public ParameterSyntax Update(SyntaxToken identifier, SyntaxToken equalsToken, ExpressionSyntax defaultValue)
        {
            if (identifier != this.Identifier || equalsToken != this.EqualsToken || defaultValue != this.DefaultValue)
            {
                var newNode = SyntaxFactory.Parameter(identifier, equalsToken, defaultValue);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ParameterSyntax WithIdentifier(SyntaxToken identifier) => Update(identifier, this.EqualsToken, this.DefaultValue);
        public ParameterSyntax WithEqualsToken(SyntaxToken equalsToken) => Update(this.Identifier, equalsToken, this.DefaultValue);
        public ParameterSyntax WithDefaultValue(ExpressionSyntax defaultValue) => Update(this.Identifier, this.EqualsToken, defaultValue);
    }

    /// <summary>Class which represents the syntax node for the list of arguments.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.ArgumentList"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ArgumentListSyntax : MoonScriptSyntaxNode
    {
        private SyntaxNode? arguments;

        internal ArgumentListSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken ExclamationToken
        {
            get
            {
                var slot = ((Syntax.InternalSyntax.ArgumentListSyntax)this.Green).exclamationToken;
                return slot != null ? new SyntaxToken(this, slot, Position, 0) : default;
            }
        }

        /// <summary>SyntaxToken representing open parenthesis.</summary>
        public SyntaxToken OpenParenToken
        {
            get
            {
                var slot = ((Syntax.InternalSyntax.ArgumentListSyntax)this.Green).openParenToken;
                return slot != null ? new SyntaxToken(this, slot, GetChildPosition(1), GetChildIndex(1)) : default;
            }
        }

        /// <summary>SeparatedSyntaxList of ArgumentSyntax representing the list of arguments.</summary>
        public SeparatedSyntaxList<ArgumentSyntax> Arguments
        {
            get
            {
                var red = GetRed(ref this.arguments, 2);
                return red != null ? new SeparatedSyntaxList<ArgumentSyntax>(red, GetChildIndex(2)) : default;
            }
        }

        /// <summary>SyntaxToken representing close parenthesis.</summary>
        public SyntaxToken CloseParenToken
        {
            get
            {
                var slot = ((Syntax.InternalSyntax.ArgumentListSyntax)this.Green).closeParenToken;
                return slot != null ? new SyntaxToken(this, slot, GetChildPosition(3), GetChildIndex(3)) : default;
            }
        }

        internal override SyntaxNode? GetNodeSlot(int index) => index == 2 ? GetRed(ref this.arguments, 2)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 2 ? this.arguments : null;

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitArgumentList(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitArgumentList(this);

        public ArgumentListSyntax Update(SyntaxToken exclamationToken, SyntaxToken openParenToken, SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeParenToken)
        {
            if (exclamationToken != this.ExclamationToken || openParenToken != this.OpenParenToken || arguments != this.Arguments || closeParenToken != this.CloseParenToken)
            {
                var newNode = SyntaxFactory.ArgumentList(exclamationToken, openParenToken, arguments, closeParenToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ArgumentListSyntax WithExclamationToken(SyntaxToken exclamationToken) => Update(exclamationToken, this.OpenParenToken, this.Arguments, this.CloseParenToken);
        public ArgumentListSyntax WithOpenParenToken(SyntaxToken openParenToken) => Update(this.ExclamationToken, openParenToken, this.Arguments, this.CloseParenToken);
        public ArgumentListSyntax WithArguments(SeparatedSyntaxList<ArgumentSyntax> arguments) => Update(this.ExclamationToken, this.OpenParenToken, arguments, this.CloseParenToken);
        public ArgumentListSyntax WithCloseParenToken(SyntaxToken closeParenToken) => Update(this.ExclamationToken, this.OpenParenToken, this.Arguments, closeParenToken);

        public ArgumentListSyntax AddArguments(params ArgumentSyntax[] items) => WithArguments(this.Arguments.AddRange(items));
    }

    /// <summary>Class which represents the syntax node for argument.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.Argument"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ArgumentSyntax : MoonScriptSyntaxNode
    {
        private ExpressionSyntax? expression;

        internal ArgumentSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>ExpressionSyntax node representing the argument.</summary>
        public ExpressionSyntax Expression => GetRedAtZero(ref this.expression)!;

        internal override SyntaxNode? GetNodeSlot(int index) => index == 0 ? GetRedAtZero(ref this.expression)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 0 ? this.expression : null;

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitArgument(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitArgument(this);

        public ArgumentSyntax Update(ExpressionSyntax expression)
        {
            if (expression != this.Expression)
            {
                var newNode = SyntaxFactory.Argument(expression);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ArgumentSyntax WithExpression(ExpressionSyntax expression) => Update(expression);
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.NameColon"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class NameColonSyntax : MoonScriptSyntaxNode
    {
        private IdentifierNameSyntax? name;

        internal NameColonSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public IdentifierNameSyntax Name => GetRedAtZero(ref this.name)!;

        public SyntaxToken ColonToken => new SyntaxToken(this, ((Syntax.InternalSyntax.NameColonSyntax)this.Green).colonToken, GetChildPosition(1), GetChildIndex(1));

        internal override SyntaxNode? GetNodeSlot(int index) => index == 0 ? GetRedAtZero(ref this.name)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 0 ? this.name : null;

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitNameColon(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitNameColon(this);

        public NameColonSyntax Update(IdentifierNameSyntax name, SyntaxToken colonToken)
        {
            if (name != this.Name || colonToken != this.ColonToken)
            {
                var newNode = SyntaxFactory.NameColon(name, colonToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public NameColonSyntax WithName(IdentifierNameSyntax name) => Update(name, this.ColonToken);
        public NameColonSyntax WithColonToken(SyntaxToken colonToken) => Update(this.Name, colonToken);
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.ColonName"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ColonNameSyntax : MoonScriptSyntaxNode
    {
        private IdentifierNameSyntax? name;

        internal ColonNameSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken ColonToken => new SyntaxToken(this, ((Syntax.InternalSyntax.ColonNameSyntax)this.Green).colonToken, Position, 0);

        public IdentifierNameSyntax Name => GetRed(ref this.name, 1)!;

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.name, 1)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.name : null;

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitColonName(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitColonName(this);

        public ColonNameSyntax Update(SyntaxToken colonToken, IdentifierNameSyntax name)
        {
            if (colonToken != this.ColonToken || name != this.Name)
            {
                var newNode = SyntaxFactory.ColonName(colonToken, name);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ColonNameSyntax WithColonToken(SyntaxToken colonToken) => Update(colonToken, this.Name);
        public ColonNameSyntax WithName(IdentifierNameSyntax name) => Update(this.ColonToken, name);
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.BackSlashName"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class BackSlashNameSyntax : MoonScriptSyntaxNode
    {
        private IdentifierNameSyntax? name;

        internal BackSlashNameSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken BackSlashToken => new SyntaxToken(this, ((Syntax.InternalSyntax.BackSlashNameSyntax)this.Green).backSlashToken, Position, 0);

        public IdentifierNameSyntax Name => GetRed(ref this.name, 1)!;

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.name, 1)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.name : null;

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitBackSlashName(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitBackSlashName(this);

        public BackSlashNameSyntax Update(SyntaxToken backSlashToken, IdentifierNameSyntax name)
        {
            if (backSlashToken != this.BackSlashToken || name != this.Name)
            {
                var newNode = SyntaxFactory.BackSlashName(backSlashToken, name);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public BackSlashNameSyntax WithBackSlashToken(SyntaxToken backSlashToken) => Update(backSlashToken, this.Name);
        public BackSlashNameSyntax WithName(IdentifierNameSyntax name) => Update(this.BackSlashToken, name);
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.ImplicitSelfCall"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ImplicitSelfCallSyntax : MoonScriptSyntaxNode
    {
        private ExpressionSyntax? expression;
        private BackSlashNameSyntax? backSlashName;

        internal ImplicitSelfCallSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>ExpressionSyntax node representing the expression part of the implicit self call.</summary>
        public ExpressionSyntax Expression => GetRedAtZero(ref this.expression)!;

        /// <summary>IdentifierNameSyntax representing the identifier name.</summary>
        public BackSlashNameSyntax BackSlashName => GetRed(ref this.backSlashName, 1)!;

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                0 => GetRedAtZero(ref this.expression)!,
                1 => GetRed(ref this.backSlashName, 1)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                0 => this.expression,
                1 => this.backSlashName,
                _ => null,
            };

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitImplicitSelfCall(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitImplicitSelfCall(this);

        public ImplicitSelfCallSyntax Update(ExpressionSyntax expression, BackSlashNameSyntax backSlashName)
        {
            if (expression != this.Expression || backSlashName != this.BackSlashName)
            {
                var newNode = SyntaxFactory.ImplicitSelfCall(expression, backSlashName);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ImplicitSelfCallSyntax WithExpression(ExpressionSyntax expression) => Update(expression, this.BackSlashName);
        public ImplicitSelfCallSyntax WithBackSlashName(BackSlashNameSyntax backSlashName) => Update(this.Expression, backSlashName);
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.ImportName"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ImportNameSyntax : MoonScriptSyntaxNode
    {
        private IdentifierNameSyntax? name;

        internal ImportNameSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken BackSlashToken
        {
            get
            {
                var slot = ((Syntax.InternalSyntax.ImportNameSyntax)this.Green).backSlashToken;
                return slot != null ? new SyntaxToken(this, slot, Position, 0) : default;
            }
        }

        public IdentifierNameSyntax Name => GetRed(ref this.name, 1)!;

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.name, 1)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.name : null;

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitImportName(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitImportName(this);

        public ImportNameSyntax Update(SyntaxToken backSlashToken, IdentifierNameSyntax name)
        {
            if (backSlashToken != this.BackSlashToken || name != this.Name)
            {
                var newNode = SyntaxFactory.ImportName(backSlashToken, name);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ImportNameSyntax WithBackSlashToken(SyntaxToken backSlashToken) => Update(backSlashToken, this.Name);
        public ImportNameSyntax WithName(IdentifierNameSyntax name) => Update(this.BackSlashToken, name);
    }
}
