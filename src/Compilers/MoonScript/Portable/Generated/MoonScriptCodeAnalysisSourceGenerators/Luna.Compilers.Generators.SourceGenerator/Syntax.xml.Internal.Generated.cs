// <auto-generated />

#nullable enable

using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Syntax.InternalSyntax;
using SamLu.CodeAnalysis.MoonScript;
using Roslyn.Utilities;

namespace SamLu.CodeAnalysis.MoonScript.Syntax.InternalSyntax
{


    /// <summary>提供表示名称语法节点继承用的父类，此类必须被继承。</summary>
    internal abstract partial class NameSyntax : MoonScriptSyntaxNode
    {
        internal NameSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal NameSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected NameSyntax(ObjectReader reader)
          : base(reader)
        {
        }
    }

    /// <summary>提供表示简单名称语法节点继承用的父类，此类必须被继承。</summary>
    internal abstract partial class SimpleNameSyntax : NameSyntax
    {
        internal SimpleNameSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal SimpleNameSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected SimpleNameSyntax(ObjectReader reader)
          : base(reader)
        {
        }

        /// <summary>表示简单名称的语法标志。</summary>
        public abstract SyntaxToken Identifier { get; }
    }

    /// <summary>Provides the base class from which the classes that represent expression syntax nodes are derived. This is an abstract class.</summary>
    internal abstract partial class ExpressionSyntax : MoonScriptSyntaxNode
    {
        internal ExpressionSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal ExpressionSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected ExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
        }
    }

    /// <summary>Provides the base class from which the classes that represent statement syntax nodes are derived. This is an abstract class.</summary>
    internal abstract partial class StatementSyntax : MoonScriptSyntaxNode
    {
        internal StatementSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal StatementSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected StatementSyntax(ObjectReader reader)
          : base(reader)
        {
        }
    }

    internal sealed partial class ChunkSyntax : MoonScriptSyntaxNode
    {
        internal readonly BlockSyntax block;
        internal readonly SyntaxToken endOfFileToken;

        internal ChunkSyntax(SyntaxKind kind, BlockSyntax block, SyntaxToken endOfFileToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(block);
            this.block = block;
            this.AdjustFlagsAndWidth(endOfFileToken);
            this.endOfFileToken = endOfFileToken;
        }

        internal ChunkSyntax(SyntaxKind kind, BlockSyntax block, SyntaxToken endOfFileToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(block);
            this.block = block;
            this.AdjustFlagsAndWidth(endOfFileToken);
            this.endOfFileToken = endOfFileToken;
        }

        internal ChunkSyntax(SyntaxKind kind, BlockSyntax block, SyntaxToken endOfFileToken)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(block);
            this.block = block;
            this.AdjustFlagsAndWidth(endOfFileToken);
            this.endOfFileToken = endOfFileToken;
        }

        public BlockSyntax Block => this.block;
        public SyntaxToken EndOfFileToken => this.endOfFileToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.block,
                1 => this.endOfFileToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.ChunkSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitChunk(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitChunk(this);

        public ChunkSyntax Update(BlockSyntax block, SyntaxToken endOfFileToken)
        {
            if (block != this.Block || endOfFileToken != this.EndOfFileToken)
            {
                var newNode = SyntaxFactory.Chunk(block, endOfFileToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ChunkSyntax(this.Kind, this.block, this.endOfFileToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ChunkSyntax(this.Kind, this.block, this.endOfFileToken, GetDiagnostics(), annotations);

        internal ChunkSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var block = (BlockSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(block);
            this.block = block;
            var endOfFileToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(endOfFileToken);
            this.endOfFileToken = endOfFileToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.block);
            writer.WriteValue(this.endOfFileToken);
        }

        static ChunkSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ChunkSyntax), r => new ChunkSyntax(r));
        }
    }

    internal sealed partial class BlockSyntax : MoonScriptSyntaxNode
    {
        internal readonly GreenNode? statements;

        internal BlockSyntax(SyntaxKind kind, GreenNode? statements, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 1;
            if (statements != null)
            {
                this.AdjustFlagsAndWidth(statements);
                this.statements = statements;
            }
        }

        internal BlockSyntax(SyntaxKind kind, GreenNode? statements, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 1;
            if (statements != null)
            {
                this.AdjustFlagsAndWidth(statements);
                this.statements = statements;
            }
        }

        internal BlockSyntax(SyntaxKind kind, GreenNode? statements)
          : base(kind)
        {
            this.SlotCount = 1;
            if (statements != null)
            {
                this.AdjustFlagsAndWidth(statements);
                this.statements = statements;
            }
        }

        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<StatementSyntax> Statements => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<StatementSyntax>(this.statements);

        internal override GreenNode? GetSlot(int index)
            => index == 0 ? this.statements : null;

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.BlockSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitBlock(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitBlock(this);

        public BlockSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<StatementSyntax> statements)
        {
            if (statements != this.Statements)
            {
                var newNode = SyntaxFactory.Block(statements);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new BlockSyntax(this.Kind, this.statements, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new BlockSyntax(this.Kind, this.statements, GetDiagnostics(), annotations);

        internal BlockSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 1;
            var statements = (GreenNode?)reader.ReadValue();
            if (statements != null)
            {
                AdjustFlagsAndWidth(statements);
                this.statements = statements;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.statements);
        }

        static BlockSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(BlockSyntax), r => new BlockSyntax(r));
        }
    }

    internal sealed partial class SkippedTokensTriviaSyntax : StructuredTriviaSyntax
    {
        internal readonly GreenNode? tokens;

        internal SkippedTokensTriviaSyntax(SyntaxKind kind, GreenNode? tokens, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 1;
            if (tokens != null)
            {
                this.AdjustFlagsAndWidth(tokens);
                this.tokens = tokens;
            }
        }

        internal SkippedTokensTriviaSyntax(SyntaxKind kind, GreenNode? tokens, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 1;
            if (tokens != null)
            {
                this.AdjustFlagsAndWidth(tokens);
                this.tokens = tokens;
            }
        }

        internal SkippedTokensTriviaSyntax(SyntaxKind kind, GreenNode? tokens)
          : base(kind)
        {
            this.SlotCount = 1;
            if (tokens != null)
            {
                this.AdjustFlagsAndWidth(tokens);
                this.tokens = tokens;
            }
        }

        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Tokens => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.tokens);

        internal override GreenNode? GetSlot(int index)
            => index == 0 ? this.tokens : null;

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new MoonScript.Syntax.SkippedTokensTriviaSyntax(this, parent as MoonScript.MoonScriptSyntaxNode, position);

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitSkippedTokensTrivia(this);
        public override TResult Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) => visitor.VisitSkippedTokensTrivia(this);

        public SkippedTokensTriviaSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> tokens)
        {
            if (tokens != this.Tokens)
            {
                var newNode = SyntaxFactory.SkippedTokensTrivia(tokens);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new SkippedTokensTriviaSyntax(this.Kind, this.tokens, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new SkippedTokensTriviaSyntax(this.Kind, this.tokens, GetDiagnostics(), annotations);

        internal SkippedTokensTriviaSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 1;
            var tokens = (GreenNode?)reader.ReadValue();
            if (tokens != null)
            {
                AdjustFlagsAndWidth(tokens);
                this.tokens = tokens;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.tokens);
        }

        static SkippedTokensTriviaSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(SkippedTokensTriviaSyntax), r => new SkippedTokensTriviaSyntax(r));
        }
    }

    internal partial class MoonScriptSyntaxVisitor<TResult>
    {
        public virtual TResult VisitChunk(ChunkSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitBlock(BlockSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitSkippedTokensTrivia(SkippedTokensTriviaSyntax node) => this.DefaultVisit(node);
    }

    internal partial class MoonScriptSyntaxVisitor
    {
        public virtual void VisitChunk(ChunkSyntax node) => this.DefaultVisit(node);
        public virtual void VisitBlock(BlockSyntax node) => this.DefaultVisit(node);
        public virtual void VisitSkippedTokensTrivia(SkippedTokensTriviaSyntax node) => this.DefaultVisit(node);
    }

    internal partial class MoonScriptSyntaxRewriter : MoonScriptSyntaxVisitor<MoonScriptSyntaxNode>
    {
        public override MoonScriptSyntaxNode VisitChunk(ChunkSyntax node)
            => node.Update((BlockSyntax)Visit(node.Block), (SyntaxToken)Visit(node.EndOfFileToken));

        public override MoonScriptSyntaxNode VisitBlock(BlockSyntax node)
            => node.Update(VisitList(node.Statements));

        public override MoonScriptSyntaxNode VisitSkippedTokensTrivia(SkippedTokensTriviaSyntax node)
            => node.Update(VisitList(node.Tokens));
    }

    internal partial class ContextAwareSyntax
    {

        private SyntaxFactoryContext context;

        public ContextAwareSyntax(SyntaxFactoryContext context)
            => this.context = context;

        public ChunkSyntax Chunk(BlockSyntax block, SyntaxToken endOfFileToken)
        {
#if DEBUG
            if (block == null) throw new ArgumentNullException(nameof(block));
            if (endOfFileToken == null) throw new ArgumentNullException(nameof(endOfFileToken));
            if (endOfFileToken.Kind != SyntaxKind.EndOfFileToken) throw new ArgumentException(nameof(endOfFileToken));
#endif

            int hash;
            var cached = MoonScriptSyntaxNodeCache.TryGetNode((int)SyntaxKind.Chunk, block, endOfFileToken, this.context, out hash);
            if (cached != null) return (ChunkSyntax)cached;

            var result = new ChunkSyntax(SyntaxKind.Chunk, block, endOfFileToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public BlockSyntax Block(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<StatementSyntax> statements)
        {
#if DEBUG
#endif

            int hash;
            var cached = MoonScriptSyntaxNodeCache.TryGetNode((int)SyntaxKind.Block, statements.Node, this.context, out hash);
            if (cached != null) return (BlockSyntax)cached;

            var result = new BlockSyntax(SyntaxKind.Block, statements.Node, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public SkippedTokensTriviaSyntax SkippedTokensTrivia(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> tokens)
        {
#if DEBUG
#endif

            return new SkippedTokensTriviaSyntax(SyntaxKind.SkippedTokensTrivia, tokens.Node, this.context);
        }
    }

    internal static partial class SyntaxFactory
    {

        public static ChunkSyntax Chunk(BlockSyntax block, SyntaxToken endOfFileToken)
        {
#if DEBUG
            if (block == null) throw new ArgumentNullException(nameof(block));
            if (endOfFileToken == null) throw new ArgumentNullException(nameof(endOfFileToken));
            if (endOfFileToken.Kind != SyntaxKind.EndOfFileToken) throw new ArgumentException(nameof(endOfFileToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.Chunk, block, endOfFileToken, out hash);
            if (cached != null) return (ChunkSyntax)cached;

            var result = new ChunkSyntax(SyntaxKind.Chunk, block, endOfFileToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static BlockSyntax Block(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<StatementSyntax> statements)
        {
#if DEBUG
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.Block, statements.Node, out hash);
            if (cached != null) return (BlockSyntax)cached;

            var result = new BlockSyntax(SyntaxKind.Block, statements.Node);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static SkippedTokensTriviaSyntax SkippedTokensTrivia(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> tokens)
        {
#if DEBUG
#endif

            return new SkippedTokensTriviaSyntax(SyntaxKind.SkippedTokensTrivia, tokens.Node);
        }

        internal static IEnumerable<Type> GetNodeTypes()
            => new Type[]
            {
                typeof(ChunkSyntax),
                typeof(BlockSyntax),
                typeof(SkippedTokensTriviaSyntax),
            };
    }
}
