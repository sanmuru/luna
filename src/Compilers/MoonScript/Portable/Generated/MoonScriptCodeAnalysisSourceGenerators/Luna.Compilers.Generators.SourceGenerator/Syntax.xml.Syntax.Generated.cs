// <auto-generated />

#nullable enable

using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Syntax.InternalSyntax;
using SamLu.CodeAnalysis.MoonScript;
using Roslyn.Utilities;

namespace SamLu.CodeAnalysis.MoonScript.Syntax
{
    using Microsoft.CodeAnalysis;

    /// <summary>提供表示名称语法节点继承用的父类，此类必须被继承。</summary>
    public abstract partial class NameSyntax : MoonScriptSyntaxNode
    {
        internal NameSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }
    }

    /// <summary>提供表示简单名称语法节点继承用的父类，此类必须被继承。</summary>
    public abstract partial class SimpleNameSyntax : NameSyntax
    {
        internal SimpleNameSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>表示简单名称的语法标志。</summary>
        public abstract SyntaxToken Identifier { get; }
        public SimpleNameSyntax WithIdentifier(SyntaxToken identifier) => WithIdentifierCore(identifier);
        internal abstract SimpleNameSyntax WithIdentifierCore(SyntaxToken identifier);
    }

    /// <summary>Provides the base class from which the classes that represent expression syntax nodes are derived. This is an abstract class.</summary>
    public abstract partial class ExpressionSyntax : MoonScriptSyntaxNode
    {
        internal ExpressionSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }
    }

    /// <summary>Provides the base class from which the classes that represent statement syntax nodes are derived. This is an abstract class.</summary>
    public abstract partial class StatementSyntax : MoonScriptSyntaxNode
    {
        internal StatementSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.Chunk"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ChunkSyntax : MoonScriptSyntaxNode
    {
        private BlockSyntax? block;

        internal ChunkSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public BlockSyntax Block => GetRedAtZero(ref this.block)!;

        public SyntaxToken EndOfFileToken => new SyntaxToken(this, ((Syntax.InternalSyntax.ChunkSyntax)this.Green).endOfFileToken, GetChildPosition(1), GetChildIndex(1));

        internal override SyntaxNode? GetNodeSlot(int index) => index == 0 ? GetRedAtZero(ref this.block)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 0 ? this.block : null;

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitChunk(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitChunk(this);

        public ChunkSyntax Update(BlockSyntax block, SyntaxToken endOfFileToken)
        {
            if (block != this.Block || endOfFileToken != this.EndOfFileToken)
            {
                var newNode = SyntaxFactory.Chunk(block, endOfFileToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ChunkSyntax WithBlock(BlockSyntax block) => Update(block, this.EndOfFileToken);
        public ChunkSyntax WithEndOfFileToken(SyntaxToken endOfFileToken) => Update(this.Block, endOfFileToken);

        public ChunkSyntax AddBlockStatements(params StatementSyntax[] items) => WithBlock(this.Block.WithStatements(this.Block.Statements.AddRange(items)));
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.Block"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class BlockSyntax : MoonScriptSyntaxNode
    {
        private SyntaxNode? statements;

        internal BlockSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxList<StatementSyntax> Statements => new SyntaxList<StatementSyntax>(GetRed(ref this.statements, 0));

        internal override SyntaxNode? GetNodeSlot(int index) => index == 0 ? GetRedAtZero(ref this.statements)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 0 ? this.statements : null;

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitBlock(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitBlock(this);

        public BlockSyntax Update(SyntaxList<StatementSyntax> statements)
        {
            if (statements != this.Statements)
            {
                var newNode = SyntaxFactory.Block(statements);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public BlockSyntax WithStatements(SyntaxList<StatementSyntax> statements) => Update(statements);

        public BlockSyntax AddStatements(params StatementSyntax[] items) => WithStatements(this.Statements.AddRange(items));
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.SkippedTokensTrivia"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class SkippedTokensTriviaSyntax : StructuredTriviaSyntax
    {

        internal SkippedTokensTriviaSyntax(InternalSyntax.MoonScriptSyntaxNode green, MoonScriptSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxTokenList Tokens
        {
            get
            {
                var slot = this.Green.GetSlot(0);
                return slot != null ? new SyntaxTokenList(this, slot, Position, 0) : default;
            }
        }

        internal override SyntaxNode? GetNodeSlot(int index) => null;

        internal override SyntaxNode? GetCachedSlot(int index) => null;

        public override void Accept(MoonScriptSyntaxVisitor visitor) => visitor.VisitSkippedTokensTrivia(this);
        public override TResult? Accept<TResult>(MoonScriptSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitSkippedTokensTrivia(this);

        public SkippedTokensTriviaSyntax Update(SyntaxTokenList tokens)
        {
            if (tokens != this.Tokens)
            {
                var newNode = SyntaxFactory.SkippedTokensTrivia(tokens);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public SkippedTokensTriviaSyntax WithTokens(SyntaxTokenList tokens) => Update(tokens);

        public SkippedTokensTriviaSyntax AddTokens(params SyntaxToken[] items) => WithTokens(this.Tokens.AddRange(items));
    }
}
