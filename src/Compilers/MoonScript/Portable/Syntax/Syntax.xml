<?xml version="1.0" encoding="utf-8"?>
<Tree Root="SyntaxNode">

  <PredefinedNode Name="MoonScriptSyntaxNode" Base="SyntaxNode"/>
  <PredefinedNode Name="SyntaxToken" Base="MoonScriptSyntaxNode"/>
  <PredefinedNode Name="StructuredTriviaSyntax" Base="MoonScriptSyntaxNode"/>



  <!-- 名称 -->
  <AbstractNode Name="NameSyntax" Base="MoonScriptSyntaxNode">
    <TypeComment>
      <summary>提供表示名称语法节点继承用的父类，此类必须被继承。</summary>
    </TypeComment>
  </AbstractNode>
  <AbstractNode Name="SimpleNameSyntax" Base="NameSyntax">
    <Field Name="Identifier" Type="SyntaxToken">
      <PropertyComment>
        <summary>表示简单名称的语法标志。</summary>
      </PropertyComment>
      <Kind Name="IdentifierToken" />
    </Field>
    <TypeComment>
      <summary>提供表示简单名称语法节点继承用的父类，此类必须被继承。</summary>
    </TypeComment>
  </AbstractNode>
  <Node Name="IdentifierNameSyntax" Base="SimpleNameSyntax">
    <Kind Name="IdentifierName"/>
    <Field Name="Identifier" Type="SyntaxToken" Override="true">
      <Kind Name="IdentifierToken"/>
      <Kind Name="GlobalEnvironmentKeyword"/>
      <Kind Name="EnvironmentKeyword"/>
      <PropertyComment>
        <summary>SyntaxToken representing the keyword for the kind of the identifier name.</summary>
      </PropertyComment>
    </Field>
    <TypeComment>
      <summary>Class which represents the syntax node for identifier name.</summary>
    </TypeComment>
    <FactoryComment>
      <summary>Creates an IdentifierNameSyntax node.</summary>
    </FactoryComment>
  </Node>



  <!-- 语句 -->
  <AbstractNode Name="ExpressionSyntax" Base="MoonScriptSyntaxNode">
    <TypeComment>
      <summary>Provides the base class from which the classes that represent expression syntax nodes are derived. This is an abstract class.</summary>
    </TypeComment>
  </AbstractNode>
  <Node Name="LiteralExpressionSyntax" Base="ExpressionSyntax">
    <Kind Name="NilLiteralExpression"/>
    <Kind Name="FalseLiteralExpression"/>
    <Kind Name="TrueLiteralExpression"/>
    <Kind Name="NumericLiteralExpression"/>
    <Kind Name="StringLiteralExpression"/>
    <Kind Name="VariousArgumentsExpression"/>
    <Field Name="Token" Type="SyntaxToken">
      <Kind Name="NilKeyword"/>
      <Kind Name="FalseKeyword"/>
      <Kind Name="TrueKeyword"/>
      <Kind Name="NumericLiteralToken"/>
      <Kind Name="StringLiteralToken"/>
      <Kind Name="MultiLineRawStringLiteralToken"/>
      <Kind Name="DotDotDotToken"/>
      <PropertyComment>
        <summary>SyntaxToken representing the keyword corresponding to the kind of the literal expression.</summary>
      </PropertyComment>
    </Field>
    <TypeComment>
      <summary>Class which represents the syntax node for a literal expression.</summary>
    </TypeComment>
    <FactoryComment>
      <summary>Creates a LiteralExpressionSyntax node.</summary>
    </FactoryComment>
  </Node>
  <AbstractNode Name="BaseInstanceExpressionSyntax" Base="ExpressionSyntax">
    <Field Name="Token" Type="SyntaxToken"/>
  </AbstractNode>
  <Node Name="SelfExpressionSyntax" Base="BaseInstanceExpressionSyntax">
    <Kind Name="SelfExpression"/>
    <Field Name="Token" Type="SyntaxToken" Override="true">
      <Kind Name="CommercialAtToken"/>
    </Field>
  </Node>
  <Node Name="SuperExpressionSyntax" Base="BaseInstanceExpressionSyntax">
    <Kind Name="SuperExpression"/>
    <Field Name="Token" Type="SyntaxToken" Override="true">
      <Kind Name="SuperKeyword"/>
    </Field>
  </Node>
  <Node Name="TypeExpressionSyntax" Base="BaseInstanceExpressionSyntax">
    <Kind Name="TypeExpression"/>
    <Field Name="Token" Type="SyntaxToken" Override="true">
      <Kind Name="CommercialAtCommercialAtToken"/>
    </Field>
  </Node>
  <Node Name="ParenthesizedExpressionSyntax" Base="ExpressionSyntax">
    <Kind Name="ParenthesizedExpression"/>
    <Field Name="OpenParenToken" Type="SyntaxToken">
      <Kind Name="OpenParenToken"/>
      <PropertyComment>
        <summary>SyntaxToken representing the open parenthesis.</summary>
      </PropertyComment>
    </Field>
    <Field Name="Expression" Type="ExpressionSyntax">
      <PropertyComment>
        <summary>ExpressionSyntax node representing the expression enclosed within the parenthesis.</summary>
      </PropertyComment>
    </Field>
    <Field Name="CloseParenToken" Type="SyntaxToken">
      <Kind Name="CloseParenToken"/>
      <PropertyComment>
        <summary>SyntaxToken representing the close parenthesis.</summary>
      </PropertyComment>
    </Field>
    <TypeComment>
      <summary>Class which represents the syntax node for parenthesized expression.</summary>
    </TypeComment>
    <FactoryComment>
      <summary>Creates a ParenthesizedExpressionSyntax node.</summary>
    </FactoryComment>
  </Node>
  <AbstractNode Name="BaseClassExpressionSyntax" Base="ExpressionSyntax">
    <Field Name="ClassKeyword" Type="SyntaxToken">
      <Kind Name="ClassKeyword"/>
    </Field>
    <Field Name="Name" Type="IdentifierNameSyntax"/>
    <Sequence Optional="true">
      <Field Name="ExtendsKeyword" Type="SyntaxToken">
        <Kind Name="ExtendsKeyword"/>
      </Field>
      <Field Name="BaseName" Type="IdentifierNameSyntax"/>
    </Sequence>
  </AbstractNode>
  <Node Name="ClassExpressionSyntax" Base="BaseClassExpressionSyntax">
    <Kind Name="ClassExpression"/>
    <Field Name="ClassKeyword" Type="SyntaxToken" Override="true">
      <Kind Name="ClassKeyword"/>
    </Field>
    <Field Name="Name" Type="IdentifierNameSyntax" Override="true"/>
    <Sequence Optional="true">
      <Field Name="ExtendsKeyword" Type="SyntaxToken" Override="true">
        <Kind Name="ExtendsKeyword"/>
      </Field>
      <Field Name="BaseName" Type="IdentifierNameSyntax" Override="true"/>
    </Sequence>
  </Node>
  <Node Name="AnomymousClassExpressionSyntax" Base="BaseClassExpressionSyntax">
    <Kind Name="AnomymousClassExpression"/>
    <Field Name="ClassKeyword" Type="SyntaxToken" Override="true">
      <Kind Name="ClassKeyword"/>
    </Field>
    <Sequence Optional="true">
      <Field Name="ExtendsKeyword" Type="SyntaxToken" Override="true">
        <Kind Name="ExtendsKeyword"/>
      </Field>
      <Field Name="BaseName" Type="IdentifierNameSyntax" Override="true"/>
    </Sequence>
  </Node>
  <Node Name="DoExpressionSyntax" Base="ExpressionSyntax">
    <Kind Name="DoExpression"/>
    <Field Name="DoKeyword" Type="SyntaxToken">
      <Kind Name="DoKeyword"/>
    </Field>
    <Field Name="Block" Type="BlockSyntax"/>
  </Node>



  <!-- 语句 -->
  <AbstractNode Name="StatementSyntax" Base="MoonScriptSyntaxNode">
    <TypeComment>
      <summary>Provides the base class from which the classes that represent statement syntax nodes are derived. This is an abstract class.</summary>
    </TypeComment>
  </AbstractNode>



  <!-- 声明 -->
  <Node Name="ChunkSyntax" Base="MoonScriptSyntaxNode">
    <Kind Name="Chunk"/>
    <Field Name="Block" Type="BlockSyntax"/>
    <Field Name="EndOfFileToken" Type="SyntaxToken">
      <Kind Name="EndOfFileToken"/>
    </Field>
  </Node>
  <Node Name="BlockSyntax" Base="MoonScriptSyntaxNode">
    <Kind Name="Block"/>
    <Field Name="Statements" Type="SyntaxList&lt;StatementSyntax&gt;"/>
  </Node>
  <Node Name="SkippedTokensTriviaSyntax" Base="StructuredTriviaSyntax">
    <Kind Name="SkippedTokensTrivia"/>
    <Field Name="Tokens" Type="SyntaxList&lt;SyntaxToken&gt;"/>
  </Node>
  <Node Name="ExpressionListSyntax" Base="LuaSyntaxNode">
    <Kind Name="ExpressionList"/>
    <Field Name="Expressions" Type="SeparatedSyntaxList&lt;ExpressionSyntax&gt;">
      <PropertyComment>
        <summary>SeparatedSyntaxList of ExpressionSyntax nodes representing the list of expressions.</summary>
      </PropertyComment>
    </Field>
    <TypeComment>
      <summary>Class which represents the syntax node for the list of expressions.</summary>
    </TypeComment>
    <FactoryComment>
      <summary>Creates an ExpressionListSyntax node.</summary>
    </FactoryComment>
  </Node>
  
</Tree>
