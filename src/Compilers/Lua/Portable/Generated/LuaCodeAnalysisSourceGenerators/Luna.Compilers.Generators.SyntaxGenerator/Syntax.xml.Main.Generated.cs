// <auto-generated />

#nullable enable

using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Syntax.InternalSyntax;
using SamLu.CodeAnalysis.Lua;
using Roslyn.Utilities;

namespace SamLu.CodeAnalysis.Lua
{
    using System.Diagnostics.CodeAnalysis;
    using Microsoft.CodeAnalysis;
    using SamLu.CodeAnalysis.Lua.Syntax;

    public partial class LuaSyntaxVisitor<TResult>
    {
        /// <summary>Called when the visitor visits a IdentifierNameSyntax node.</summary>
        public virtual TResult? VisitIdentifierName(IdentifierNameSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a LiteralExpressionSyntax node.</summary>
        public virtual TResult? VisitLiteralExpression(LiteralExpressionSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a ParenthesizedExpressionSyntax node.</summary>
        public virtual TResult? VisitParenthesizedExpression(ParenthesizedExpressionSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a FunctionDefinitionExpressionSyntax node.</summary>
        public virtual TResult? VisitFunctionDefinitionExpression(FunctionDefinitionExpressionSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a TableConstructorExpressionSyntax node.</summary>
        public virtual TResult? VisitTableConstructorExpression(TableConstructorExpressionSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a BinaryExpressionSyntax node.</summary>
        public virtual TResult? VisitBinaryExpression(BinaryExpressionSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a UnaryExpressionSyntax node.</summary>
        public virtual TResult? VisitUnaryExpression(UnaryExpressionSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a AssignmentExpressionSyntax node.</summary>
        public virtual TResult? VisitAssignmentExpression(AssignmentExpressionSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a SimpleMemberAccessExpression node.</summary>
        public virtual TResult? VisitSimpleMemberAccessExpression(SimpleMemberAccessExpression node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a IndexMemberAccessExpressionSyntax node.</summary>
        public virtual TResult? VisitIndexMemberAccessExpression(IndexMemberAccessExpressionSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a InvocationExpressionSyntax node.</summary>
        public virtual TResult? VisitInvocationExpression(InvocationExpressionSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a EmptyStatementSyntax node.</summary>
        public virtual TResult? VisitEmptyStatement(EmptyStatementSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a LabeledStatementSyntax node.</summary>
        public virtual TResult? VisitLabeledStatement(LabeledStatementSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a BreakStatementSyntax node.</summary>
        public virtual TResult? VisitBreakStatement(BreakStatementSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a GotoStatementSyntax node.</summary>
        public virtual TResult? VisitGotoStatement(GotoStatementSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a ReturnStatementSyntax node.</summary>
        public virtual TResult? VisitReturnStatement(ReturnStatementSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a DoStatementSyntax node.</summary>
        public virtual TResult? VisitDoStatement(DoStatementSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a WhileStatementSyntax node.</summary>
        public virtual TResult? VisitWhileStatement(WhileStatementSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a RepeatStatementSyntax node.</summary>
        public virtual TResult? VisitRepeatStatement(RepeatStatementSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a IfStatementSyntax node.</summary>
        public virtual TResult? VisitIfStatement(IfStatementSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a ElseIfClauseSyntax node.</summary>
        public virtual TResult? VisitElseIfClause(ElseIfClauseSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a ElseClauseSyntax node.</summary>
        public virtual TResult? VisitElseClause(ElseClauseSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a ForStatementSyntax node.</summary>
        public virtual TResult? VisitForStatement(ForStatementSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a ChunkSyntax node.</summary>
        public virtual TResult? VisitChunk(ChunkSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a BlockSyntax node.</summary>
        public virtual TResult? VisitBlock(BlockSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a SkippedTokensTriviaSyntax node.</summary>
        public virtual TResult? VisitSkippedTokensTrivia(SkippedTokensTriviaSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a ExpressionListSyntax node.</summary>
        public virtual TResult? VisitExpressionList(ExpressionListSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a BracketedExpressionSyntax node.</summary>
        public virtual TResult? VisitBracketedExpression(BracketedExpressionSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a ParameterListSyntax node.</summary>
        public virtual TResult? VisitParameterList(ParameterListSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a ParameterSyntax node.</summary>
        public virtual TResult? VisitParameter(ParameterSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a FieldListSyntax node.</summary>
        public virtual TResult? VisitFieldList(FieldListSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a FieldSyntax node.</summary>
        public virtual TResult? VisitField(FieldSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a ArgumentListSyntax node.</summary>
        public virtual TResult? VisitArgumentList(ArgumentListSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a ArgumentSyntax node.</summary>
        public virtual TResult? VisitArgument(ArgumentSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a ImplicitSelfCallSyntax node.</summary>
        public virtual TResult? VisitImplicitSelfCall(ImplicitSelfCallSyntax node) => this.DefaultVisit(node);
    }

    public partial class LuaSyntaxVisitor
    {
        /// <summary>Called when the visitor visits a IdentifierNameSyntax node.</summary>
        public virtual void VisitIdentifierName(IdentifierNameSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a LiteralExpressionSyntax node.</summary>
        public virtual void VisitLiteralExpression(LiteralExpressionSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a ParenthesizedExpressionSyntax node.</summary>
        public virtual void VisitParenthesizedExpression(ParenthesizedExpressionSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a FunctionDefinitionExpressionSyntax node.</summary>
        public virtual void VisitFunctionDefinitionExpression(FunctionDefinitionExpressionSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a TableConstructorExpressionSyntax node.</summary>
        public virtual void VisitTableConstructorExpression(TableConstructorExpressionSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a BinaryExpressionSyntax node.</summary>
        public virtual void VisitBinaryExpression(BinaryExpressionSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a UnaryExpressionSyntax node.</summary>
        public virtual void VisitUnaryExpression(UnaryExpressionSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a AssignmentExpressionSyntax node.</summary>
        public virtual void VisitAssignmentExpression(AssignmentExpressionSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a SimpleMemberAccessExpression node.</summary>
        public virtual void VisitSimpleMemberAccessExpression(SimpleMemberAccessExpression node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a IndexMemberAccessExpressionSyntax node.</summary>
        public virtual void VisitIndexMemberAccessExpression(IndexMemberAccessExpressionSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a InvocationExpressionSyntax node.</summary>
        public virtual void VisitInvocationExpression(InvocationExpressionSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a EmptyStatementSyntax node.</summary>
        public virtual void VisitEmptyStatement(EmptyStatementSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a LabeledStatementSyntax node.</summary>
        public virtual void VisitLabeledStatement(LabeledStatementSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a BreakStatementSyntax node.</summary>
        public virtual void VisitBreakStatement(BreakStatementSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a GotoStatementSyntax node.</summary>
        public virtual void VisitGotoStatement(GotoStatementSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a ReturnStatementSyntax node.</summary>
        public virtual void VisitReturnStatement(ReturnStatementSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a DoStatementSyntax node.</summary>
        public virtual void VisitDoStatement(DoStatementSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a WhileStatementSyntax node.</summary>
        public virtual void VisitWhileStatement(WhileStatementSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a RepeatStatementSyntax node.</summary>
        public virtual void VisitRepeatStatement(RepeatStatementSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a IfStatementSyntax node.</summary>
        public virtual void VisitIfStatement(IfStatementSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a ElseIfClauseSyntax node.</summary>
        public virtual void VisitElseIfClause(ElseIfClauseSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a ElseClauseSyntax node.</summary>
        public virtual void VisitElseClause(ElseClauseSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a ForStatementSyntax node.</summary>
        public virtual void VisitForStatement(ForStatementSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a ChunkSyntax node.</summary>
        public virtual void VisitChunk(ChunkSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a BlockSyntax node.</summary>
        public virtual void VisitBlock(BlockSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a SkippedTokensTriviaSyntax node.</summary>
        public virtual void VisitSkippedTokensTrivia(SkippedTokensTriviaSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a ExpressionListSyntax node.</summary>
        public virtual void VisitExpressionList(ExpressionListSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a BracketedExpressionSyntax node.</summary>
        public virtual void VisitBracketedExpression(BracketedExpressionSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a ParameterListSyntax node.</summary>
        public virtual void VisitParameterList(ParameterListSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a ParameterSyntax node.</summary>
        public virtual void VisitParameter(ParameterSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a FieldListSyntax node.</summary>
        public virtual void VisitFieldList(FieldListSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a FieldSyntax node.</summary>
        public virtual void VisitField(FieldSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a ArgumentListSyntax node.</summary>
        public virtual void VisitArgumentList(ArgumentListSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a ArgumentSyntax node.</summary>
        public virtual void VisitArgument(ArgumentSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a ImplicitSelfCallSyntax node.</summary>
        public virtual void VisitImplicitSelfCall(ImplicitSelfCallSyntax node) => this.DefaultVisit(node);
    }

    public partial class LuaSyntaxRewriter
    {
        public override LuaSyntaxNode? VisitIdentifierName(IdentifierNameSyntax node)
            => node.Update(VisitToken(node.Identifier));

        public override LuaSyntaxNode? VisitLiteralExpression(LiteralExpressionSyntax node)
            => node.Update(VisitToken(node.Token));

        public override LuaSyntaxNode? VisitParenthesizedExpression(ParenthesizedExpressionSyntax node)
            => node.Update(VisitToken(node.OpenParenToken), (ExpressionSyntax?)Visit(node.Expression) ?? throw new ArgumentNullException("expression"), VisitToken(node.CloseParenToken));

        public override LuaSyntaxNode? VisitFunctionDefinitionExpression(FunctionDefinitionExpressionSyntax node)
            => node.Update(VisitToken(node.FunctionKeyword), (ParameterListSyntax?)Visit(node.Parameters) ?? throw new ArgumentNullException("parameters"), (BlockSyntax?)Visit(node.Body) ?? throw new ArgumentNullException("body"), VisitToken(node.EndKeyword));

        public override LuaSyntaxNode? VisitTableConstructorExpression(TableConstructorExpressionSyntax node)
            => node.Update(VisitToken(node.OpenBrace), VisitList(node.Fields), VisitToken(node.CloseBrace));

        public override LuaSyntaxNode? VisitBinaryExpression(BinaryExpressionSyntax node)
            => node.Update((ExpressionSyntax?)Visit(node.Left) ?? throw new ArgumentNullException("left"), VisitToken(node.OperatorToken), (ExpressionSyntax?)Visit(node.Right) ?? throw new ArgumentNullException("right"));

        public override LuaSyntaxNode? VisitUnaryExpression(UnaryExpressionSyntax node)
            => node.Update(VisitToken(node.OperatorToken), (ExpressionSyntax?)Visit(node.Operand) ?? throw new ArgumentNullException("operand"));

        public override LuaSyntaxNode? VisitAssignmentExpression(AssignmentExpressionSyntax node)
            => node.Update((ExpressionSyntax?)Visit(node.Left) ?? throw new ArgumentNullException("left"), VisitToken(node.EqualsToken), (ExpressionSyntax?)Visit(node.Right) ?? throw new ArgumentNullException("right"));

        public override LuaSyntaxNode? VisitSimpleMemberAccessExpression(SimpleMemberAccessExpression node)
            => node.Update((ExpressionSyntax?)Visit(node.Expression) ?? throw new ArgumentNullException("expression"), VisitToken(node.OperatorToken), (ExpressionSyntax?)Visit(node.MemberExpression) ?? throw new ArgumentNullException("memberExpression"));

        public override LuaSyntaxNode? VisitIndexMemberAccessExpression(IndexMemberAccessExpressionSyntax node)
            => node.Update((ExpressionSyntax?)Visit(node.Expression) ?? throw new ArgumentNullException("expression"), (BracketedExpressionSyntax?)Visit(node.Key) ?? throw new ArgumentNullException("key"));

        public override LuaSyntaxNode? VisitInvocationExpression(InvocationExpressionSyntax node)
            => node.Update((ExpressionSyntax?)Visit(node.Expression), (ImplicitSelfCallSyntax?)Visit(node.SelfCall), (ArgumentListSyntax?)Visit(node.ArgumentList) ?? throw new ArgumentNullException("argumentList"));

        public override LuaSyntaxNode? VisitEmptyStatement(EmptyStatementSyntax node)
            => node.Update(VisitToken(node.SemicolonToken));

        public override LuaSyntaxNode? VisitLabeledStatement(LabeledStatementSyntax node)
            => node.Update(VisitToken(node.LeftColonColonToken), VisitToken(node.Identifier), VisitToken(node.RightColonColonToken), (StatementSyntax?)Visit(node.Statement) ?? throw new ArgumentNullException("statement"));

        public override LuaSyntaxNode? VisitBreakStatement(BreakStatementSyntax node)
            => node.Update(VisitToken(node.BreakKeyword));

        public override LuaSyntaxNode? VisitGotoStatement(GotoStatementSyntax node)
            => node.Update(VisitToken(node.GotoKeyword), (IdentifierNameSyntax?)Visit(node.Name) ?? throw new ArgumentNullException("name"), VisitToken(node.SemicolonToken));

        public override LuaSyntaxNode? VisitReturnStatement(ReturnStatementSyntax node)
            => node.Update(VisitToken(node.ReturnKeyword), (ExpressionListSyntax?)Visit(node.Values), VisitToken(node.SemicolonToken));

        public override LuaSyntaxNode? VisitDoStatement(DoStatementSyntax node)
            => node.Update(VisitToken(node.DoKeyword), (BlockSyntax?)Visit(node.Block) ?? throw new ArgumentNullException("block"), VisitToken(node.EndKeyword));

        public override LuaSyntaxNode? VisitWhileStatement(WhileStatementSyntax node)
            => node.Update(VisitToken(node.WhileKeyword), (ExpressionSyntax?)Visit(node.Condition) ?? throw new ArgumentNullException("condition"), VisitToken(node.DoKeyword), (BlockSyntax?)Visit(node.Block) ?? throw new ArgumentNullException("block"), VisitToken(node.EndKeyword));

        public override LuaSyntaxNode? VisitRepeatStatement(RepeatStatementSyntax node)
            => node.Update(VisitToken(node.RepeatKeyword), (BlockSyntax?)Visit(node.Block) ?? throw new ArgumentNullException("block"), VisitToken(node.UntilKeyword), (ExpressionSyntax?)Visit(node.Condition) ?? throw new ArgumentNullException("condition"), VisitToken(node.SemicolonToken));

        public override LuaSyntaxNode? VisitIfStatement(IfStatementSyntax node)
            => node.Update(VisitToken(node.IfKeyword), (ExpressionSyntax?)Visit(node.Condition) ?? throw new ArgumentNullException("condition"), VisitToken(node.ThenKeyword), (BlockSyntax?)Visit(node.Block) ?? throw new ArgumentNullException("block"), VisitList(node.ElseIfs), (ElseClauseSyntax?)Visit(node.Else), VisitToken(node.EndKeyword));

        public override LuaSyntaxNode? VisitElseIfClause(ElseIfClauseSyntax node)
            => node.Update(VisitToken(node.ElseIfKeyword), (ExpressionSyntax?)Visit(node.Condition) ?? throw new ArgumentNullException("condition"), VisitToken(node.ThenKeyword), (BlockSyntax?)Visit(node.Block) ?? throw new ArgumentNullException("block"));

        public override LuaSyntaxNode? VisitElseClause(ElseClauseSyntax node)
            => node.Update(VisitToken(node.ElseKeyword), (StatementSyntax?)Visit(node.Statement) ?? throw new ArgumentNullException("statement"));

        public override LuaSyntaxNode? VisitForStatement(ForStatementSyntax node)
            => node.Update(VisitToken(node.ForKeyword), (IdentifierNameSyntax?)Visit(node.Name) ?? throw new ArgumentNullException("name"), VisitToken(node.EqualsToken), (ExpressionSyntax?)Visit(node.Initial) ?? throw new ArgumentNullException("initial"), VisitToken(node.FirstCommaToken), (ExpressionSyntax?)Visit(node.Limit) ?? throw new ArgumentNullException("limit"), VisitToken(node.SecondCommaToken), (ExpressionSyntax?)Visit(node.Step) ?? throw new ArgumentNullException("step"), VisitToken(node.DoKeyword), (BlockSyntax?)Visit(node.Block) ?? throw new ArgumentNullException("block"), VisitToken(node.EndKeyword));

        public override LuaSyntaxNode? VisitChunk(ChunkSyntax node)
            => node.Update((BlockSyntax?)Visit(node.Block) ?? throw new ArgumentNullException("block"), VisitToken(node.EndOfFileToken));

        public override LuaSyntaxNode? VisitBlock(BlockSyntax node)
            => node.Update(VisitList(node.Statements));

        public override LuaSyntaxNode? VisitSkippedTokensTrivia(SkippedTokensTriviaSyntax node)
            => node.Update(VisitList(node.Tokens));

        public override LuaSyntaxNode? VisitExpressionList(ExpressionListSyntax node)
            => node.Update(VisitList(node.Expressions));

        public override LuaSyntaxNode? VisitBracketedExpression(BracketedExpressionSyntax node)
            => node.Update(VisitToken(node.OpenParenToken), (ExpressionSyntax?)Visit(node.Expression) ?? throw new ArgumentNullException("expression"), VisitToken(node.CloseParenToken));

        public override LuaSyntaxNode? VisitParameterList(ParameterListSyntax node)
            => node.Update(VisitToken(node.OpenParenToken), VisitList(node.Parameters), VisitToken(node.CloseParenToken));

        public override LuaSyntaxNode? VisitParameter(ParameterSyntax node)
            => node.Update(VisitToken(node.Identifier));

        public override LuaSyntaxNode? VisitFieldList(FieldListSyntax node)
            => node.Update(VisitList(node.Fields));

        public override LuaSyntaxNode? VisitField(FieldSyntax node)
            => node.Update((ExpressionSyntax?)Visit(node.Expression), (IdentifierNameSyntax?)Visit(node.Name), (BracketedExpressionSyntax?)Visit(node.FieldKey), VisitToken(node.EqualsToken), (ExpressionSyntax?)Visit(node.FieldValue));

        public override LuaSyntaxNode? VisitArgumentList(ArgumentListSyntax node)
            => node.Update((TableConstructorExpressionSyntax?)Visit(node.ArgumentTable), VisitToken(node.OpenParenToken), VisitList(node.Arguments), VisitToken(node.CloseParenToken));

        public override LuaSyntaxNode? VisitArgument(ArgumentSyntax node)
            => node.Update((ExpressionSyntax?)Visit(node.Expression) ?? throw new ArgumentNullException("expression"));

        public override LuaSyntaxNode? VisitImplicitSelfCall(ImplicitSelfCallSyntax node)
            => node.Update((ExpressionSyntax?)Visit(node.Expression) ?? throw new ArgumentNullException("expression"), VisitToken(node.ColonToken), (IdentifierNameSyntax?)Visit(node.Name) ?? throw new ArgumentNullException("name"));
    }

    public static partial class SyntaxFactory
    {

        /// <summary>Creates a new IdentifierNameSyntax instance.</summary>
        public static IdentifierNameSyntax IdentifierName(SyntaxToken identifier)
        {
            switch (identifier.Kind())
            {
                case SyntaxKind.IdentifierToken:
                case SyntaxKind.GlobalEnvironmentKeyword:
                case SyntaxKind.EnvironmentKeyword: break;
                default: throw new ArgumentException(nameof(identifier));
            }
            return (IdentifierNameSyntax)Syntax.InternalSyntax.SyntaxFactory.IdentifierName((Syntax.InternalSyntax.SyntaxToken)identifier.Node!).CreateRed();
        }

        /// <summary>Creates a new LiteralExpressionSyntax instance.</summary>
        public static LiteralExpressionSyntax LiteralExpression(SyntaxKind kind, SyntaxToken token)
        {
            switch (kind)
            {
                case SyntaxKind.NilLiteralExpression:
                case SyntaxKind.FalseLiteralExpression:
                case SyntaxKind.TrueLiteralExpression:
                case SyntaxKind.NumericLiteralExpression:
                case SyntaxKind.StringLiteralExpression:
                case SyntaxKind.VariousArgumentsExpression: break;
                default: throw new ArgumentException(nameof(kind));
            }
            switch (token.Kind())
            {
                case SyntaxKind.NilKeyword:
                case SyntaxKind.FalseKeyword:
                case SyntaxKind.TrueKeyword:
                case SyntaxKind.NumericLiteralToken:
                case SyntaxKind.StringLiteralToken:
                case SyntaxKind.MultiLineRawStringLiteralToken:
                case SyntaxKind.DotDotDotToken: break;
                default: throw new ArgumentException(nameof(token));
            }
            return (LiteralExpressionSyntax)Syntax.InternalSyntax.SyntaxFactory.LiteralExpression(kind, (Syntax.InternalSyntax.SyntaxToken)token.Node!).CreateRed();
        }

        /// <summary>Creates a new ParenthesizedExpressionSyntax instance.</summary>
        public static ParenthesizedExpressionSyntax ParenthesizedExpression(SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
        {
            if (openParenToken.Kind() != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (closeParenToken.Kind() != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
            return (ParenthesizedExpressionSyntax)Syntax.InternalSyntax.SyntaxFactory.ParenthesizedExpression((Syntax.InternalSyntax.SyntaxToken)openParenToken.Node!, (Syntax.InternalSyntax.ExpressionSyntax)expression.Green, (Syntax.InternalSyntax.SyntaxToken)closeParenToken.Node!).CreateRed();
        }

        /// <summary>Creates a new ParenthesizedExpressionSyntax instance.</summary>
        public static ParenthesizedExpressionSyntax ParenthesizedExpression(ExpressionSyntax expression)
            => SyntaxFactory.ParenthesizedExpression(SyntaxFactory.Token(SyntaxKind.OpenParenToken), expression, SyntaxFactory.Token(SyntaxKind.CloseParenToken));

        /// <summary>Creates a new FunctionDefinitionExpressionSyntax instance.</summary>
        public static FunctionDefinitionExpressionSyntax FunctionDefinitionExpression(SyntaxToken functionKeyword, ParameterListSyntax parameters, BlockSyntax body, SyntaxToken endKeyword)
        {
            if (functionKeyword.Kind() != SyntaxKind.FunctionKeyword) throw new ArgumentException(nameof(functionKeyword));
            if (parameters == null) throw new ArgumentNullException(nameof(parameters));
            if (body == null) throw new ArgumentNullException(nameof(body));
            if (endKeyword.Kind() != SyntaxKind.EndKeyword) throw new ArgumentException(nameof(endKeyword));
            return (FunctionDefinitionExpressionSyntax)Syntax.InternalSyntax.SyntaxFactory.FunctionDefinitionExpression((Syntax.InternalSyntax.SyntaxToken)functionKeyword.Node!, (Syntax.InternalSyntax.ParameterListSyntax)parameters.Green, (Syntax.InternalSyntax.BlockSyntax)body.Green, (Syntax.InternalSyntax.SyntaxToken)endKeyword.Node!).CreateRed();
        }

        /// <summary>Creates a new FunctionDefinitionExpressionSyntax instance.</summary>
        public static FunctionDefinitionExpressionSyntax FunctionDefinitionExpression(ParameterListSyntax parameters, BlockSyntax body)
            => SyntaxFactory.FunctionDefinitionExpression(SyntaxFactory.Token(SyntaxKind.FunctionKeyword), parameters, body, SyntaxFactory.Token(SyntaxKind.EndKeyword));

        /// <summary>Creates a new FunctionDefinitionExpressionSyntax instance.</summary>
        public static FunctionDefinitionExpressionSyntax FunctionDefinitionExpression()
            => SyntaxFactory.FunctionDefinitionExpression(SyntaxFactory.Token(SyntaxKind.FunctionKeyword), SyntaxFactory.ParameterList(), SyntaxFactory.Block(), SyntaxFactory.Token(SyntaxKind.EndKeyword));

        /// <summary>Creates a new TableConstructorExpressionSyntax instance.</summary>
        public static TableConstructorExpressionSyntax TableConstructorExpression(SyntaxToken openBrace, SeparatedSyntaxList<FieldListSyntax> fields, SyntaxToken closeBrace)
        {
            if (openBrace.Kind() != SyntaxKind.OpenBraceToken) throw new ArgumentException(nameof(openBrace));
            if (closeBrace.Kind() != SyntaxKind.CloseBraceToken) throw new ArgumentException(nameof(closeBrace));
            return (TableConstructorExpressionSyntax)Syntax.InternalSyntax.SyntaxFactory.TableConstructorExpression((Syntax.InternalSyntax.SyntaxToken)openBrace.Node!, fields.Node.ToGreenSeparatedList<Syntax.InternalSyntax.FieldListSyntax>(), (Syntax.InternalSyntax.SyntaxToken)closeBrace.Node!).CreateRed();
        }

        /// <summary>Creates a new TableConstructorExpressionSyntax instance.</summary>
        public static TableConstructorExpressionSyntax TableConstructorExpression(SeparatedSyntaxList<FieldListSyntax> fields = default)
            => SyntaxFactory.TableConstructorExpression(SyntaxFactory.Token(SyntaxKind.OpenBraceToken), fields, SyntaxFactory.Token(SyntaxKind.CloseBraceToken));

        /// <summary>Creates a new BinaryExpressionSyntax instance.</summary>
        public static BinaryExpressionSyntax BinaryExpression(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)
        {
            switch (kind)
            {
                case SyntaxKind.AdditionExpression:
                case SyntaxKind.SubtractionExpression:
                case SyntaxKind.MultiplicationExpression:
                case SyntaxKind.DivisionExpression:
                case SyntaxKind.FloorDivisionExpression:
                case SyntaxKind.ExponentiationExpression:
                case SyntaxKind.ModuloExpression:
                case SyntaxKind.BitwiseAndExpression:
                case SyntaxKind.BitwiseExclusiveOrExpression:
                case SyntaxKind.BitwiseOrExpression:
                case SyntaxKind.BitwiseLeftShiftExpression:
                case SyntaxKind.BitwiseRightShiftExpression:
                case SyntaxKind.ConcatenationExpression:
                case SyntaxKind.LessThanExpression:
                case SyntaxKind.LessThanOrEqualExpression:
                case SyntaxKind.GreaterThanExpression:
                case SyntaxKind.GreaterThanOrEqualExpression:
                case SyntaxKind.EqualExpression:
                case SyntaxKind.NotEqualExpression:
                case SyntaxKind.AndExpression:
                case SyntaxKind.OrExpression: break;
                default: throw new ArgumentException(nameof(kind));
            }
            if (left == null) throw new ArgumentNullException(nameof(left));
            switch (operatorToken.Kind())
            {
                case SyntaxKind.PlusToken:
                case SyntaxKind.MinusToken:
                case SyntaxKind.AsteriskToken:
                case SyntaxKind.SlashToken:
                case SyntaxKind.SlashSlashToken:
                case SyntaxKind.CaretToken:
                case SyntaxKind.PersentToken:
                case SyntaxKind.AmpersandToken:
                case SyntaxKind.TildeToken:
                case SyntaxKind.BarToken:
                case SyntaxKind.LessThanLessThanToken:
                case SyntaxKind.GreaterThanGreaterThanToken:
                case SyntaxKind.DotDotToken:
                case SyntaxKind.LessThanToken:
                case SyntaxKind.LessThanEqualsToken:
                case SyntaxKind.GreaterThanToken:
                case SyntaxKind.GreaterThanEqualsToken:
                case SyntaxKind.EqualsEqualsToken:
                case SyntaxKind.TildeEqualsToken:
                case SyntaxKind.AndKeyword:
                case SyntaxKind.OrKeyword: break;
                default: throw new ArgumentException(nameof(operatorToken));
            }
            if (right == null) throw new ArgumentNullException(nameof(right));
            return (BinaryExpressionSyntax)Syntax.InternalSyntax.SyntaxFactory.BinaryExpression(kind, (Syntax.InternalSyntax.ExpressionSyntax)left.Green, (Syntax.InternalSyntax.SyntaxToken)operatorToken.Node!, (Syntax.InternalSyntax.ExpressionSyntax)right.Green).CreateRed();
        }

        /// <summary>Creates a new BinaryExpressionSyntax instance.</summary>
        public static BinaryExpressionSyntax BinaryExpression(SyntaxKind kind, ExpressionSyntax left, ExpressionSyntax right)
            => SyntaxFactory.BinaryExpression(kind, left, SyntaxFactory.Token(GetBinaryExpressionOperatorTokenKind(kind)), right);

        private static SyntaxKind GetBinaryExpressionOperatorTokenKind(SyntaxKind kind)
            => kind switch
            {
                SyntaxKind.AdditionExpression => SyntaxKind.PlusToken,
                SyntaxKind.SubtractionExpression => SyntaxKind.MinusToken,
                SyntaxKind.MultiplicationExpression => SyntaxKind.AsteriskToken,
                SyntaxKind.DivisionExpression => SyntaxKind.SlashToken,
                SyntaxKind.FloorDivisionExpression => SyntaxKind.SlashSlashToken,
                SyntaxKind.ExponentiationExpression => SyntaxKind.CaretToken,
                SyntaxKind.ModuloExpression => SyntaxKind.PersentToken,
                SyntaxKind.BitwiseAndExpression => SyntaxKind.AmpersandToken,
                SyntaxKind.BitwiseExclusiveOrExpression => SyntaxKind.TildeToken,
                SyntaxKind.BitwiseOrExpression => SyntaxKind.BarToken,
                SyntaxKind.BitwiseLeftShiftExpression => SyntaxKind.LessThanLessThanToken,
                SyntaxKind.BitwiseRightShiftExpression => SyntaxKind.GreaterThanGreaterThanToken,
                SyntaxKind.ConcatenationExpression => SyntaxKind.DotDotToken,
                SyntaxKind.LessThanExpression => SyntaxKind.LessThanToken,
                SyntaxKind.LessThanOrEqualExpression => SyntaxKind.LessThanEqualsToken,
                SyntaxKind.GreaterThanExpression => SyntaxKind.GreaterThanToken,
                SyntaxKind.GreaterThanOrEqualExpression => SyntaxKind.GreaterThanEqualsToken,
                SyntaxKind.EqualExpression => SyntaxKind.EqualsEqualsToken,
                SyntaxKind.NotEqualExpression => SyntaxKind.TildeEqualsToken,
                SyntaxKind.AndExpression => SyntaxKind.AndKeyword,
                SyntaxKind.OrExpression => SyntaxKind.OrKeyword,
                _ => throw new ArgumentOutOfRangeException(),
            };

        /// <summary>Creates a new UnaryExpressionSyntax instance.</summary>
        public static UnaryExpressionSyntax UnaryExpression(SyntaxKind kind, SyntaxToken operatorToken, ExpressionSyntax operand)
        {
            switch (kind)
            {
                case SyntaxKind.UnaryMinusExpression:
                case SyntaxKind.LogicalNotExpression:
                case SyntaxKind.LengthExpression:
                case SyntaxKind.BitwiseNotExpression: break;
                default: throw new ArgumentException(nameof(kind));
            }
            switch (operatorToken.Kind())
            {
                case SyntaxKind.MinusToken:
                case SyntaxKind.NotKeyword:
                case SyntaxKind.HashToken:
                case SyntaxKind.TildeToken: break;
                default: throw new ArgumentException(nameof(operatorToken));
            }
            if (operand == null) throw new ArgumentNullException(nameof(operand));
            return (UnaryExpressionSyntax)Syntax.InternalSyntax.SyntaxFactory.UnaryExpression(kind, (Syntax.InternalSyntax.SyntaxToken)operatorToken.Node!, (Syntax.InternalSyntax.ExpressionSyntax)operand.Green).CreateRed();
        }

        /// <summary>Creates a new UnaryExpressionSyntax instance.</summary>
        public static UnaryExpressionSyntax UnaryExpression(SyntaxKind kind, ExpressionSyntax operand)
            => SyntaxFactory.UnaryExpression(kind, SyntaxFactory.Token(GetUnaryExpressionOperatorTokenKind(kind)), operand);

        private static SyntaxKind GetUnaryExpressionOperatorTokenKind(SyntaxKind kind)
            => kind switch
            {
                SyntaxKind.UnaryMinusExpression => SyntaxKind.MinusToken,
                SyntaxKind.LogicalNotExpression => SyntaxKind.NotKeyword,
                SyntaxKind.LengthExpression => SyntaxKind.HashToken,
                SyntaxKind.BitwiseNotExpression => SyntaxKind.TildeToken,
                _ => throw new ArgumentOutOfRangeException(),
            };

        /// <summary>Creates a new AssignmentExpressionSyntax instance.</summary>
        public static AssignmentExpressionSyntax AssignmentExpression(ExpressionSyntax left, SyntaxToken equalsToken, ExpressionSyntax right)
        {
            if (left == null) throw new ArgumentNullException(nameof(left));
            if (equalsToken.Kind() != SyntaxKind.EqualsToken) throw new ArgumentException(nameof(equalsToken));
            if (right == null) throw new ArgumentNullException(nameof(right));
            return (AssignmentExpressionSyntax)Syntax.InternalSyntax.SyntaxFactory.AssignmentExpression((Syntax.InternalSyntax.ExpressionSyntax)left.Green, (Syntax.InternalSyntax.SyntaxToken)equalsToken.Node!, (Syntax.InternalSyntax.ExpressionSyntax)right.Green).CreateRed();
        }

        /// <summary>Creates a new AssignmentExpressionSyntax instance.</summary>
        public static AssignmentExpressionSyntax AssignmentExpression(ExpressionSyntax left, ExpressionSyntax right)
            => SyntaxFactory.AssignmentExpression(left, SyntaxFactory.Token(SyntaxKind.EqualsToken), right);

        /// <summary>Creates a new SimpleMemberAccessExpression instance.</summary>
        public static SimpleMemberAccessExpression SimpleMemberAccessExpression(ExpressionSyntax expression, SyntaxToken operatorToken, ExpressionSyntax memberExpression)
        {
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (operatorToken.Kind() != SyntaxKind.DotToken) throw new ArgumentException(nameof(operatorToken));
            if (memberExpression == null) throw new ArgumentNullException(nameof(memberExpression));
            return (SimpleMemberAccessExpression)Syntax.InternalSyntax.SyntaxFactory.SimpleMemberAccessExpression((Syntax.InternalSyntax.ExpressionSyntax)expression.Green, (Syntax.InternalSyntax.SyntaxToken)operatorToken.Node!, (Syntax.InternalSyntax.ExpressionSyntax)memberExpression.Green).CreateRed();
        }

        /// <summary>Creates a new SimpleMemberAccessExpression instance.</summary>
        public static SimpleMemberAccessExpression SimpleMemberAccessExpression(ExpressionSyntax expression, ExpressionSyntax memberExpression)
            => SyntaxFactory.SimpleMemberAccessExpression(expression, SyntaxFactory.Token(SyntaxKind.DotToken), memberExpression);

        /// <summary>Creates a new IndexMemberAccessExpressionSyntax instance.</summary>
        public static IndexMemberAccessExpressionSyntax IndexMemberAccessExpression(ExpressionSyntax expression, BracketedExpressionSyntax key)
        {
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (key == null) throw new ArgumentNullException(nameof(key));
            return (IndexMemberAccessExpressionSyntax)Syntax.InternalSyntax.SyntaxFactory.IndexMemberAccessExpression((Syntax.InternalSyntax.ExpressionSyntax)expression.Green, (Syntax.InternalSyntax.BracketedExpressionSyntax)key.Green).CreateRed();
        }

        /// <summary>Creates a new InvocationExpressionSyntax instance.</summary>
        public static InvocationExpressionSyntax InvocationExpression(ExpressionSyntax? expression, ImplicitSelfCallSyntax? selfCall, ArgumentListSyntax argumentList)
        {
            if (argumentList == null) throw new ArgumentNullException(nameof(argumentList));
            return (InvocationExpressionSyntax)Syntax.InternalSyntax.SyntaxFactory.InvocationExpression(expression == null ? null : (Syntax.InternalSyntax.ExpressionSyntax)expression.Green, selfCall == null ? null : (Syntax.InternalSyntax.ImplicitSelfCallSyntax)selfCall.Green, (Syntax.InternalSyntax.ArgumentListSyntax)argumentList.Green).CreateRed();
        }

        /// <summary>Creates a new InvocationExpressionSyntax instance.</summary>
        public static InvocationExpressionSyntax InvocationExpression()
            => SyntaxFactory.InvocationExpression(default, default, SyntaxFactory.ArgumentList());

        /// <summary>Creates a new EmptyStatementSyntax instance.</summary>
        public static EmptyStatementSyntax EmptyStatement(SyntaxToken semicolonToken)
        {
            switch (semicolonToken.Kind())
            {
                case SyntaxKind.SemicolonToken:
                case SyntaxKind.None: break;
                default: throw new ArgumentException(nameof(semicolonToken));
            }
            return (EmptyStatementSyntax)Syntax.InternalSyntax.SyntaxFactory.EmptyStatement((Syntax.InternalSyntax.SyntaxToken?)semicolonToken.Node).CreateRed();
        }

        /// <summary>Creates a new EmptyStatementSyntax instance.</summary>
        public static EmptyStatementSyntax EmptyStatement()
            => SyntaxFactory.EmptyStatement(default);

        /// <summary>Creates a new LabeledStatementSyntax instance.</summary>
        public static LabeledStatementSyntax LabeledStatement(SyntaxToken leftColonColonToken, SyntaxToken identifier, SyntaxToken rightColonColonToken, StatementSyntax statement)
        {
            if (leftColonColonToken.Kind() != SyntaxKind.ColonColonToken) throw new ArgumentException(nameof(leftColonColonToken));
            if (identifier.Kind() != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(identifier));
            if (rightColonColonToken.Kind() != SyntaxKind.ColonColonToken) throw new ArgumentException(nameof(rightColonColonToken));
            if (statement == null) throw new ArgumentNullException(nameof(statement));
            return (LabeledStatementSyntax)Syntax.InternalSyntax.SyntaxFactory.LabeledStatement((Syntax.InternalSyntax.SyntaxToken)leftColonColonToken.Node!, (Syntax.InternalSyntax.SyntaxToken)identifier.Node!, (Syntax.InternalSyntax.SyntaxToken)rightColonColonToken.Node!, (Syntax.InternalSyntax.StatementSyntax)statement.Green).CreateRed();
        }

        /// <summary>Creates a new LabeledStatementSyntax instance.</summary>
        public static LabeledStatementSyntax LabeledStatement(SyntaxToken identifier, StatementSyntax statement)
            => SyntaxFactory.LabeledStatement(SyntaxFactory.Token(SyntaxKind.ColonColonToken), identifier, SyntaxFactory.Token(SyntaxKind.ColonColonToken), statement);

        /// <summary>Creates a new LabeledStatementSyntax instance.</summary>
        public static LabeledStatementSyntax LabeledStatement(string identifier, StatementSyntax statement)
            => SyntaxFactory.LabeledStatement(SyntaxFactory.Token(SyntaxKind.ColonColonToken), SyntaxFactory.Identifier(identifier), SyntaxFactory.Token(SyntaxKind.ColonColonToken), statement);

        /// <summary>Creates a new BreakStatementSyntax instance.</summary>
        public static BreakStatementSyntax BreakStatement(SyntaxToken breakKeyword)
        {
            if (breakKeyword.Kind() != SyntaxKind.BreakKeyword) throw new ArgumentException(nameof(breakKeyword));
            return (BreakStatementSyntax)Syntax.InternalSyntax.SyntaxFactory.BreakStatement((Syntax.InternalSyntax.SyntaxToken)breakKeyword.Node!).CreateRed();
        }

        /// <summary>Creates a new BreakStatementSyntax instance.</summary>
        public static BreakStatementSyntax BreakStatement()
            => SyntaxFactory.BreakStatement(SyntaxFactory.Token(SyntaxKind.BreakKeyword));

        /// <summary>Creates a new GotoStatementSyntax instance.</summary>
        public static GotoStatementSyntax GotoStatement(SyntaxToken gotoKeyword, IdentifierNameSyntax name, SyntaxToken semicolonToken)
        {
            if (gotoKeyword.Kind() != SyntaxKind.GotoKeyword) throw new ArgumentException(nameof(gotoKeyword));
            if (name == null) throw new ArgumentNullException(nameof(name));
            switch (semicolonToken.Kind())
            {
                case SyntaxKind.SemicolonToken:
                case SyntaxKind.None: break;
                default: throw new ArgumentException(nameof(semicolonToken));
            }
            return (GotoStatementSyntax)Syntax.InternalSyntax.SyntaxFactory.GotoStatement((Syntax.InternalSyntax.SyntaxToken)gotoKeyword.Node!, (Syntax.InternalSyntax.IdentifierNameSyntax)name.Green, (Syntax.InternalSyntax.SyntaxToken?)semicolonToken.Node).CreateRed();
        }

        /// <summary>Creates a new GotoStatementSyntax instance.</summary>
        public static GotoStatementSyntax GotoStatement(IdentifierNameSyntax name)
            => SyntaxFactory.GotoStatement(SyntaxFactory.Token(SyntaxKind.GotoKeyword), name, default);

        /// <summary>Creates a new GotoStatementSyntax instance.</summary>
        public static GotoStatementSyntax GotoStatement(string name)
            => SyntaxFactory.GotoStatement(SyntaxFactory.Token(SyntaxKind.GotoKeyword), SyntaxFactory.IdentifierName(name), default);

        /// <summary>Creates a new ReturnStatementSyntax instance.</summary>
        public static ReturnStatementSyntax ReturnStatement(SyntaxToken returnKeyword, ExpressionListSyntax? values, SyntaxToken semicolonToken)
        {
            if (returnKeyword.Kind() != SyntaxKind.ReturnKeyword) throw new ArgumentException(nameof(returnKeyword));
            switch (semicolonToken.Kind())
            {
                case SyntaxKind.SemicolonToken:
                case SyntaxKind.None: break;
                default: throw new ArgumentException(nameof(semicolonToken));
            }
            return (ReturnStatementSyntax)Syntax.InternalSyntax.SyntaxFactory.ReturnStatement((Syntax.InternalSyntax.SyntaxToken)returnKeyword.Node!, values == null ? null : (Syntax.InternalSyntax.ExpressionListSyntax)values.Green, (Syntax.InternalSyntax.SyntaxToken?)semicolonToken.Node).CreateRed();
        }

        /// <summary>Creates a new ReturnStatementSyntax instance.</summary>
        public static ReturnStatementSyntax ReturnStatement(ExpressionListSyntax? values = default)
            => SyntaxFactory.ReturnStatement(SyntaxFactory.Token(SyntaxKind.ReturnKeyword), values, default);

        /// <summary>Creates a new DoStatementSyntax instance.</summary>
        public static DoStatementSyntax DoStatement(SyntaxToken doKeyword, BlockSyntax block, SyntaxToken endKeyword)
        {
            if (doKeyword.Kind() != SyntaxKind.DoKeyword) throw new ArgumentException(nameof(doKeyword));
            if (block == null) throw new ArgumentNullException(nameof(block));
            if (endKeyword.Kind() != SyntaxKind.EndKeyword) throw new ArgumentException(nameof(endKeyword));
            return (DoStatementSyntax)Syntax.InternalSyntax.SyntaxFactory.DoStatement((Syntax.InternalSyntax.SyntaxToken)doKeyword.Node!, (Syntax.InternalSyntax.BlockSyntax)block.Green, (Syntax.InternalSyntax.SyntaxToken)endKeyword.Node!).CreateRed();
        }

        /// <summary>Creates a new DoStatementSyntax instance.</summary>
        public static DoStatementSyntax DoStatement(BlockSyntax? block = default)
            => SyntaxFactory.DoStatement(SyntaxFactory.Token(SyntaxKind.DoKeyword), block ?? SyntaxFactory.Block(), SyntaxFactory.Token(SyntaxKind.EndKeyword));

        /// <summary>Creates a new WhileStatementSyntax instance.</summary>
        public static WhileStatementSyntax WhileStatement(SyntaxToken whileKeyword, ExpressionSyntax condition, SyntaxToken doKeyword, BlockSyntax block, SyntaxToken endKeyword)
        {
            if (whileKeyword.Kind() != SyntaxKind.WhileKeyword) throw new ArgumentException(nameof(whileKeyword));
            if (condition == null) throw new ArgumentNullException(nameof(condition));
            if (doKeyword.Kind() != SyntaxKind.DoKeyword) throw new ArgumentException(nameof(doKeyword));
            if (block == null) throw new ArgumentNullException(nameof(block));
            if (endKeyword.Kind() != SyntaxKind.EndKeyword) throw new ArgumentException(nameof(endKeyword));
            return (WhileStatementSyntax)Syntax.InternalSyntax.SyntaxFactory.WhileStatement((Syntax.InternalSyntax.SyntaxToken)whileKeyword.Node!, (Syntax.InternalSyntax.ExpressionSyntax)condition.Green, (Syntax.InternalSyntax.SyntaxToken)doKeyword.Node!, (Syntax.InternalSyntax.BlockSyntax)block.Green, (Syntax.InternalSyntax.SyntaxToken)endKeyword.Node!).CreateRed();
        }

        /// <summary>Creates a new WhileStatementSyntax instance.</summary>
        public static WhileStatementSyntax WhileStatement(ExpressionSyntax condition, BlockSyntax block)
            => SyntaxFactory.WhileStatement(SyntaxFactory.Token(SyntaxKind.WhileKeyword), condition, SyntaxFactory.Token(SyntaxKind.DoKeyword), block, SyntaxFactory.Token(SyntaxKind.EndKeyword));

        /// <summary>Creates a new WhileStatementSyntax instance.</summary>
        public static WhileStatementSyntax WhileStatement(ExpressionSyntax condition)
            => SyntaxFactory.WhileStatement(SyntaxFactory.Token(SyntaxKind.WhileKeyword), condition, SyntaxFactory.Token(SyntaxKind.DoKeyword), SyntaxFactory.Block(), SyntaxFactory.Token(SyntaxKind.EndKeyword));

        /// <summary>Creates a new RepeatStatementSyntax instance.</summary>
        public static RepeatStatementSyntax RepeatStatement(SyntaxToken repeatKeyword, BlockSyntax block, SyntaxToken untilKeyword, ExpressionSyntax condition, SyntaxToken semicolonToken)
        {
            if (repeatKeyword.Kind() != SyntaxKind.RepeatKeyword) throw new ArgumentException(nameof(repeatKeyword));
            if (block == null) throw new ArgumentNullException(nameof(block));
            if (untilKeyword.Kind() != SyntaxKind.UntilKeyword) throw new ArgumentException(nameof(untilKeyword));
            if (condition == null) throw new ArgumentNullException(nameof(condition));
            switch (semicolonToken.Kind())
            {
                case SyntaxKind.SemicolonToken:
                case SyntaxKind.None: break;
                default: throw new ArgumentException(nameof(semicolonToken));
            }
            return (RepeatStatementSyntax)Syntax.InternalSyntax.SyntaxFactory.RepeatStatement((Syntax.InternalSyntax.SyntaxToken)repeatKeyword.Node!, (Syntax.InternalSyntax.BlockSyntax)block.Green, (Syntax.InternalSyntax.SyntaxToken)untilKeyword.Node!, (Syntax.InternalSyntax.ExpressionSyntax)condition.Green, (Syntax.InternalSyntax.SyntaxToken?)semicolonToken.Node).CreateRed();
        }

        /// <summary>Creates a new RepeatStatementSyntax instance.</summary>
        public static RepeatStatementSyntax RepeatStatement(BlockSyntax block, ExpressionSyntax condition)
            => SyntaxFactory.RepeatStatement(SyntaxFactory.Token(SyntaxKind.RepeatKeyword), block, SyntaxFactory.Token(SyntaxKind.UntilKeyword), condition, default);

        /// <summary>Creates a new RepeatStatementSyntax instance.</summary>
        public static RepeatStatementSyntax RepeatStatement(ExpressionSyntax condition)
            => SyntaxFactory.RepeatStatement(SyntaxFactory.Token(SyntaxKind.RepeatKeyword), SyntaxFactory.Block(), SyntaxFactory.Token(SyntaxKind.UntilKeyword), condition, default);

        /// <summary>Creates a new IfStatementSyntax instance.</summary>
        public static IfStatementSyntax IfStatement(SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken thenKeyword, BlockSyntax block, SyntaxList<ElseIfClauseSyntax> elseIfs, ElseClauseSyntax? @else, SyntaxToken endKeyword)
        {
            if (ifKeyword.Kind() != SyntaxKind.IfKeyword) throw new ArgumentException(nameof(ifKeyword));
            if (condition == null) throw new ArgumentNullException(nameof(condition));
            if (thenKeyword.Kind() != SyntaxKind.ThenKeyword) throw new ArgumentException(nameof(thenKeyword));
            if (block == null) throw new ArgumentNullException(nameof(block));
            if (endKeyword.Kind() != SyntaxKind.EndKeyword) throw new ArgumentException(nameof(endKeyword));
            return (IfStatementSyntax)Syntax.InternalSyntax.SyntaxFactory.IfStatement((Syntax.InternalSyntax.SyntaxToken)ifKeyword.Node!, (Syntax.InternalSyntax.ExpressionSyntax)condition.Green, (Syntax.InternalSyntax.SyntaxToken)thenKeyword.Node!, (Syntax.InternalSyntax.BlockSyntax)block.Green, elseIfs.Node.ToGreenList<Syntax.InternalSyntax.ElseIfClauseSyntax>(), @else == null ? null : (Syntax.InternalSyntax.ElseClauseSyntax)@else.Green, (Syntax.InternalSyntax.SyntaxToken)endKeyword.Node!).CreateRed();
        }

        /// <summary>Creates a new IfStatementSyntax instance.</summary>
        public static IfStatementSyntax IfStatement(ExpressionSyntax condition, BlockSyntax block, SyntaxList<ElseIfClauseSyntax> elseIfs, ElseClauseSyntax? @else)
            => SyntaxFactory.IfStatement(SyntaxFactory.Token(SyntaxKind.IfKeyword), condition, SyntaxFactory.Token(SyntaxKind.ThenKeyword), block, elseIfs, @else, SyntaxFactory.Token(SyntaxKind.EndKeyword));

        /// <summary>Creates a new IfStatementSyntax instance.</summary>
        public static IfStatementSyntax IfStatement(ExpressionSyntax condition)
            => SyntaxFactory.IfStatement(SyntaxFactory.Token(SyntaxKind.IfKeyword), condition, SyntaxFactory.Token(SyntaxKind.ThenKeyword), SyntaxFactory.Block(), default, default, SyntaxFactory.Token(SyntaxKind.EndKeyword));

        /// <summary>Creates a new ElseIfClauseSyntax instance.</summary>
        public static ElseIfClauseSyntax ElseIfClause(SyntaxToken elseIfKeyword, ExpressionSyntax condition, SyntaxToken thenKeyword, BlockSyntax block)
        {
            if (elseIfKeyword.Kind() != SyntaxKind.ElseIfKeyword) throw new ArgumentException(nameof(elseIfKeyword));
            if (condition == null) throw new ArgumentNullException(nameof(condition));
            if (thenKeyword.Kind() != SyntaxKind.ThenKeyword) throw new ArgumentException(nameof(thenKeyword));
            if (block == null) throw new ArgumentNullException(nameof(block));
            return (ElseIfClauseSyntax)Syntax.InternalSyntax.SyntaxFactory.ElseIfClause((Syntax.InternalSyntax.SyntaxToken)elseIfKeyword.Node!, (Syntax.InternalSyntax.ExpressionSyntax)condition.Green, (Syntax.InternalSyntax.SyntaxToken)thenKeyword.Node!, (Syntax.InternalSyntax.BlockSyntax)block.Green).CreateRed();
        }

        /// <summary>Creates a new ElseIfClauseSyntax instance.</summary>
        public static ElseIfClauseSyntax ElseIfClause(ExpressionSyntax condition, BlockSyntax block)
            => SyntaxFactory.ElseIfClause(SyntaxFactory.Token(SyntaxKind.ElseIfKeyword), condition, SyntaxFactory.Token(SyntaxKind.ThenKeyword), block);

        /// <summary>Creates a new ElseIfClauseSyntax instance.</summary>
        public static ElseIfClauseSyntax ElseIfClause(ExpressionSyntax condition)
            => SyntaxFactory.ElseIfClause(SyntaxFactory.Token(SyntaxKind.ElseIfKeyword), condition, SyntaxFactory.Token(SyntaxKind.ThenKeyword), SyntaxFactory.Block());

        /// <summary>Creates a new ElseClauseSyntax instance.</summary>
        public static ElseClauseSyntax ElseClause(SyntaxToken elseKeyword, StatementSyntax statement)
        {
            if (elseKeyword.Kind() != SyntaxKind.ElseKeyword) throw new ArgumentException(nameof(elseKeyword));
            if (statement == null) throw new ArgumentNullException(nameof(statement));
            return (ElseClauseSyntax)Syntax.InternalSyntax.SyntaxFactory.ElseClause((Syntax.InternalSyntax.SyntaxToken)elseKeyword.Node!, (Syntax.InternalSyntax.StatementSyntax)statement.Green).CreateRed();
        }

        /// <summary>Creates a new ElseClauseSyntax instance.</summary>
        public static ElseClauseSyntax ElseClause(StatementSyntax statement)
            => SyntaxFactory.ElseClause(SyntaxFactory.Token(SyntaxKind.ElseKeyword), statement);

        /// <summary>Creates a new ForStatementSyntax instance.</summary>
        public static ForStatementSyntax ForStatement(SyntaxToken forKeyword, IdentifierNameSyntax name, SyntaxToken equalsToken, ExpressionSyntax initial, SyntaxToken firstCommaToken, ExpressionSyntax limit, SyntaxToken secondCommaToken, ExpressionSyntax step, SyntaxToken doKeyword, BlockSyntax block, SyntaxToken endKeyword)
        {
            if (forKeyword.Kind() != SyntaxKind.ForKeyword) throw new ArgumentException(nameof(forKeyword));
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (equalsToken.Kind() != SyntaxKind.EqualsToken) throw new ArgumentException(nameof(equalsToken));
            if (initial == null) throw new ArgumentNullException(nameof(initial));
            if (firstCommaToken.Kind() != SyntaxKind.CommaToken) throw new ArgumentException(nameof(firstCommaToken));
            if (limit == null) throw new ArgumentNullException(nameof(limit));
            if (secondCommaToken.Kind() != SyntaxKind.CommaToken) throw new ArgumentException(nameof(secondCommaToken));
            if (step == null) throw new ArgumentNullException(nameof(step));
            if (doKeyword.Kind() != SyntaxKind.DoKeyword) throw new ArgumentException(nameof(doKeyword));
            if (block == null) throw new ArgumentNullException(nameof(block));
            if (endKeyword.Kind() != SyntaxKind.EndKeyword) throw new ArgumentException(nameof(endKeyword));
            return (ForStatementSyntax)Syntax.InternalSyntax.SyntaxFactory.ForStatement((Syntax.InternalSyntax.SyntaxToken)forKeyword.Node!, (Syntax.InternalSyntax.IdentifierNameSyntax)name.Green, (Syntax.InternalSyntax.SyntaxToken)equalsToken.Node!, (Syntax.InternalSyntax.ExpressionSyntax)initial.Green, (Syntax.InternalSyntax.SyntaxToken)firstCommaToken.Node!, (Syntax.InternalSyntax.ExpressionSyntax)limit.Green, (Syntax.InternalSyntax.SyntaxToken)secondCommaToken.Node!, (Syntax.InternalSyntax.ExpressionSyntax)step.Green, (Syntax.InternalSyntax.SyntaxToken)doKeyword.Node!, (Syntax.InternalSyntax.BlockSyntax)block.Green, (Syntax.InternalSyntax.SyntaxToken)endKeyword.Node!).CreateRed();
        }

        /// <summary>Creates a new ForStatementSyntax instance.</summary>
        public static ForStatementSyntax ForStatement(IdentifierNameSyntax name, ExpressionSyntax initial, ExpressionSyntax limit, ExpressionSyntax step, BlockSyntax block)
            => SyntaxFactory.ForStatement(SyntaxFactory.Token(SyntaxKind.ForKeyword), name, SyntaxFactory.Token(SyntaxKind.EqualsToken), initial, SyntaxFactory.Token(SyntaxKind.CommaToken), limit, SyntaxFactory.Token(SyntaxKind.CommaToken), step, SyntaxFactory.Token(SyntaxKind.DoKeyword), block, SyntaxFactory.Token(SyntaxKind.EndKeyword));

        /// <summary>Creates a new ForStatementSyntax instance.</summary>
        public static ForStatementSyntax ForStatement(IdentifierNameSyntax name, ExpressionSyntax initial, ExpressionSyntax limit, ExpressionSyntax step)
            => SyntaxFactory.ForStatement(SyntaxFactory.Token(SyntaxKind.ForKeyword), name, SyntaxFactory.Token(SyntaxKind.EqualsToken), initial, SyntaxFactory.Token(SyntaxKind.CommaToken), limit, SyntaxFactory.Token(SyntaxKind.CommaToken), step, SyntaxFactory.Token(SyntaxKind.DoKeyword), SyntaxFactory.Block(), SyntaxFactory.Token(SyntaxKind.EndKeyword));

        /// <summary>Creates a new ForStatementSyntax instance.</summary>
        public static ForStatementSyntax ForStatement(string name, ExpressionSyntax initial, ExpressionSyntax limit, ExpressionSyntax step)
            => SyntaxFactory.ForStatement(SyntaxFactory.Token(SyntaxKind.ForKeyword), SyntaxFactory.IdentifierName(name), SyntaxFactory.Token(SyntaxKind.EqualsToken), initial, SyntaxFactory.Token(SyntaxKind.CommaToken), limit, SyntaxFactory.Token(SyntaxKind.CommaToken), step, SyntaxFactory.Token(SyntaxKind.DoKeyword), SyntaxFactory.Block(), SyntaxFactory.Token(SyntaxKind.EndKeyword));

        /// <summary>Creates a new ChunkSyntax instance.</summary>
        public static ChunkSyntax Chunk(BlockSyntax block, SyntaxToken endOfFileToken)
        {
            if (block == null) throw new ArgumentNullException(nameof(block));
            if (endOfFileToken.Kind() != SyntaxKind.EndOfFileToken) throw new ArgumentException(nameof(endOfFileToken));
            return (ChunkSyntax)Syntax.InternalSyntax.SyntaxFactory.Chunk((Syntax.InternalSyntax.BlockSyntax)block.Green, (Syntax.InternalSyntax.SyntaxToken)endOfFileToken.Node!).CreateRed();
        }

        /// <summary>Creates a new ChunkSyntax instance.</summary>
        public static ChunkSyntax Chunk(BlockSyntax? block = default)
            => SyntaxFactory.Chunk(block ?? SyntaxFactory.Block(), SyntaxFactory.Token(SyntaxKind.EndOfFileToken));

        /// <summary>Creates a new BlockSyntax instance.</summary>
        public static BlockSyntax Block(SyntaxList<StatementSyntax> statements)
        {
            return (BlockSyntax)Syntax.InternalSyntax.SyntaxFactory.Block(statements.Node.ToGreenList<Syntax.InternalSyntax.StatementSyntax>()).CreateRed();
        }

        /// <summary>Creates a new BlockSyntax instance.</summary>
        public static BlockSyntax Block()
            => SyntaxFactory.Block(default);

        /// <summary>Creates a new SkippedTokensTriviaSyntax instance.</summary>
        public static SkippedTokensTriviaSyntax SkippedTokensTrivia(SyntaxTokenList tokens)
        {
            return (SkippedTokensTriviaSyntax)Syntax.InternalSyntax.SyntaxFactory.SkippedTokensTrivia(tokens.Node.ToGreenList<Syntax.InternalSyntax.SyntaxToken>()).CreateRed();
        }

        /// <summary>Creates a new SkippedTokensTriviaSyntax instance.</summary>
        public static SkippedTokensTriviaSyntax SkippedTokensTrivia()
            => SyntaxFactory.SkippedTokensTrivia(default(SyntaxTokenList));

        /// <summary>Creates a new ExpressionListSyntax instance.</summary>
        public static ExpressionListSyntax ExpressionList(SeparatedSyntaxList<ExpressionSyntax> expressions)
        {
            return (ExpressionListSyntax)Syntax.InternalSyntax.SyntaxFactory.ExpressionList(expressions.Node.ToGreenSeparatedList<Syntax.InternalSyntax.ExpressionSyntax>()).CreateRed();
        }

        /// <summary>Creates a new ExpressionListSyntax instance.</summary>
        public static ExpressionListSyntax ExpressionList()
            => SyntaxFactory.ExpressionList(default);

        /// <summary>Creates a new BracketedExpressionSyntax instance.</summary>
        public static BracketedExpressionSyntax BracketedExpression(SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
        {
            if (openParenToken.Kind() != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (closeParenToken.Kind() != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
            return (BracketedExpressionSyntax)Syntax.InternalSyntax.SyntaxFactory.BracketedExpression((Syntax.InternalSyntax.SyntaxToken)openParenToken.Node!, (Syntax.InternalSyntax.ExpressionSyntax)expression.Green, (Syntax.InternalSyntax.SyntaxToken)closeParenToken.Node!).CreateRed();
        }

        /// <summary>Creates a new BracketedExpressionSyntax instance.</summary>
        public static BracketedExpressionSyntax BracketedExpression(ExpressionSyntax expression)
            => SyntaxFactory.BracketedExpression(SyntaxFactory.Token(SyntaxKind.OpenParenToken), expression, SyntaxFactory.Token(SyntaxKind.CloseParenToken));

        /// <summary>Creates a new ParameterListSyntax instance.</summary>
        public static ParameterListSyntax ParameterList(SyntaxToken openParenToken, SeparatedSyntaxList<ParameterSyntax> parameters, SyntaxToken closeParenToken)
        {
            if (openParenToken.Kind() != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (closeParenToken.Kind() != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
            return (ParameterListSyntax)Syntax.InternalSyntax.SyntaxFactory.ParameterList((Syntax.InternalSyntax.SyntaxToken)openParenToken.Node!, parameters.Node.ToGreenSeparatedList<Syntax.InternalSyntax.ParameterSyntax>(), (Syntax.InternalSyntax.SyntaxToken)closeParenToken.Node!).CreateRed();
        }

        /// <summary>Creates a new ParameterListSyntax instance.</summary>
        public static ParameterListSyntax ParameterList(SeparatedSyntaxList<ParameterSyntax> parameters = default)
            => SyntaxFactory.ParameterList(SyntaxFactory.Token(SyntaxKind.OpenParenToken), parameters, SyntaxFactory.Token(SyntaxKind.CloseParenToken));

        /// <summary>Creates a new ParameterSyntax instance.</summary>
        public static ParameterSyntax Parameter(SyntaxToken identifier)
        {
            switch (identifier.Kind())
            {
                case SyntaxKind.IdentifierToken:
                case SyntaxKind.DotDotDotToken: break;
                default: throw new ArgumentException(nameof(identifier));
            }
            return (ParameterSyntax)Syntax.InternalSyntax.SyntaxFactory.Parameter((Syntax.InternalSyntax.SyntaxToken)identifier.Node!).CreateRed();
        }

        /// <summary>Creates a new FieldListSyntax instance.</summary>
        public static FieldListSyntax FieldList(SeparatedSyntaxList<FieldSyntax> fields)
        {
            return (FieldListSyntax)Syntax.InternalSyntax.SyntaxFactory.FieldList(fields.Node.ToGreenSeparatedList<Syntax.InternalSyntax.FieldSyntax>()).CreateRed();
        }

        /// <summary>Creates a new FieldListSyntax instance.</summary>
        public static FieldListSyntax FieldList()
            => SyntaxFactory.FieldList(default);

        /// <summary>Creates a new FieldSyntax instance.</summary>
        public static FieldSyntax Field(ExpressionSyntax? expression, IdentifierNameSyntax? name, BracketedExpressionSyntax? fieldKey, SyntaxToken equalsToken, ExpressionSyntax? fieldValue)
        {
            switch (equalsToken.Kind())
            {
                case SyntaxKind.EqualsToken:
                case SyntaxKind.None: break;
                default: throw new ArgumentException(nameof(equalsToken));
            }
            return (FieldSyntax)Syntax.InternalSyntax.SyntaxFactory.Field(expression == null ? null : (Syntax.InternalSyntax.ExpressionSyntax)expression.Green, name == null ? null : (Syntax.InternalSyntax.IdentifierNameSyntax)name.Green, fieldKey == null ? null : (Syntax.InternalSyntax.BracketedExpressionSyntax)fieldKey.Green, (Syntax.InternalSyntax.SyntaxToken?)equalsToken.Node, fieldValue == null ? null : (Syntax.InternalSyntax.ExpressionSyntax)fieldValue.Green).CreateRed();
        }

        /// <summary>Creates a new FieldSyntax instance.</summary>
        public static FieldSyntax Field(ExpressionSyntax? expression, IdentifierNameSyntax? name, BracketedExpressionSyntax? fieldKey, ExpressionSyntax? fieldValue)
            => SyntaxFactory.Field(expression, name, fieldKey, default, fieldValue);

        /// <summary>Creates a new FieldSyntax instance.</summary>
        public static FieldSyntax Field()
            => SyntaxFactory.Field(default, default, default, default, default);

        /// <summary>Creates a new ArgumentListSyntax instance.</summary>
        public static ArgumentListSyntax ArgumentList(TableConstructorExpressionSyntax? argumentTable, SyntaxToken openParenToken, SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeParenToken)
        {
            switch (openParenToken.Kind())
            {
                case SyntaxKind.OpenParenToken:
                case SyntaxKind.None: break;
                default: throw new ArgumentException(nameof(openParenToken));
            }
            switch (closeParenToken.Kind())
            {
                case SyntaxKind.CloseParenToken:
                case SyntaxKind.None: break;
                default: throw new ArgumentException(nameof(closeParenToken));
            }
            return (ArgumentListSyntax)Syntax.InternalSyntax.SyntaxFactory.ArgumentList(argumentTable == null ? null : (Syntax.InternalSyntax.TableConstructorExpressionSyntax)argumentTable.Green, (Syntax.InternalSyntax.SyntaxToken?)openParenToken.Node, arguments.Node.ToGreenSeparatedList<Syntax.InternalSyntax.ArgumentSyntax>(), (Syntax.InternalSyntax.SyntaxToken?)closeParenToken.Node).CreateRed();
        }

        /// <summary>Creates a new ArgumentListSyntax instance.</summary>
        public static ArgumentListSyntax ArgumentList(TableConstructorExpressionSyntax? argumentTable, SeparatedSyntaxList<ArgumentSyntax> arguments)
            => SyntaxFactory.ArgumentList(argumentTable, default, arguments, default);

        /// <summary>Creates a new ArgumentListSyntax instance.</summary>
        public static ArgumentListSyntax ArgumentList(SeparatedSyntaxList<ArgumentSyntax> arguments = default)
            => SyntaxFactory.ArgumentList(default, default, arguments, default);

        /// <summary>Creates a new ArgumentSyntax instance.</summary>
        public static ArgumentSyntax Argument(ExpressionSyntax expression)
        {
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            return (ArgumentSyntax)Syntax.InternalSyntax.SyntaxFactory.Argument((Syntax.InternalSyntax.ExpressionSyntax)expression.Green).CreateRed();
        }

        /// <summary>Creates a new ImplicitSelfCallSyntax instance.</summary>
        public static ImplicitSelfCallSyntax ImplicitSelfCall(ExpressionSyntax expression, SyntaxToken colonToken, IdentifierNameSyntax name)
        {
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (colonToken.Kind() != SyntaxKind.ColonToken) throw new ArgumentException(nameof(colonToken));
            if (name == null) throw new ArgumentNullException(nameof(name));
            return (ImplicitSelfCallSyntax)Syntax.InternalSyntax.SyntaxFactory.ImplicitSelfCall((Syntax.InternalSyntax.ExpressionSyntax)expression.Green, (Syntax.InternalSyntax.SyntaxToken)colonToken.Node!, (Syntax.InternalSyntax.IdentifierNameSyntax)name.Green).CreateRed();
        }

        /// <summary>Creates a new ImplicitSelfCallSyntax instance.</summary>
        public static ImplicitSelfCallSyntax ImplicitSelfCall(ExpressionSyntax expression, IdentifierNameSyntax name)
            => SyntaxFactory.ImplicitSelfCall(expression, SyntaxFactory.Token(SyntaxKind.ColonToken), name);

        /// <summary>Creates a new ImplicitSelfCallSyntax instance.</summary>
        public static ImplicitSelfCallSyntax ImplicitSelfCall(ExpressionSyntax expression, string name)
            => SyntaxFactory.ImplicitSelfCall(expression, SyntaxFactory.Token(SyntaxKind.ColonToken), SyntaxFactory.IdentifierName(name));
    }
}
