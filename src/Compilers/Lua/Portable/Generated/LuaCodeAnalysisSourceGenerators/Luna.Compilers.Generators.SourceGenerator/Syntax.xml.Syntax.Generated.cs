// <auto-generated />

#nullable enable

using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Syntax.InternalSyntax;
using SamLu.CodeAnalysis.Lua;
using Roslyn.Utilities;

namespace SamLu.CodeAnalysis.Lua.Syntax
{
    using Microsoft.CodeAnalysis;

    /// <summary>提供表示名称语法节点继承用的父类，此类必须被继承。</summary>
    public abstract partial class NameSyntax : LuaSyntaxNode
    {
        internal NameSyntax(InternalSyntax.LuaSyntaxNode green, LuaSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }
    }

    /// <summary>提供表示简单名称语法节点继承用的父类，此类必须被继承。</summary>
    public abstract partial class SimpleNameSyntax : NameSyntax
    {
        internal SimpleNameSyntax(InternalSyntax.LuaSyntaxNode green, LuaSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>表示简单名称的语法标志。</summary>
        public abstract SyntaxToken Identifier { get; }
        public SimpleNameSyntax WithIdentifier(SyntaxToken identifier) => WithIdentifierCore(identifier);
        internal abstract SimpleNameSyntax WithIdentifierCore(SyntaxToken identifier);
    }

    /// <summary>Class which represents the syntax node for identifier name.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.IdentifierName"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class IdentifierNameSyntax : SimpleNameSyntax
    {

        internal IdentifierNameSyntax(InternalSyntax.LuaSyntaxNode green, LuaSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>SyntaxToken representing the keyword for the kind of the identifier name.</summary>
        public override SyntaxToken Identifier => new SyntaxToken(this, ((Syntax.InternalSyntax.IdentifierNameSyntax)this.Green).identifier, Position, 0);

        internal override SyntaxNode? GetNodeSlot(int index) => null;

        internal override SyntaxNode? GetCachedSlot(int index) => null;

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitIdentifierName(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitIdentifierName(this);

        public IdentifierNameSyntax Update(SyntaxToken identifier)
        {
            if (identifier != this.Identifier)
            {
                var newNode = SyntaxFactory.IdentifierName(identifier);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        internal override SimpleNameSyntax WithIdentifierCore(SyntaxToken identifier) => WithIdentifier(identifier);
        public new IdentifierNameSyntax WithIdentifier(SyntaxToken identifier) => Update(identifier);
    }

    /// <summary>Provides the base class from which the classes that represent expression syntax nodes are derived. This is an abstract class.</summary>
    public abstract partial class ExpressionSyntax : LuaSyntaxNode
    {
        internal ExpressionSyntax(InternalSyntax.LuaSyntaxNode green, LuaSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }
    }

    /// <summary>Class which represents the syntax node for a literal expression.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.NilLiteralExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.FalseLiteralExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.TrueLiteralExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.NumericLiteralExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.StringLiteralExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.VariousArgumentsExpression"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class LiteralExpressionSyntax : ExpressionSyntax
    {

        internal LiteralExpressionSyntax(InternalSyntax.LuaSyntaxNode green, LuaSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>SyntaxToken representing the keyword corresponding to the kind of the literal expression.</summary>
        public SyntaxToken Token => new SyntaxToken(this, ((Syntax.InternalSyntax.LiteralExpressionSyntax)this.Green).token, Position, 0);

        internal override SyntaxNode? GetNodeSlot(int index) => null;

        internal override SyntaxNode? GetCachedSlot(int index) => null;

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitLiteralExpression(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitLiteralExpression(this);

        public LiteralExpressionSyntax Update(SyntaxToken token)
        {
            if (token != this.Token)
            {
                var newNode = SyntaxFactory.LiteralExpression(this.Kind(), token);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public LiteralExpressionSyntax WithToken(SyntaxToken token) => Update(token);
    }

    /// <summary>Class which represents the syntax node for parenthesized expression.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.ParenthesizedExpression"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ParenthesizedExpressionSyntax : ExpressionSyntax
    {
        private ExpressionSyntax? expression;

        internal ParenthesizedExpressionSyntax(InternalSyntax.LuaSyntaxNode green, LuaSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>SyntaxToken representing the open parenthesis.</summary>
        public SyntaxToken OpenParenToken => new SyntaxToken(this, ((Syntax.InternalSyntax.ParenthesizedExpressionSyntax)this.Green).openParenToken, Position, 0);

        /// <summary>ExpressionSyntax node representing the expression enclosed within the parenthesis.</summary>
        public ExpressionSyntax Expression => GetRed(ref this.expression, 1)!;

        /// <summary>SyntaxToken representing the close parenthesis.</summary>
        public SyntaxToken CloseParenToken => new SyntaxToken(this, ((Syntax.InternalSyntax.ParenthesizedExpressionSyntax)this.Green).closeParenToken, GetChildPosition(2), GetChildIndex(2));

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.expression, 1)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.expression : null;

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitParenthesizedExpression(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitParenthesizedExpression(this);

        public ParenthesizedExpressionSyntax Update(SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
        {
            if (openParenToken != this.OpenParenToken || expression != this.Expression || closeParenToken != this.CloseParenToken)
            {
                var newNode = SyntaxFactory.ParenthesizedExpression(openParenToken, expression, closeParenToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ParenthesizedExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken) => Update(openParenToken, this.Expression, this.CloseParenToken);
        public ParenthesizedExpressionSyntax WithExpression(ExpressionSyntax expression) => Update(this.OpenParenToken, expression, this.CloseParenToken);
        public ParenthesizedExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken) => Update(this.OpenParenToken, this.Expression, closeParenToken);
    }

    /// <summary>Class which represents the syntax node for the list of expressions.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.ExpressionList"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ExpressionListSyntax : LuaSyntaxNode
    {
        private SyntaxNode? expressions;

        internal ExpressionListSyntax(InternalSyntax.LuaSyntaxNode green, LuaSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>SeparatedSyntaxList of ExpressionSyntax nodes representing the list of expressions.</summary>
        public SeparatedSyntaxList<ExpressionSyntax> Expressions
        {
            get
            {
                var red = GetRed(ref this.expressions, 0);
                return red != null ? new SeparatedSyntaxList<ExpressionSyntax>(red, 0) : default;
            }
        }

        internal override SyntaxNode? GetNodeSlot(int index) => index == 0 ? GetRedAtZero(ref this.expressions)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 0 ? this.expressions : null;

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitExpressionList(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitExpressionList(this);

        public ExpressionListSyntax Update(SeparatedSyntaxList<ExpressionSyntax> expressions)
        {
            if (expressions != this.Expressions)
            {
                var newNode = SyntaxFactory.ExpressionList(expressions);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ExpressionListSyntax WithExpressions(SeparatedSyntaxList<ExpressionSyntax> expressions) => Update(expressions);

        public ExpressionListSyntax AddExpressions(params ExpressionSyntax[] items) => WithExpressions(this.Expressions.AddRange(items));
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.FunctionDefinitionExpression"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class FunctionDefinitionExpressionSyntax : ExpressionSyntax
    {
        private ParameterListSyntax? parameters;
        private BlockSyntax? body;

        internal FunctionDefinitionExpressionSyntax(InternalSyntax.LuaSyntaxNode green, LuaSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken FunctionKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.FunctionDefinitionExpressionSyntax)this.Green).functionKeyword, Position, 0);

        public ParameterListSyntax Parameters => GetRed(ref this.parameters, 1)!;

        public BlockSyntax Body => GetRed(ref this.body, 2)!;

        public SyntaxToken EndKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.FunctionDefinitionExpressionSyntax)this.Green).endKeyword, GetChildPosition(3), GetChildIndex(3));

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                1 => GetRed(ref this.parameters, 1)!,
                2 => GetRed(ref this.body, 2)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                1 => this.parameters,
                2 => this.body,
                _ => null,
            };

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitFunctionDefinitionExpression(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitFunctionDefinitionExpression(this);

        public FunctionDefinitionExpressionSyntax Update(SyntaxToken functionKeyword, ParameterListSyntax parameters, BlockSyntax body, SyntaxToken endKeyword)
        {
            if (functionKeyword != this.FunctionKeyword || parameters != this.Parameters || body != this.Body || endKeyword != this.EndKeyword)
            {
                var newNode = SyntaxFactory.FunctionDefinitionExpression(functionKeyword, parameters, body, endKeyword);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public FunctionDefinitionExpressionSyntax WithFunctionKeyword(SyntaxToken functionKeyword) => Update(functionKeyword, this.Parameters, this.Body, this.EndKeyword);
        public FunctionDefinitionExpressionSyntax WithParameters(ParameterListSyntax parameters) => Update(this.FunctionKeyword, parameters, this.Body, this.EndKeyword);
        public FunctionDefinitionExpressionSyntax WithBody(BlockSyntax body) => Update(this.FunctionKeyword, this.Parameters, body, this.EndKeyword);
        public FunctionDefinitionExpressionSyntax WithEndKeyword(SyntaxToken endKeyword) => Update(this.FunctionKeyword, this.Parameters, this.Body, endKeyword);

        public FunctionDefinitionExpressionSyntax AddParametersParameters(params ParameterSyntax[] items) => WithParameters(this.Parameters.WithParameters(this.Parameters.Parameters.AddRange(items)));
        public FunctionDefinitionExpressionSyntax AddBodyStatements(params StatementSyntax[] items) => WithBody(this.Body.WithStatements(this.Body.Statements.AddRange(items)));
    }

    /// <summary>Class which represents the syntax node for the table constructor expression.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.TableConstructorExpression"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class TableConstructorExpressionSyntax : ExpressionSyntax
    {
        private SyntaxNode? fields;

        internal TableConstructorExpressionSyntax(InternalSyntax.LuaSyntaxNode green, LuaSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>SyntaxToken representing open brace.</summary>
        public SyntaxToken OpenBrace => new SyntaxToken(this, ((Syntax.InternalSyntax.TableConstructorExpressionSyntax)this.Green).openBrace, Position, 0);

        /// <summary>SeparatedSyntaxList of ExpressionSyntax nodes representing the list of fields.</summary>
        public SeparatedSyntaxList<FieldListSyntax> Fields
        {
            get
            {
                var red = GetRed(ref this.fields, 1);
                return red != null ? new SeparatedSyntaxList<FieldListSyntax>(red, GetChildIndex(1)) : default;
            }
        }

        /// <summary>SyntaxToken representing close brace.</summary>
        public SyntaxToken CloseBrace => new SyntaxToken(this, ((Syntax.InternalSyntax.TableConstructorExpressionSyntax)this.Green).closeBrace, GetChildPosition(2), GetChildIndex(2));

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.fields, 1)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.fields : null;

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitTableConstructorExpression(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitTableConstructorExpression(this);

        public TableConstructorExpressionSyntax Update(SyntaxToken openBrace, SeparatedSyntaxList<FieldListSyntax> fields, SyntaxToken closeBrace)
        {
            if (openBrace != this.OpenBrace || fields != this.Fields || closeBrace != this.CloseBrace)
            {
                var newNode = SyntaxFactory.TableConstructorExpression(openBrace, fields, closeBrace);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public TableConstructorExpressionSyntax WithOpenBrace(SyntaxToken openBrace) => Update(openBrace, this.Fields, this.CloseBrace);
        public TableConstructorExpressionSyntax WithFields(SeparatedSyntaxList<FieldListSyntax> fields) => Update(this.OpenBrace, fields, this.CloseBrace);
        public TableConstructorExpressionSyntax WithCloseBrace(SyntaxToken closeBrace) => Update(this.OpenBrace, this.Fields, closeBrace);

        public TableConstructorExpressionSyntax AddFields(params FieldListSyntax[] items) => WithFields(this.Fields.AddRange(items));
    }

    /// <summary>Class which represents an expression that has a binary operator.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.AdditionExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.SubtractionExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.MultiplicationExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.DivisionExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.FloorDivisionExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.ExponentiationExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.ModuloExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.BitwiseAndExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.BitwiseExclusiveOrExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.BitwiseOrExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.BitwiseLeftShiftExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.BitwiseRightShiftExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.ConcatenationExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.LessThanExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.LessThanOrEqualExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.GreaterThanExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.GreaterThanOrEqualExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.EqualExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.NotEqualExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.AndExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.OrExpression"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class BinaryExpressionSyntax : ExpressionSyntax
    {
        private ExpressionSyntax? left;
        private ExpressionSyntax? right;

        internal BinaryExpressionSyntax(InternalSyntax.LuaSyntaxNode green, LuaSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>ExpressionSyntax node representing the expression on the left of the binary operator.</summary>
        public ExpressionSyntax Left => GetRedAtZero(ref this.left)!;

        /// <summary>SyntaxToken representing the operator of the binary expression.</summary>
        public SyntaxToken OperatorToken => new SyntaxToken(this, ((Syntax.InternalSyntax.BinaryExpressionSyntax)this.Green).operatorToken, GetChildPosition(1), GetChildIndex(1));

        /// <summary>ExpressionSyntax node representing the expression on the right of the binary operator.</summary>
        public ExpressionSyntax Right => GetRed(ref this.right, 2)!;

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                0 => GetRedAtZero(ref this.left)!,
                2 => GetRed(ref this.right, 2)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                0 => this.left,
                2 => this.right,
                _ => null,
            };

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitBinaryExpression(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitBinaryExpression(this);

        public BinaryExpressionSyntax Update(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)
        {
            if (left != this.Left || operatorToken != this.OperatorToken || right != this.Right)
            {
                var newNode = SyntaxFactory.BinaryExpression(this.Kind(), left, operatorToken, right);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public BinaryExpressionSyntax WithLeft(ExpressionSyntax left) => Update(left, this.OperatorToken, this.Right);
        public BinaryExpressionSyntax WithOperatorToken(SyntaxToken operatorToken) => Update(this.Left, operatorToken, this.Right);
        public BinaryExpressionSyntax WithRight(ExpressionSyntax right) => Update(this.Left, this.OperatorToken, right);
    }

    /// <summary>Class which represents the syntax node for prefix unary expression.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.UnaryMinusExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.LogicalNotExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.LengthExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.BitwiseNotExpression"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class UnaryExpressionSyntax : ExpressionSyntax
    {
        private ExpressionSyntax? operand;

        internal UnaryExpressionSyntax(InternalSyntax.LuaSyntaxNode green, LuaSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>SyntaxToken representing the kind of the operator of the prefix unary expression.</summary>
        public SyntaxToken OperatorToken => new SyntaxToken(this, ((Syntax.InternalSyntax.UnaryExpressionSyntax)this.Green).operatorToken, Position, 0);

        /// <summary>ExpressionSyntax representing the operand of the prefix unary expression.</summary>
        public ExpressionSyntax Operand => GetRed(ref this.operand, 1)!;

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.operand, 1)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.operand : null;

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitUnaryExpression(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitUnaryExpression(this);

        public UnaryExpressionSyntax Update(SyntaxToken operatorToken, ExpressionSyntax operand)
        {
            if (operatorToken != this.OperatorToken || operand != this.Operand)
            {
                var newNode = SyntaxFactory.UnaryExpression(this.Kind(), operatorToken, operand);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public UnaryExpressionSyntax WithOperatorToken(SyntaxToken operatorToken) => Update(operatorToken, this.Operand);
        public UnaryExpressionSyntax WithOperand(ExpressionSyntax operand) => Update(this.OperatorToken, operand);
    }

    /// <summary>Class which represents an expression that has an assignment operator.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.AssignmentExpression"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class AssignmentExpressionSyntax : ExpressionSyntax
    {
        private ExpressionSyntax? left;
        private ExpressionSyntax? right;

        internal AssignmentExpressionSyntax(InternalSyntax.LuaSyntaxNode green, LuaSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>ExpressionSyntax node representing the expression on the left of the assignment operator.</summary>
        public ExpressionSyntax Left => GetRedAtZero(ref this.left)!;

        /// <summary>SyntaxToken representing the operator of the assignment expression.</summary>
        public SyntaxToken EqualsToken => new SyntaxToken(this, ((Syntax.InternalSyntax.AssignmentExpressionSyntax)this.Green).equalsToken, GetChildPosition(1), GetChildIndex(1));

        /// <summary>ExpressionSyntax node representing the expression on the right of the assignment operator.</summary>
        public ExpressionSyntax Right => GetRed(ref this.right, 2)!;

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                0 => GetRedAtZero(ref this.left)!,
                2 => GetRed(ref this.right, 2)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                0 => this.left,
                2 => this.right,
                _ => null,
            };

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitAssignmentExpression(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitAssignmentExpression(this);

        public AssignmentExpressionSyntax Update(ExpressionSyntax left, SyntaxToken equalsToken, ExpressionSyntax right)
        {
            if (left != this.Left || equalsToken != this.EqualsToken || right != this.Right)
            {
                var newNode = SyntaxFactory.AssignmentExpression(left, equalsToken, right);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public AssignmentExpressionSyntax WithLeft(ExpressionSyntax left) => Update(left, this.EqualsToken, this.Right);
        public AssignmentExpressionSyntax WithEqualsToken(SyntaxToken equalsToken) => Update(this.Left, equalsToken, this.Right);
        public AssignmentExpressionSyntax WithRight(ExpressionSyntax right) => Update(this.Left, this.EqualsToken, right);
    }

    public abstract partial class MemberAccessExpressionSyntax : ExpressionSyntax
    {
        internal MemberAccessExpressionSyntax(InternalSyntax.LuaSyntaxNode green, LuaSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>ExpressionSyntax node representing the object that the member belongs to.</summary>
        public abstract ExpressionSyntax Expression { get; }
        public MemberAccessExpressionSyntax WithExpression(ExpressionSyntax expression) => WithExpressionCore(expression);
        internal abstract MemberAccessExpressionSyntax WithExpressionCore(ExpressionSyntax expression);

        /// <summary>SimpleNameSyntax node representing the member being accessed.</summary>
        public abstract ExpressionSyntax MemberExpression { get; }
        public MemberAccessExpressionSyntax WithMemberExpression(ExpressionSyntax memberExpression) => WithMemberExpressionCore(memberExpression);
        internal abstract MemberAccessExpressionSyntax WithMemberExpressionCore(ExpressionSyntax memberExpression);
    }

    /// <summary>Class which represents the syntax node for member access expression.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.SimpleMemberAccessExpression"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class SimpleMemberAccessExpression : MemberAccessExpressionSyntax
    {
        private ExpressionSyntax? expression;
        private ExpressionSyntax? memberExpression;

        internal SimpleMemberAccessExpression(InternalSyntax.LuaSyntaxNode green, LuaSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>ExpressionSyntax node representing the object that the member belongs to.</summary>
        public override ExpressionSyntax Expression => GetRedAtZero(ref this.expression)!;

        /// <summary>SyntaxToken representing the kind of the operator in the member access expression.</summary>
        public SyntaxToken OperatorToken => new SyntaxToken(this, ((Syntax.InternalSyntax.SimpleMemberAccessExpression)this.Green).operatorToken, GetChildPosition(1), GetChildIndex(1));

        /// <summary>SimpleNameSyntax node representing the member being accessed.</summary>
        public override ExpressionSyntax MemberExpression => GetRed(ref this.memberExpression, 2)!;

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                0 => GetRedAtZero(ref this.expression)!,
                2 => GetRed(ref this.memberExpression, 2)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                0 => this.expression,
                2 => this.memberExpression,
                _ => null,
            };

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitSimpleMemberAccessExpression(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitSimpleMemberAccessExpression(this);

        public SimpleMemberAccessExpression Update(ExpressionSyntax expression, SyntaxToken operatorToken, ExpressionSyntax memberExpression)
        {
            if (expression != this.Expression || operatorToken != this.OperatorToken || memberExpression != this.MemberExpression)
            {
                var newNode = SyntaxFactory.SimpleMemberAccessExpression(expression, operatorToken, memberExpression);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        internal override MemberAccessExpressionSyntax WithExpressionCore(ExpressionSyntax expression) => WithExpression(expression);
        public new SimpleMemberAccessExpression WithExpression(ExpressionSyntax expression) => Update(expression, this.OperatorToken, this.MemberExpression);
        public SimpleMemberAccessExpression WithOperatorToken(SyntaxToken operatorToken) => Update(this.Expression, operatorToken, this.MemberExpression);
        internal override MemberAccessExpressionSyntax WithMemberExpressionCore(ExpressionSyntax memberExpression) => WithMemberExpression(memberExpression);
        public new SimpleMemberAccessExpression WithMemberExpression(ExpressionSyntax memberExpression) => Update(this.Expression, this.OperatorToken, memberExpression);
    }

    /// <summary>Class which represents the syntax node for member access expression.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.IndexMemberAccessExpression"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class IndexMemberAccessExpressionSyntax : MemberAccessExpressionSyntax
    {
        private ExpressionSyntax? expression;
        private BracketedExpressionSyntax? key;

        internal IndexMemberAccessExpressionSyntax(InternalSyntax.LuaSyntaxNode green, LuaSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>ExpressionSyntax node representing the object that the member belongs to.</summary>
        public override ExpressionSyntax Expression => GetRedAtZero(ref this.expression)!;

        public BracketedExpressionSyntax Key => GetRed(ref this.key, 1)!;

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                0 => GetRedAtZero(ref this.expression)!,
                1 => GetRed(ref this.key, 1)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                0 => this.expression,
                1 => this.key,
                _ => null,
            };

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitIndexMemberAccessExpression(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitIndexMemberAccessExpression(this);

        public IndexMemberAccessExpressionSyntax Update(ExpressionSyntax expression, BracketedExpressionSyntax key)
        {
            if (expression != this.Expression || key != this.Key)
            {
                var newNode = SyntaxFactory.IndexMemberAccessExpression(expression, key);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        internal override MemberAccessExpressionSyntax WithExpressionCore(ExpressionSyntax expression) => WithExpression(expression);
        public new IndexMemberAccessExpressionSyntax WithExpression(ExpressionSyntax expression) => Update(expression, this.Key);
        public IndexMemberAccessExpressionSyntax WithKey(BracketedExpressionSyntax key) => Update(this.Expression, key);
    }

    /// <summary>Class which represents the syntax node for invocation expression.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.InvocationExpression"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class InvocationExpressionSyntax : ExpressionSyntax
    {
        private ExpressionSyntax? expression;
        private ImplicitSelfCallSyntax? selfCallExpression;
        private ArgumentListSyntax? argumentList;

        internal InvocationExpressionSyntax(InternalSyntax.LuaSyntaxNode green, LuaSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>ExpressionSyntax node representing the expression part of the invocation.</summary>
        public ExpressionSyntax? Expression => GetRedAtZero(ref this.expression);

        public ImplicitSelfCallSyntax? SelfCallExpression => GetRed(ref this.selfCallExpression, 1);

        /// <summary>ArgumentListSyntax node representing the list of arguments of the invocation expression.</summary>
        public ArgumentListSyntax ArgumentList => GetRed(ref this.argumentList, 2)!;

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                0 => GetRedAtZero(ref this.expression),
                1 => GetRed(ref this.selfCallExpression, 1),
                2 => GetRed(ref this.argumentList, 2)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                0 => this.expression,
                1 => this.selfCallExpression,
                2 => this.argumentList,
                _ => null,
            };

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitInvocationExpression(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitInvocationExpression(this);

        public InvocationExpressionSyntax Update(ExpressionSyntax? expression, ImplicitSelfCallSyntax? selfCallExpression, ArgumentListSyntax argumentList)
        {
            if (expression != this.Expression || selfCallExpression != this.SelfCallExpression || argumentList != this.ArgumentList)
            {
                var newNode = SyntaxFactory.InvocationExpression(expression, selfCallExpression, argumentList);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public InvocationExpressionSyntax WithExpression(ExpressionSyntax? expression) => Update(expression, this.SelfCallExpression, this.ArgumentList);
        public InvocationExpressionSyntax WithSelfCallExpression(ImplicitSelfCallSyntax? selfCallExpression) => Update(this.Expression, selfCallExpression, this.ArgumentList);
        public InvocationExpressionSyntax WithArgumentList(ArgumentListSyntax argumentList) => Update(this.Expression, this.SelfCallExpression, argumentList);

        public InvocationExpressionSyntax AddArgumentListArguments(params ArgumentSyntax[] items) => WithArgumentList(this.ArgumentList.WithArguments(this.ArgumentList.Arguments.AddRange(items)));
    }

    /// <summary>Provides the base class from which the classes that represent statement syntax nodes are derived. This is an abstract class.</summary>
    public abstract partial class StatementSyntax : LuaSyntaxNode
    {
        internal StatementSyntax(InternalSyntax.LuaSyntaxNode green, LuaSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.EmptyStatement"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class EmptyStatementSyntax : StatementSyntax
    {

        internal EmptyStatementSyntax(InternalSyntax.LuaSyntaxNode green, LuaSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken SemicolonToken
        {
            get
            {
                var slot = ((Syntax.InternalSyntax.EmptyStatementSyntax)this.Green).semicolonToken;
                return slot != null ? new SyntaxToken(this, slot, Position, 0) : default;
            }
        }

        internal override SyntaxNode? GetNodeSlot(int index) => null;

        internal override SyntaxNode? GetCachedSlot(int index) => null;

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitEmptyStatement(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitEmptyStatement(this);

        public EmptyStatementSyntax Update(SyntaxToken semicolonToken)
        {
            if (semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.EmptyStatement(semicolonToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public EmptyStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken) => Update(semicolonToken);
    }

    /// <summary>Represents a labeled statement syntax.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.LabeledStatement"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class LabeledStatementSyntax : StatementSyntax
    {
        private StatementSyntax? statement;

        internal LabeledStatementSyntax(InternalSyntax.LuaSyntaxNode green, LuaSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>Gets a SyntaxToken that represents the double colons leading the statement's label.</summary>
        public SyntaxToken LeftColonColonToken => new SyntaxToken(this, ((Syntax.InternalSyntax.LabeledStatementSyntax)this.Green).leftColonColonToken, Position, 0);

        /// <summary>Gets the identifier.</summary>
        public SyntaxToken Identifier => new SyntaxToken(this, ((Syntax.InternalSyntax.LabeledStatementSyntax)this.Green).identifier, GetChildPosition(1), GetChildIndex(1));

        /// <summary>Gets a SyntaxToken that represents the double colons trailing the statement's label.</summary>
        public SyntaxToken RightColonColonToken => new SyntaxToken(this, ((Syntax.InternalSyntax.LabeledStatementSyntax)this.Green).rightColonColonToken, GetChildPosition(2), GetChildIndex(2));

        public StatementSyntax Statement => GetRed(ref this.statement, 3)!;

        internal override SyntaxNode? GetNodeSlot(int index) => index == 3 ? GetRed(ref this.statement, 3)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 3 ? this.statement : null;

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitLabeledStatement(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitLabeledStatement(this);

        public LabeledStatementSyntax Update(SyntaxToken leftColonColonToken, SyntaxToken identifier, SyntaxToken rightColonColonToken, StatementSyntax statement)
        {
            if (leftColonColonToken != this.LeftColonColonToken || identifier != this.Identifier || rightColonColonToken != this.RightColonColonToken || statement != this.Statement)
            {
                var newNode = SyntaxFactory.LabeledStatement(leftColonColonToken, identifier, rightColonColonToken, statement);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public LabeledStatementSyntax WithLeftColonColonToken(SyntaxToken leftColonColonToken) => Update(leftColonColonToken, this.Identifier, this.RightColonColonToken, this.Statement);
        public LabeledStatementSyntax WithIdentifier(SyntaxToken identifier) => Update(this.LeftColonColonToken, identifier, this.RightColonColonToken, this.Statement);
        public LabeledStatementSyntax WithRightColonColonToken(SyntaxToken rightColonColonToken) => Update(this.LeftColonColonToken, this.Identifier, rightColonColonToken, this.Statement);
        public LabeledStatementSyntax WithStatement(StatementSyntax statement) => Update(this.LeftColonColonToken, this.Identifier, this.RightColonColonToken, statement);
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.BreakStatement"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class BreakStatementSyntax : StatementSyntax
    {

        internal BreakStatementSyntax(InternalSyntax.LuaSyntaxNode green, LuaSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken BreakKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.BreakStatementSyntax)this.Green).breakKeyword, Position, 0);

        internal override SyntaxNode? GetNodeSlot(int index) => null;

        internal override SyntaxNode? GetCachedSlot(int index) => null;

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitBreakStatement(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitBreakStatement(this);

        public BreakStatementSyntax Update(SyntaxToken breakKeyword)
        {
            if (breakKeyword != this.BreakKeyword)
            {
                var newNode = SyntaxFactory.BreakStatement(breakKeyword);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public BreakStatementSyntax WithBreakKeyword(SyntaxToken breakKeyword) => Update(breakKeyword);
    }

    /// <summary>
    /// Represents a goto statement syntax
    /// </summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.GotoStatement"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class GotoStatementSyntax : StatementSyntax
    {
        private IdentifierNameSyntax? name;

        internal GotoStatementSyntax(InternalSyntax.LuaSyntaxNode green, LuaSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>
        /// Gets a SyntaxToken that represents the goto keyword.
        /// </summary>
        public SyntaxToken GotoKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.GotoStatementSyntax)this.Green).gotoKeyword, Position, 0);

        /// <summary>
        /// Gets the name for a goto statement to goto.
        /// </summary>
        public IdentifierNameSyntax Name => GetRed(ref this.name, 1)!;

        public SyntaxToken SemicolonToken
        {
            get
            {
                var slot = ((Syntax.InternalSyntax.GotoStatementSyntax)this.Green).semicolonToken;
                return slot != null ? new SyntaxToken(this, slot, GetChildPosition(2), GetChildIndex(2)) : default;
            }
        }

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.name, 1)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.name : null;

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitGotoStatement(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitGotoStatement(this);

        public GotoStatementSyntax Update(SyntaxToken gotoKeyword, IdentifierNameSyntax name, SyntaxToken semicolonToken)
        {
            if (gotoKeyword != this.GotoKeyword || name != this.Name || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.GotoStatement(gotoKeyword, name, semicolonToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public GotoStatementSyntax WithGotoKeyword(SyntaxToken gotoKeyword) => Update(gotoKeyword, this.Name, this.SemicolonToken);
        public GotoStatementSyntax WithName(IdentifierNameSyntax name) => Update(this.GotoKeyword, name, this.SemicolonToken);
        public GotoStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken) => Update(this.GotoKeyword, this.Name, semicolonToken);
    }

    /// <summary>
    /// Represents a goto statement syntax
    /// </summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.ReturnStatement"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ReturnStatementSyntax : StatementSyntax
    {
        private ExpressionListSyntax? values;

        internal ReturnStatementSyntax(InternalSyntax.LuaSyntaxNode green, LuaSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>
        /// Gets a SyntaxToken that represents the return keyword.
        /// </summary>
        public SyntaxToken ReturnKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.ReturnStatementSyntax)this.Green).returnKeyword, Position, 0);

        /// <summary>
        /// Gets the values to return.
        /// </summary>
        public ExpressionListSyntax? Values => GetRed(ref this.values, 1);

        public SyntaxToken SemicolonToken
        {
            get
            {
                var slot = ((Syntax.InternalSyntax.ReturnStatementSyntax)this.Green).semicolonToken;
                return slot != null ? new SyntaxToken(this, slot, GetChildPosition(2), GetChildIndex(2)) : default;
            }
        }

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.values, 1) : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.values : null;

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitReturnStatement(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitReturnStatement(this);

        public ReturnStatementSyntax Update(SyntaxToken returnKeyword, ExpressionListSyntax? values, SyntaxToken semicolonToken)
        {
            if (returnKeyword != this.ReturnKeyword || values != this.Values || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.ReturnStatement(returnKeyword, values, semicolonToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ReturnStatementSyntax WithReturnKeyword(SyntaxToken returnKeyword) => Update(returnKeyword, this.Values, this.SemicolonToken);
        public ReturnStatementSyntax WithValues(ExpressionListSyntax? values) => Update(this.ReturnKeyword, values, this.SemicolonToken);
        public ReturnStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken) => Update(this.ReturnKeyword, this.Values, semicolonToken);

        public ReturnStatementSyntax AddValuesExpressions(params ExpressionSyntax[] items)
        {
            var values = this.Values ?? SyntaxFactory.ExpressionList();
            return WithValues(values.WithExpressions(values.Expressions.AddRange(items)));
        }
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.DoStatement"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class DoStatementSyntax : StatementSyntax
    {
        private BlockSyntax? block;

        internal DoStatementSyntax(InternalSyntax.LuaSyntaxNode green, LuaSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken DoKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.DoStatementSyntax)this.Green).doKeyword, Position, 0);

        public BlockSyntax Block => GetRed(ref this.block, 1)!;

        public SyntaxToken EndKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.DoStatementSyntax)this.Green).endKeyword, GetChildPosition(2), GetChildIndex(2));

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.block, 1)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.block : null;

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitDoStatement(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitDoStatement(this);

        public DoStatementSyntax Update(SyntaxToken doKeyword, BlockSyntax block, SyntaxToken endKeyword)
        {
            if (doKeyword != this.DoKeyword || block != this.Block || endKeyword != this.EndKeyword)
            {
                var newNode = SyntaxFactory.DoStatement(doKeyword, block, endKeyword);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public DoStatementSyntax WithDoKeyword(SyntaxToken doKeyword) => Update(doKeyword, this.Block, this.EndKeyword);
        public DoStatementSyntax WithBlock(BlockSyntax block) => Update(this.DoKeyword, block, this.EndKeyword);
        public DoStatementSyntax WithEndKeyword(SyntaxToken endKeyword) => Update(this.DoKeyword, this.Block, endKeyword);

        public DoStatementSyntax AddBlockStatements(params StatementSyntax[] items) => WithBlock(this.Block.WithStatements(this.Block.Statements.AddRange(items)));
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.WhileStatement"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class WhileStatementSyntax : StatementSyntax
    {
        private ExpressionSyntax? condition;
        private BlockSyntax? block;

        internal WhileStatementSyntax(InternalSyntax.LuaSyntaxNode green, LuaSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken WhileKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.WhileStatementSyntax)this.Green).whileKeyword, Position, 0);

        public ExpressionSyntax Condition => GetRed(ref this.condition, 1)!;

        public SyntaxToken DoKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.WhileStatementSyntax)this.Green).doKeyword, GetChildPosition(2), GetChildIndex(2));

        public BlockSyntax Block => GetRed(ref this.block, 3)!;

        public SyntaxToken EndKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.WhileStatementSyntax)this.Green).endKeyword, GetChildPosition(4), GetChildIndex(4));

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                1 => GetRed(ref this.condition, 1)!,
                3 => GetRed(ref this.block, 3)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                1 => this.condition,
                3 => this.block,
                _ => null,
            };

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitWhileStatement(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitWhileStatement(this);

        public WhileStatementSyntax Update(SyntaxToken whileKeyword, ExpressionSyntax condition, SyntaxToken doKeyword, BlockSyntax block, SyntaxToken endKeyword)
        {
            if (whileKeyword != this.WhileKeyword || condition != this.Condition || doKeyword != this.DoKeyword || block != this.Block || endKeyword != this.EndKeyword)
            {
                var newNode = SyntaxFactory.WhileStatement(whileKeyword, condition, doKeyword, block, endKeyword);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public WhileStatementSyntax WithWhileKeyword(SyntaxToken whileKeyword) => Update(whileKeyword, this.Condition, this.DoKeyword, this.Block, this.EndKeyword);
        public WhileStatementSyntax WithCondition(ExpressionSyntax condition) => Update(this.WhileKeyword, condition, this.DoKeyword, this.Block, this.EndKeyword);
        public WhileStatementSyntax WithDoKeyword(SyntaxToken doKeyword) => Update(this.WhileKeyword, this.Condition, doKeyword, this.Block, this.EndKeyword);
        public WhileStatementSyntax WithBlock(BlockSyntax block) => Update(this.WhileKeyword, this.Condition, this.DoKeyword, block, this.EndKeyword);
        public WhileStatementSyntax WithEndKeyword(SyntaxToken endKeyword) => Update(this.WhileKeyword, this.Condition, this.DoKeyword, this.Block, endKeyword);

        public WhileStatementSyntax AddBlockStatements(params StatementSyntax[] items) => WithBlock(this.Block.WithStatements(this.Block.Statements.AddRange(items)));
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.RepeatStatement"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class RepeatStatementSyntax : StatementSyntax
    {
        private BlockSyntax? block;
        private ExpressionSyntax? condition;

        internal RepeatStatementSyntax(InternalSyntax.LuaSyntaxNode green, LuaSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken RepeatKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.RepeatStatementSyntax)this.Green).repeatKeyword, Position, 0);

        public BlockSyntax Block => GetRed(ref this.block, 1)!;

        public SyntaxToken UntilKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.RepeatStatementSyntax)this.Green).untilKeyword, GetChildPosition(2), GetChildIndex(2));

        public ExpressionSyntax Condition => GetRed(ref this.condition, 3)!;

        public SyntaxToken SemicolonToken
        {
            get
            {
                var slot = ((Syntax.InternalSyntax.RepeatStatementSyntax)this.Green).semicolonToken;
                return slot != null ? new SyntaxToken(this, slot, GetChildPosition(4), GetChildIndex(4)) : default;
            }
        }

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                1 => GetRed(ref this.block, 1)!,
                3 => GetRed(ref this.condition, 3)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                1 => this.block,
                3 => this.condition,
                _ => null,
            };

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitRepeatStatement(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitRepeatStatement(this);

        public RepeatStatementSyntax Update(SyntaxToken repeatKeyword, BlockSyntax block, SyntaxToken untilKeyword, ExpressionSyntax condition, SyntaxToken semicolonToken)
        {
            if (repeatKeyword != this.RepeatKeyword || block != this.Block || untilKeyword != this.UntilKeyword || condition != this.Condition || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.RepeatStatement(repeatKeyword, block, untilKeyword, condition, semicolonToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public RepeatStatementSyntax WithRepeatKeyword(SyntaxToken repeatKeyword) => Update(repeatKeyword, this.Block, this.UntilKeyword, this.Condition, this.SemicolonToken);
        public RepeatStatementSyntax WithBlock(BlockSyntax block) => Update(this.RepeatKeyword, block, this.UntilKeyword, this.Condition, this.SemicolonToken);
        public RepeatStatementSyntax WithUntilKeyword(SyntaxToken untilKeyword) => Update(this.RepeatKeyword, this.Block, untilKeyword, this.Condition, this.SemicolonToken);
        public RepeatStatementSyntax WithCondition(ExpressionSyntax condition) => Update(this.RepeatKeyword, this.Block, this.UntilKeyword, condition, this.SemicolonToken);
        public RepeatStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken) => Update(this.RepeatKeyword, this.Block, this.UntilKeyword, this.Condition, semicolonToken);

        public RepeatStatementSyntax AddBlockStatements(params StatementSyntax[] items) => WithBlock(this.Block.WithStatements(this.Block.Statements.AddRange(items)));
    }

    /// <summary>
    /// Represents an if statement syntax.
    /// </summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.IfStatement"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class IfStatementSyntax : StatementSyntax
    {
        private ExpressionSyntax? condition;
        private BlockSyntax? block;
        private SyntaxNode? elseIfs;
        private ElseClauseSyntax? @else;

        internal IfStatementSyntax(InternalSyntax.LuaSyntaxNode green, LuaSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>
        /// Gets a SyntaxToken that represents the if keyword.
        /// </summary>
        public SyntaxToken IfKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.IfStatementSyntax)this.Green).ifKeyword, Position, 0);

        /// <summary>
        /// Gets an ExpressionSyntax that represents the condition of the if statement.
        /// </summary>
        public ExpressionSyntax Condition => GetRed(ref this.condition, 1)!;

        public SyntaxToken ThenKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.IfStatementSyntax)this.Green).thenKeyword, GetChildPosition(2), GetChildIndex(2));

        /// <summary>
        /// Gets a StatementSyntax the represents the statement to be executed when the condition is true.
        /// </summary>
        public BlockSyntax Block => GetRed(ref this.block, 3)!;

        /// <summary>
        /// Gets a list of ElseIfClauseSyntax that represents the statement to be executed when the condition is false and its condition is true if such statement exists.
        /// </summary>
        public SyntaxList<ElseIfClauseSyntax> ElseIfs => new SyntaxList<ElseIfClauseSyntax>(GetRed(ref this.elseIfs, 4));

        /// <summary>
        /// Gets an ElseClauseSyntax that represents the statement to be executed when the condition is false if such statement exists.
        /// </summary>
        public ElseClauseSyntax? Else => GetRed(ref this.@else, 5);

        public SyntaxToken EndKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.IfStatementSyntax)this.Green).endKeyword, GetChildPosition(6), GetChildIndex(6));

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                1 => GetRed(ref this.condition, 1)!,
                3 => GetRed(ref this.block, 3)!,
                4 => GetRed(ref this.elseIfs, 4),
                5 => GetRed(ref this.@else, 5),
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                1 => this.condition,
                3 => this.block,
                4 => this.elseIfs,
                5 => this.@else,
                _ => null,
            };

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitIfStatement(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitIfStatement(this);

        public IfStatementSyntax Update(SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken thenKeyword, BlockSyntax block, SyntaxList<ElseIfClauseSyntax> elseIfs, ElseClauseSyntax? @else, SyntaxToken endKeyword)
        {
            if (ifKeyword != this.IfKeyword || condition != this.Condition || thenKeyword != this.ThenKeyword || block != this.Block || elseIfs != this.ElseIfs || @else != this.Else || endKeyword != this.EndKeyword)
            {
                var newNode = SyntaxFactory.IfStatement(ifKeyword, condition, thenKeyword, block, elseIfs, @else, endKeyword);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public IfStatementSyntax WithIfKeyword(SyntaxToken ifKeyword) => Update(ifKeyword, this.Condition, this.ThenKeyword, this.Block, this.ElseIfs, this.Else, this.EndKeyword);
        public IfStatementSyntax WithCondition(ExpressionSyntax condition) => Update(this.IfKeyword, condition, this.ThenKeyword, this.Block, this.ElseIfs, this.Else, this.EndKeyword);
        public IfStatementSyntax WithThenKeyword(SyntaxToken thenKeyword) => Update(this.IfKeyword, this.Condition, thenKeyword, this.Block, this.ElseIfs, this.Else, this.EndKeyword);
        public IfStatementSyntax WithBlock(BlockSyntax block) => Update(this.IfKeyword, this.Condition, this.ThenKeyword, block, this.ElseIfs, this.Else, this.EndKeyword);
        public IfStatementSyntax WithElseIfs(SyntaxList<ElseIfClauseSyntax> elseIfs) => Update(this.IfKeyword, this.Condition, this.ThenKeyword, this.Block, elseIfs, this.Else, this.EndKeyword);
        public IfStatementSyntax WithElse(ElseClauseSyntax? @else) => Update(this.IfKeyword, this.Condition, this.ThenKeyword, this.Block, this.ElseIfs, @else, this.EndKeyword);
        public IfStatementSyntax WithEndKeyword(SyntaxToken endKeyword) => Update(this.IfKeyword, this.Condition, this.ThenKeyword, this.Block, this.ElseIfs, this.Else, endKeyword);

        public IfStatementSyntax AddBlockStatements(params StatementSyntax[] items) => WithBlock(this.Block.WithStatements(this.Block.Statements.AddRange(items)));
        public IfStatementSyntax AddElseIfs(params ElseIfClauseSyntax[] items) => WithElseIfs(this.ElseIfs.AddRange(items));
    }

    /// <summary>Represents an elseif clause syntax.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.ElseIfClause"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ElseIfClauseSyntax : LuaSyntaxNode
    {
        private ExpressionSyntax? condition;
        private BlockSyntax? block;

        internal ElseIfClauseSyntax(InternalSyntax.LuaSyntaxNode green, LuaSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>
        /// Gets a SyntaxToken that represents the elseif keyword.
        /// </summary>
        public SyntaxToken ElseIfKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.ElseIfClauseSyntax)this.Green).elseIfKeyword, Position, 0);

        /// <summary>
        /// Gets an ExpressionSyntax that represents the condition of the elseif clause.
        /// </summary>
        public ExpressionSyntax Condition => GetRed(ref this.condition, 1)!;

        public SyntaxToken ThenKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.ElseIfClauseSyntax)this.Green).thenKeyword, GetChildPosition(2), GetChildIndex(2));

        /// <summary>
        /// Gets a StatementSyntax the represents the statement to be executed when the condition is true.
        /// </summary>
        public BlockSyntax Block => GetRed(ref this.block, 3)!;

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                1 => GetRed(ref this.condition, 1)!,
                3 => GetRed(ref this.block, 3)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                1 => this.condition,
                3 => this.block,
                _ => null,
            };

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitElseIfClause(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitElseIfClause(this);

        public ElseIfClauseSyntax Update(SyntaxToken elseIfKeyword, ExpressionSyntax condition, SyntaxToken thenKeyword, BlockSyntax block)
        {
            if (elseIfKeyword != this.ElseIfKeyword || condition != this.Condition || thenKeyword != this.ThenKeyword || block != this.Block)
            {
                var newNode = SyntaxFactory.ElseIfClause(elseIfKeyword, condition, thenKeyword, block);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ElseIfClauseSyntax WithElseIfKeyword(SyntaxToken elseIfKeyword) => Update(elseIfKeyword, this.Condition, this.ThenKeyword, this.Block);
        public ElseIfClauseSyntax WithCondition(ExpressionSyntax condition) => Update(this.ElseIfKeyword, condition, this.ThenKeyword, this.Block);
        public ElseIfClauseSyntax WithThenKeyword(SyntaxToken thenKeyword) => Update(this.ElseIfKeyword, this.Condition, thenKeyword, this.Block);
        public ElseIfClauseSyntax WithBlock(BlockSyntax block) => Update(this.ElseIfKeyword, this.Condition, this.ThenKeyword, block);

        public ElseIfClauseSyntax AddBlockStatements(params StatementSyntax[] items) => WithBlock(this.Block.WithStatements(this.Block.Statements.AddRange(items)));
    }

    /// <summary>Represents an else statement syntax.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.ElseClause"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ElseClauseSyntax : LuaSyntaxNode
    {
        private StatementSyntax? statement;

        internal ElseClauseSyntax(InternalSyntax.LuaSyntaxNode green, LuaSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>
        /// Gets a SyntaxToken that represents the else keyword.
        /// </summary>
        public SyntaxToken ElseKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.ElseClauseSyntax)this.Green).elseKeyword, Position, 0);

        public StatementSyntax Statement => GetRed(ref this.statement, 1)!;

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.statement, 1)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.statement : null;

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitElseClause(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitElseClause(this);

        public ElseClauseSyntax Update(SyntaxToken elseKeyword, StatementSyntax statement)
        {
            if (elseKeyword != this.ElseKeyword || statement != this.Statement)
            {
                var newNode = SyntaxFactory.ElseClause(elseKeyword, statement);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ElseClauseSyntax WithElseKeyword(SyntaxToken elseKeyword) => Update(elseKeyword, this.Statement);
        public ElseClauseSyntax WithStatement(StatementSyntax statement) => Update(this.ElseKeyword, statement);
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.ForStatement"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ForStatementSyntax : StatementSyntax
    {
        private IdentifierNameSyntax? name;
        private ExpressionSyntax? initial;
        private ExpressionSyntax? limit;
        private ExpressionSyntax? step;
        private BlockSyntax? block;

        internal ForStatementSyntax(InternalSyntax.LuaSyntaxNode green, LuaSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken ForKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.ForStatementSyntax)this.Green).forKeyword, Position, 0);

        public IdentifierNameSyntax Name => GetRed(ref this.name, 1)!;

        public SyntaxToken EqualsToken => new SyntaxToken(this, ((Syntax.InternalSyntax.ForStatementSyntax)this.Green).equalsToken, GetChildPosition(2), GetChildIndex(2));

        public ExpressionSyntax Initial => GetRed(ref this.initial, 3)!;

        public SyntaxToken FirstCommaToken => new SyntaxToken(this, ((Syntax.InternalSyntax.ForStatementSyntax)this.Green).firstCommaToken, GetChildPosition(4), GetChildIndex(4));

        public ExpressionSyntax Limit => GetRed(ref this.limit, 5)!;

        public SyntaxToken SecondCommaToken => new SyntaxToken(this, ((Syntax.InternalSyntax.ForStatementSyntax)this.Green).secondCommaToken, GetChildPosition(6), GetChildIndex(6));

        public ExpressionSyntax Step => GetRed(ref this.step, 7)!;

        public SyntaxToken DoKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.ForStatementSyntax)this.Green).doKeyword, GetChildPosition(8), GetChildIndex(8));

        public BlockSyntax Block => GetRed(ref this.block, 9)!;

        public SyntaxToken EndKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.ForStatementSyntax)this.Green).endKeyword, GetChildPosition(10), GetChildIndex(10));

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                1 => GetRed(ref this.name, 1)!,
                3 => GetRed(ref this.initial, 3)!,
                5 => GetRed(ref this.limit, 5)!,
                7 => GetRed(ref this.step, 7)!,
                9 => GetRed(ref this.block, 9)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                1 => this.name,
                3 => this.initial,
                5 => this.limit,
                7 => this.step,
                9 => this.block,
                _ => null,
            };

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitForStatement(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitForStatement(this);

        public ForStatementSyntax Update(SyntaxToken forKeyword, IdentifierNameSyntax name, SyntaxToken equalsToken, ExpressionSyntax initial, SyntaxToken firstCommaToken, ExpressionSyntax limit, SyntaxToken secondCommaToken, ExpressionSyntax step, SyntaxToken doKeyword, BlockSyntax block, SyntaxToken endKeyword)
        {
            if (forKeyword != this.ForKeyword || name != this.Name || equalsToken != this.EqualsToken || initial != this.Initial || firstCommaToken != this.FirstCommaToken || limit != this.Limit || secondCommaToken != this.SecondCommaToken || step != this.Step || doKeyword != this.DoKeyword || block != this.Block || endKeyword != this.EndKeyword)
            {
                var newNode = SyntaxFactory.ForStatement(forKeyword, name, equalsToken, initial, firstCommaToken, limit, secondCommaToken, step, doKeyword, block, endKeyword);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ForStatementSyntax WithForKeyword(SyntaxToken forKeyword) => Update(forKeyword, this.Name, this.EqualsToken, this.Initial, this.FirstCommaToken, this.Limit, this.SecondCommaToken, this.Step, this.DoKeyword, this.Block, this.EndKeyword);
        public ForStatementSyntax WithName(IdentifierNameSyntax name) => Update(this.ForKeyword, name, this.EqualsToken, this.Initial, this.FirstCommaToken, this.Limit, this.SecondCommaToken, this.Step, this.DoKeyword, this.Block, this.EndKeyword);
        public ForStatementSyntax WithEqualsToken(SyntaxToken equalsToken) => Update(this.ForKeyword, this.Name, equalsToken, this.Initial, this.FirstCommaToken, this.Limit, this.SecondCommaToken, this.Step, this.DoKeyword, this.Block, this.EndKeyword);
        public ForStatementSyntax WithInitial(ExpressionSyntax initial) => Update(this.ForKeyword, this.Name, this.EqualsToken, initial, this.FirstCommaToken, this.Limit, this.SecondCommaToken, this.Step, this.DoKeyword, this.Block, this.EndKeyword);
        public ForStatementSyntax WithFirstCommaToken(SyntaxToken firstCommaToken) => Update(this.ForKeyword, this.Name, this.EqualsToken, this.Initial, firstCommaToken, this.Limit, this.SecondCommaToken, this.Step, this.DoKeyword, this.Block, this.EndKeyword);
        public ForStatementSyntax WithLimit(ExpressionSyntax limit) => Update(this.ForKeyword, this.Name, this.EqualsToken, this.Initial, this.FirstCommaToken, limit, this.SecondCommaToken, this.Step, this.DoKeyword, this.Block, this.EndKeyword);
        public ForStatementSyntax WithSecondCommaToken(SyntaxToken secondCommaToken) => Update(this.ForKeyword, this.Name, this.EqualsToken, this.Initial, this.FirstCommaToken, this.Limit, secondCommaToken, this.Step, this.DoKeyword, this.Block, this.EndKeyword);
        public ForStatementSyntax WithStep(ExpressionSyntax step) => Update(this.ForKeyword, this.Name, this.EqualsToken, this.Initial, this.FirstCommaToken, this.Limit, this.SecondCommaToken, step, this.DoKeyword, this.Block, this.EndKeyword);
        public ForStatementSyntax WithDoKeyword(SyntaxToken doKeyword) => Update(this.ForKeyword, this.Name, this.EqualsToken, this.Initial, this.FirstCommaToken, this.Limit, this.SecondCommaToken, this.Step, doKeyword, this.Block, this.EndKeyword);
        public ForStatementSyntax WithBlock(BlockSyntax block) => Update(this.ForKeyword, this.Name, this.EqualsToken, this.Initial, this.FirstCommaToken, this.Limit, this.SecondCommaToken, this.Step, this.DoKeyword, block, this.EndKeyword);
        public ForStatementSyntax WithEndKeyword(SyntaxToken endKeyword) => Update(this.ForKeyword, this.Name, this.EqualsToken, this.Initial, this.FirstCommaToken, this.Limit, this.SecondCommaToken, this.Step, this.DoKeyword, this.Block, endKeyword);

        public ForStatementSyntax AddBlockStatements(params StatementSyntax[] items) => WithBlock(this.Block.WithStatements(this.Block.Statements.AddRange(items)));
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.Chunk"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ChunkSyntax : LuaSyntaxNode
    {
        private BlockSyntax? block;

        internal ChunkSyntax(InternalSyntax.LuaSyntaxNode green, LuaSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public BlockSyntax Block => GetRedAtZero(ref this.block)!;

        public SyntaxToken EndOfFileToken => new SyntaxToken(this, ((Syntax.InternalSyntax.ChunkSyntax)this.Green).endOfFileToken, GetChildPosition(1), GetChildIndex(1));

        internal override SyntaxNode? GetNodeSlot(int index) => index == 0 ? GetRedAtZero(ref this.block)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 0 ? this.block : null;

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitChunk(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitChunk(this);

        public ChunkSyntax Update(BlockSyntax block, SyntaxToken endOfFileToken)
        {
            if (block != this.Block || endOfFileToken != this.EndOfFileToken)
            {
                var newNode = SyntaxFactory.Chunk(block, endOfFileToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ChunkSyntax WithBlock(BlockSyntax block) => Update(block, this.EndOfFileToken);
        public ChunkSyntax WithEndOfFileToken(SyntaxToken endOfFileToken) => Update(this.Block, endOfFileToken);

        public ChunkSyntax AddBlockStatements(params StatementSyntax[] items) => WithBlock(this.Block.WithStatements(this.Block.Statements.AddRange(items)));
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.Block"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class BlockSyntax : LuaSyntaxNode
    {
        private SyntaxNode? statements;

        internal BlockSyntax(InternalSyntax.LuaSyntaxNode green, LuaSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxList<StatementSyntax> Statements => new SyntaxList<StatementSyntax>(GetRed(ref this.statements, 0));

        internal override SyntaxNode? GetNodeSlot(int index) => index == 0 ? GetRedAtZero(ref this.statements)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 0 ? this.statements : null;

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitBlock(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitBlock(this);

        public BlockSyntax Update(SyntaxList<StatementSyntax> statements)
        {
            if (statements != this.Statements)
            {
                var newNode = SyntaxFactory.Block(statements);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public BlockSyntax WithStatements(SyntaxList<StatementSyntax> statements) => Update(statements);

        public BlockSyntax AddStatements(params StatementSyntax[] items) => WithStatements(this.Statements.AddRange(items));
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.SkippedTokensTrivia"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class SkippedTokensTriviaSyntax : StructuredTriviaSyntax
    {

        internal SkippedTokensTriviaSyntax(InternalSyntax.LuaSyntaxNode green, LuaSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxTokenList Tokens
        {
            get
            {
                var slot = this.Green.GetSlot(0);
                return slot != null ? new SyntaxTokenList(this, slot, Position, 0) : default;
            }
        }

        internal override SyntaxNode? GetNodeSlot(int index) => null;

        internal override SyntaxNode? GetCachedSlot(int index) => null;

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitSkippedTokensTrivia(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitSkippedTokensTrivia(this);

        public SkippedTokensTriviaSyntax Update(SyntaxTokenList tokens)
        {
            if (tokens != this.Tokens)
            {
                var newNode = SyntaxFactory.SkippedTokensTrivia(tokens);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public SkippedTokensTriviaSyntax WithTokens(SyntaxTokenList tokens) => Update(tokens);

        public SkippedTokensTriviaSyntax AddTokens(params SyntaxToken[] items) => WithTokens(this.Tokens.AddRange(items));
    }

    /// <summary>Class which represents the syntax node for parenthesized expression.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.BracketedExpression"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class BracketedExpressionSyntax : LuaSyntaxNode
    {
        private ExpressionSyntax? expression;

        internal BracketedExpressionSyntax(InternalSyntax.LuaSyntaxNode green, LuaSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>SyntaxToken representing the open parenthesis.</summary>
        public SyntaxToken OpenParenToken => new SyntaxToken(this, ((Syntax.InternalSyntax.BracketedExpressionSyntax)this.Green).openParenToken, Position, 0);

        /// <summary>ExpressionSyntax node representing the expression enclosed within the parenthesis.</summary>
        public ExpressionSyntax Expression => GetRed(ref this.expression, 1)!;

        /// <summary>SyntaxToken representing the close parenthesis.</summary>
        public SyntaxToken CloseParenToken => new SyntaxToken(this, ((Syntax.InternalSyntax.BracketedExpressionSyntax)this.Green).closeParenToken, GetChildPosition(2), GetChildIndex(2));

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.expression, 1)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.expression : null;

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitBracketedExpression(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitBracketedExpression(this);

        public BracketedExpressionSyntax Update(SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
        {
            if (openParenToken != this.OpenParenToken || expression != this.Expression || closeParenToken != this.CloseParenToken)
            {
                var newNode = SyntaxFactory.BracketedExpression(openParenToken, expression, closeParenToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public BracketedExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken) => Update(openParenToken, this.Expression, this.CloseParenToken);
        public BracketedExpressionSyntax WithExpression(ExpressionSyntax expression) => Update(this.OpenParenToken, expression, this.CloseParenToken);
        public BracketedExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken) => Update(this.OpenParenToken, this.Expression, closeParenToken);
    }

    /// <summary>Parameter list syntax.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.ParameterList"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ParameterListSyntax : LuaSyntaxNode
    {
        private SyntaxNode? parameters;

        internal ParameterListSyntax(InternalSyntax.LuaSyntaxNode green, LuaSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>Gets the open paren token.</summary>
        public SyntaxToken OpenParenToken => new SyntaxToken(this, ((Syntax.InternalSyntax.ParameterListSyntax)this.Green).openParenToken, Position, 0);

        public SeparatedSyntaxList<ParameterSyntax> Parameters
        {
            get
            {
                var red = GetRed(ref this.parameters, 1);
                return red != null ? new SeparatedSyntaxList<ParameterSyntax>(red, GetChildIndex(1)) : default;
            }
        }

        /// <summary>Gets the close paren token.</summary>
        public SyntaxToken CloseParenToken => new SyntaxToken(this, ((Syntax.InternalSyntax.ParameterListSyntax)this.Green).closeParenToken, GetChildPosition(2), GetChildIndex(2));

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.parameters, 1)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.parameters : null;

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitParameterList(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitParameterList(this);

        public ParameterListSyntax Update(SyntaxToken openParenToken, SeparatedSyntaxList<ParameterSyntax> parameters, SyntaxToken closeParenToken)
        {
            if (openParenToken != this.OpenParenToken || parameters != this.Parameters || closeParenToken != this.CloseParenToken)
            {
                var newNode = SyntaxFactory.ParameterList(openParenToken, parameters, closeParenToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ParameterListSyntax WithOpenParenToken(SyntaxToken openParenToken) => Update(openParenToken, this.Parameters, this.CloseParenToken);
        public ParameterListSyntax WithParameters(SeparatedSyntaxList<ParameterSyntax> parameters) => Update(this.OpenParenToken, parameters, this.CloseParenToken);
        public ParameterListSyntax WithCloseParenToken(SyntaxToken closeParenToken) => Update(this.OpenParenToken, this.Parameters, closeParenToken);

        public ParameterListSyntax AddParameters(params ParameterSyntax[] items) => WithParameters(this.Parameters.AddRange(items));
    }

    /// <summary>Parameter syntax.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.Parameter"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ParameterSyntax : LuaSyntaxNode
    {

        internal ParameterSyntax(InternalSyntax.LuaSyntaxNode green, LuaSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>Gets the identifier.</summary>
        public SyntaxToken Identifier => new SyntaxToken(this, ((Syntax.InternalSyntax.ParameterSyntax)this.Green).identifier, Position, 0);

        internal override SyntaxNode? GetNodeSlot(int index) => null;

        internal override SyntaxNode? GetCachedSlot(int index) => null;

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitParameter(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitParameter(this);

        public ParameterSyntax Update(SyntaxToken identifier)
        {
            if (identifier != this.Identifier)
            {
                var newNode = SyntaxFactory.Parameter(identifier);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ParameterSyntax WithIdentifier(SyntaxToken identifier) => Update(identifier);
    }

    /// <summary>Class which represents the syntax node for the list of fields.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.FieldList"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class FieldListSyntax : LuaSyntaxNode
    {
        private SyntaxNode? fields;

        internal FieldListSyntax(InternalSyntax.LuaSyntaxNode green, LuaSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>SeparatedSyntaxList of FieldSyntax nodes representing the list of fields.</summary>
        public SeparatedSyntaxList<FieldSyntax> Fields
        {
            get
            {
                var red = GetRed(ref this.fields, 0);
                return red != null ? new SeparatedSyntaxList<FieldSyntax>(red, 0) : default;
            }
        }

        internal override SyntaxNode? GetNodeSlot(int index) => index == 0 ? GetRedAtZero(ref this.fields)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 0 ? this.fields : null;

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitFieldList(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitFieldList(this);

        public FieldListSyntax Update(SeparatedSyntaxList<FieldSyntax> fields)
        {
            if (fields != this.Fields)
            {
                var newNode = SyntaxFactory.FieldList(fields);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public FieldListSyntax WithFields(SeparatedSyntaxList<FieldSyntax> fields) => Update(fields);

        public FieldListSyntax AddFields(params FieldSyntax[] items) => WithFields(this.Fields.AddRange(items));
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.Field"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class FieldSyntax : LuaSyntaxNode
    {
        private ExpressionSyntax? expression;
        private IdentifierNameSyntax? name;
        private BracketedExpressionSyntax? key;
        private ExpressionSyntax? value;

        internal FieldSyntax(InternalSyntax.LuaSyntaxNode green, LuaSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public ExpressionSyntax? Expression => GetRedAtZero(ref this.expression);

        /// <summary>IdentifierNameSyntax representing the field name.</summary>
        public IdentifierNameSyntax? Name => GetRed(ref this.name, 1);

        public BracketedExpressionSyntax? Key => GetRed(ref this.key, 2);

        /// <summary>SyntaxToken representing the operator of the assignment expression.</summary>
        public SyntaxToken EqualsToken
        {
            get
            {
                var slot = ((Syntax.InternalSyntax.FieldSyntax)this.Green).equalsToken;
                return slot != null ? new SyntaxToken(this, slot, GetChildPosition(3), GetChildIndex(3)) : default;
            }
        }

        /// <summary>ExpressionSyntax node representing the expression on the right of the assignment operator.</summary>
        public ExpressionSyntax? Value => GetRed(ref this.value, 4);

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                0 => GetRedAtZero(ref this.expression),
                1 => GetRed(ref this.name, 1),
                2 => GetRed(ref this.key, 2),
                4 => GetRed(ref this.value, 4),
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                0 => this.expression,
                1 => this.name,
                2 => this.key,
                4 => this.value,
                _ => null,
            };

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitField(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitField(this);

        public FieldSyntax Update(ExpressionSyntax? expression, IdentifierNameSyntax? name, BracketedExpressionSyntax? key, SyntaxToken equalsToken, ExpressionSyntax? value)
        {
            if (expression != this.Expression || name != this.Name || key != this.Key || equalsToken != this.EqualsToken || value != this.Value)
            {
                var newNode = SyntaxFactory.Field(expression, name, key, equalsToken, value);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public FieldSyntax WithExpression(ExpressionSyntax? expression) => Update(expression, this.Name, this.Key, this.EqualsToken, this.Value);
        public FieldSyntax WithName(IdentifierNameSyntax? name) => Update(this.Expression, name, this.Key, this.EqualsToken, this.Value);
        public FieldSyntax WithKey(BracketedExpressionSyntax? key) => Update(this.Expression, this.Name, key, this.EqualsToken, this.Value);
        public FieldSyntax WithEqualsToken(SyntaxToken equalsToken) => Update(this.Expression, this.Name, this.Key, equalsToken, this.Value);
        public FieldSyntax WithValue(ExpressionSyntax? value) => Update(this.Expression, this.Name, this.Key, this.EqualsToken, value);
    }

    /// <summary>Class which represents the syntax node for the list of arguments.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.ArgumentList"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ArgumentListSyntax : LuaSyntaxNode
    {
        private TableConstructorExpressionSyntax? argumentTable;
        private SyntaxNode? arguments;

        internal ArgumentListSyntax(InternalSyntax.LuaSyntaxNode green, LuaSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public TableConstructorExpressionSyntax? ArgumentTable => GetRedAtZero(ref this.argumentTable);

        /// <summary>SyntaxToken representing open parenthesis.</summary>
        public SyntaxToken OpenParenToken
        {
            get
            {
                var slot = ((Syntax.InternalSyntax.ArgumentListSyntax)this.Green).openParenToken;
                return slot != null ? new SyntaxToken(this, slot, GetChildPosition(1), GetChildIndex(1)) : default;
            }
        }

        /// <summary>SeparatedSyntaxList of ArgumentSyntax representing the list of arguments.</summary>
        public SeparatedSyntaxList<ArgumentSyntax> Arguments
        {
            get
            {
                var red = GetRed(ref this.arguments, 2);
                return red != null ? new SeparatedSyntaxList<ArgumentSyntax>(red, GetChildIndex(2)) : default;
            }
        }

        /// <summary>SyntaxToken representing close parenthesis.</summary>
        public SyntaxToken CloseParenToken
        {
            get
            {
                var slot = ((Syntax.InternalSyntax.ArgumentListSyntax)this.Green).closeParenToken;
                return slot != null ? new SyntaxToken(this, slot, GetChildPosition(3), GetChildIndex(3)) : default;
            }
        }

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                0 => GetRedAtZero(ref this.argumentTable),
                2 => GetRed(ref this.arguments, 2)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                0 => this.argumentTable,
                2 => this.arguments,
                _ => null,
            };

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitArgumentList(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitArgumentList(this);

        public ArgumentListSyntax Update(TableConstructorExpressionSyntax? argumentTable, SyntaxToken openParenToken, SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeParenToken)
        {
            if (argumentTable != this.ArgumentTable || openParenToken != this.OpenParenToken || arguments != this.Arguments || closeParenToken != this.CloseParenToken)
            {
                var newNode = SyntaxFactory.ArgumentList(argumentTable, openParenToken, arguments, closeParenToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ArgumentListSyntax WithArgumentTable(TableConstructorExpressionSyntax? argumentTable) => Update(argumentTable, this.OpenParenToken, this.Arguments, this.CloseParenToken);
        public ArgumentListSyntax WithOpenParenToken(SyntaxToken openParenToken) => Update(this.ArgumentTable, openParenToken, this.Arguments, this.CloseParenToken);
        public ArgumentListSyntax WithArguments(SeparatedSyntaxList<ArgumentSyntax> arguments) => Update(this.ArgumentTable, this.OpenParenToken, arguments, this.CloseParenToken);
        public ArgumentListSyntax WithCloseParenToken(SyntaxToken closeParenToken) => Update(this.ArgumentTable, this.OpenParenToken, this.Arguments, closeParenToken);

        public ArgumentListSyntax AddArgumentTableFields(params FieldListSyntax[] items)
        {
            var argumentTable = this.ArgumentTable ?? SyntaxFactory.TableConstructorExpression();
            return WithArgumentTable(argumentTable.WithFields(argumentTable.Fields.AddRange(items)));
        }
        public ArgumentListSyntax AddArguments(params ArgumentSyntax[] items) => WithArguments(this.Arguments.AddRange(items));
    }

    /// <summary>Class which represents the syntax node for argument.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.Argument"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ArgumentSyntax : LuaSyntaxNode
    {
        private ExpressionSyntax? expression;

        internal ArgumentSyntax(InternalSyntax.LuaSyntaxNode green, LuaSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>ExpressionSyntax node representing the argument.</summary>
        public ExpressionSyntax Expression => GetRedAtZero(ref this.expression)!;

        internal override SyntaxNode? GetNodeSlot(int index) => index == 0 ? GetRedAtZero(ref this.expression)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 0 ? this.expression : null;

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitArgument(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitArgument(this);

        public ArgumentSyntax Update(ExpressionSyntax expression)
        {
            if (expression != this.Expression)
            {
                var newNode = SyntaxFactory.Argument(expression);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ArgumentSyntax WithExpression(ExpressionSyntax expression) => Update(expression);
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.ImplicitSelfCall"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ImplicitSelfCallSyntax : LuaSyntaxNode
    {
        private ExpressionSyntax? expression;
        private IdentifierNameSyntax? name;

        internal ImplicitSelfCallSyntax(InternalSyntax.LuaSyntaxNode green, LuaSyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>ExpressionSyntax node representing the expression part of the implicit self call.</summary>
        public ExpressionSyntax Expression => GetRedAtZero(ref this.expression)!;

        public SyntaxToken ColonToken => new SyntaxToken(this, ((Syntax.InternalSyntax.ImplicitSelfCallSyntax)this.Green).colonToken, GetChildPosition(1), GetChildIndex(1));

        /// <summary>IdentifierNameSyntax representing the identifier name.</summary>
        public IdentifierNameSyntax Name => GetRed(ref this.name, 2)!;

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                0 => GetRedAtZero(ref this.expression)!,
                2 => GetRed(ref this.name, 2)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                0 => this.expression,
                2 => this.name,
                _ => null,
            };

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitImplicitSelfCall(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitImplicitSelfCall(this);

        public ImplicitSelfCallSyntax Update(ExpressionSyntax expression, SyntaxToken colonToken, IdentifierNameSyntax name)
        {
            if (expression != this.Expression || colonToken != this.ColonToken || name != this.Name)
            {
                var newNode = SyntaxFactory.ImplicitSelfCall(expression, colonToken, name);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ImplicitSelfCallSyntax WithExpression(ExpressionSyntax expression) => Update(expression, this.ColonToken, this.Name);
        public ImplicitSelfCallSyntax WithColonToken(SyntaxToken colonToken) => Update(this.Expression, colonToken, this.Name);
        public ImplicitSelfCallSyntax WithName(IdentifierNameSyntax name) => Update(this.Expression, this.ColonToken, name);
    }
}
